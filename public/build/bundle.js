
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop$1() { }
    const identity$1 = x => x;
    function assign$2(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$2($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$1;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen$1(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity$1, tick = noop$1, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                if (info.blocks[i] === block) {
                                    info.blocks[i] = null;
                                }
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.35.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen$1(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
     *
     *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
     *
     */
    (function() {

    // Exit early if we're not running in a browser.
    if (typeof window !== 'object') {
      return;
    }

    // Exit early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
    if ('IntersectionObserver' in window &&
        'IntersectionObserverEntry' in window &&
        'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

      // Minimal polyfill for Edge 15's lack of `isIntersecting`
      // See: https://github.com/w3c/IntersectionObserver/issues/211
      if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
        Object.defineProperty(window.IntersectionObserverEntry.prototype,
          'isIntersecting', {
          get: function () {
            return this.intersectionRatio > 0;
          }
        });
      }
      return;
    }

    /**
     * Returns the embedding frame element, if any.
     * @param {!Document} doc
     * @return {!Element}
     */
    function getFrameElement(doc) {
      try {
        return doc.defaultView && doc.defaultView.frameElement || null;
      } catch (e) {
        // Ignore the error.
        return null;
      }
    }

    /**
     * A local reference to the root document.
     */
    var document = (function(startDoc) {
      var doc = startDoc;
      var frame = getFrameElement(doc);
      while (frame) {
        doc = frame.ownerDocument;
        frame = getFrameElement(doc);
      }
      return doc;
    })(window.document);

    /**
     * An IntersectionObserver registry. This registry exists to hold a strong
     * reference to IntersectionObserver instances currently observing a target
     * element. Without this registry, instances without another reference may be
     * garbage collected.
     */
    var registry = [];

    /**
     * The signal updater for cross-origin intersection. When not null, it means
     * that the polyfill is configured to work in a cross-origin mode.
     * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
     */
    var crossOriginUpdater = null;

    /**
     * The current cross-origin intersection. Only used in the cross-origin mode.
     * @type {DOMRect|ClientRect}
     */
    var crossOriginRect = null;


    /**
     * Creates the global IntersectionObserverEntry constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
     * @param {Object} entry A dictionary of instance properties.
     * @constructor
     */
    function IntersectionObserverEntry(entry) {
      this.time = entry.time;
      this.target = entry.target;
      this.rootBounds = ensureDOMRect(entry.rootBounds);
      this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
      this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
      this.isIntersecting = !!entry.intersectionRect;

      // Calculates the intersection ratio.
      var targetRect = this.boundingClientRect;
      var targetArea = targetRect.width * targetRect.height;
      var intersectionRect = this.intersectionRect;
      var intersectionArea = intersectionRect.width * intersectionRect.height;

      // Sets intersection ratio.
      if (targetArea) {
        // Round the intersection ratio to avoid floating point math issues:
        // https://github.com/w3c/IntersectionObserver/issues/324
        this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
      } else {
        // If area is zero and is intersecting, sets to 1, otherwise to 0
        this.intersectionRatio = this.isIntersecting ? 1 : 0;
      }
    }


    /**
     * Creates the global IntersectionObserver constructor.
     * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
     * @param {Function} callback The function to be invoked after intersection
     *     changes have queued. The function is not invoked if the queue has
     *     been emptied by calling the `takeRecords` method.
     * @param {Object=} opt_options Optional configuration options.
     * @constructor
     */
    function IntersectionObserver(callback, opt_options) {

      var options = opt_options || {};

      if (typeof callback != 'function') {
        throw new Error('callback must be a function');
      }

      if (
        options.root &&
        options.root.nodeType != 1 &&
        options.root.nodeType != 9
      ) {
        throw new Error('root must be a Document or Element');
      }

      // Binds and throttles `this._checkForIntersections`.
      this._checkForIntersections = throttle(
          this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

      // Private properties.
      this._callback = callback;
      this._observationTargets = [];
      this._queuedEntries = [];
      this._rootMarginValues = this._parseRootMargin(options.rootMargin);

      // Public properties.
      this.thresholds = this._initThresholds(options.threshold);
      this.root = options.root || null;
      this.rootMargin = this._rootMarginValues.map(function(margin) {
        return margin.value + margin.unit;
      }).join(' ');

      /** @private @const {!Array<!Document>} */
      this._monitoringDocuments = [];
      /** @private @const {!Array<function()>} */
      this._monitoringUnsubscribes = [];
    }


    /**
     * The minimum interval within which the document will be checked for
     * intersection changes.
     */
    IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


    /**
     * The frequency in which the polyfill polls for intersection changes.
     * this can be updated on a per instance basis and must be set prior to
     * calling `observe` on the first target.
     */
    IntersectionObserver.prototype.POLL_INTERVAL = null;

    /**
     * Use a mutation observer on the root element
     * to detect intersection changes.
     */
    IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


    /**
     * Sets up the polyfill in the cross-origin mode. The result is the
     * updater function that accepts two arguments: `boundingClientRect` and
     * `intersectionRect` - just as these fields would be available to the
     * parent via `IntersectionObserverEntry`. This function should be called
     * each time the iframe receives intersection information from the parent
     * window, e.g. via messaging.
     * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
     */
    IntersectionObserver._setupCrossOriginUpdater = function() {
      if (!crossOriginUpdater) {
        /**
         * @param {DOMRect|ClientRect} boundingClientRect
         * @param {DOMRect|ClientRect} intersectionRect
         */
        crossOriginUpdater = function(boundingClientRect, intersectionRect) {
          if (!boundingClientRect || !intersectionRect) {
            crossOriginRect = getEmptyRect();
          } else {
            crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
          }
          registry.forEach(function(observer) {
            observer._checkForIntersections();
          });
        };
      }
      return crossOriginUpdater;
    };


    /**
     * Resets the cross-origin mode.
     */
    IntersectionObserver._resetCrossOriginUpdater = function() {
      crossOriginUpdater = null;
      crossOriginRect = null;
    };


    /**
     * Starts observing a target element for intersection changes based on
     * the thresholds values.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.observe = function(target) {
      var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
        return item.element == target;
      });

      if (isTargetAlreadyObserved) {
        return;
      }

      if (!(target && target.nodeType == 1)) {
        throw new Error('target must be an Element');
      }

      this._registerInstance();
      this._observationTargets.push({element: target, entry: null});
      this._monitorIntersections(target.ownerDocument);
      this._checkForIntersections();
    };


    /**
     * Stops observing a target element for intersection changes.
     * @param {Element} target The DOM element to observe.
     */
    IntersectionObserver.prototype.unobserve = function(target) {
      this._observationTargets =
          this._observationTargets.filter(function(item) {
            return item.element != target;
          });
      this._unmonitorIntersections(target.ownerDocument);
      if (this._observationTargets.length == 0) {
        this._unregisterInstance();
      }
    };


    /**
     * Stops observing all target elements for intersection changes.
     */
    IntersectionObserver.prototype.disconnect = function() {
      this._observationTargets = [];
      this._unmonitorAllIntersections();
      this._unregisterInstance();
    };


    /**
     * Returns any queue entries that have not yet been reported to the
     * callback and clears the queue. This can be used in conjunction with the
     * callback to obtain the absolute most up-to-date intersection information.
     * @return {Array} The currently queued entries.
     */
    IntersectionObserver.prototype.takeRecords = function() {
      var records = this._queuedEntries.slice();
      this._queuedEntries = [];
      return records;
    };


    /**
     * Accepts the threshold value from the user configuration object and
     * returns a sorted array of unique threshold values. If a value is not
     * between 0 and 1 and error is thrown.
     * @private
     * @param {Array|number=} opt_threshold An optional threshold value or
     *     a list of threshold values, defaulting to [0].
     * @return {Array} A sorted list of unique and valid threshold values.
     */
    IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
      var threshold = opt_threshold || [0];
      if (!Array.isArray(threshold)) threshold = [threshold];

      return threshold.sort().filter(function(t, i, a) {
        if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
          throw new Error('threshold must be a number between 0 and 1 inclusively');
        }
        return t !== a[i - 1];
      });
    };


    /**
     * Accepts the rootMargin value from the user configuration object
     * and returns an array of the four margin values as an object containing
     * the value and unit properties. If any of the values are not properly
     * formatted or use a unit other than px or %, and error is thrown.
     * @private
     * @param {string=} opt_rootMargin An optional rootMargin value,
     *     defaulting to '0px'.
     * @return {Array<Object>} An array of margin objects with the keys
     *     value and unit.
     */
    IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
      var marginString = opt_rootMargin || '0px';
      var margins = marginString.split(/\s+/).map(function(margin) {
        var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
        if (!parts) {
          throw new Error('rootMargin must be specified in pixels or percent');
        }
        return {value: parseFloat(parts[1]), unit: parts[2]};
      });

      // Handles shorthand.
      margins[1] = margins[1] || margins[0];
      margins[2] = margins[2] || margins[0];
      margins[3] = margins[3] || margins[1];

      return margins;
    };


    /**
     * Starts polling for intersection changes if the polling is not already
     * happening, and if the page's visibility state is visible.
     * @param {!Document} doc
     * @private
     */
    IntersectionObserver.prototype._monitorIntersections = function(doc) {
      var win = doc.defaultView;
      if (!win) {
        // Already destroyed.
        return;
      }
      if (this._monitoringDocuments.indexOf(doc) != -1) {
        // Already monitoring.
        return;
      }

      // Private state for monitoring.
      var callback = this._checkForIntersections;
      var monitoringInterval = null;
      var domObserver = null;

      // If a poll interval is set, use polling instead of listening to
      // resize and scroll events or DOM mutations.
      if (this.POLL_INTERVAL) {
        monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
      } else {
        addEvent(win, 'resize', callback, true);
        addEvent(doc, 'scroll', callback, true);
        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
          domObserver = new win.MutationObserver(callback);
          domObserver.observe(doc, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        }
      }

      this._monitoringDocuments.push(doc);
      this._monitoringUnsubscribes.push(function() {
        // Get the window object again. When a friendly iframe is destroyed, it
        // will be null.
        var win = doc.defaultView;

        if (win) {
          if (monitoringInterval) {
            win.clearInterval(monitoringInterval);
          }
          removeEvent(win, 'resize', callback, true);
        }

        removeEvent(doc, 'scroll', callback, true);
        if (domObserver) {
          domObserver.disconnect();
        }
      });

      // Also monitor the parent.
      var rootDoc =
        (this.root && (this.root.ownerDocument || this.root)) || document;
      if (doc != rootDoc) {
        var frame = getFrameElement(doc);
        if (frame) {
          this._monitorIntersections(frame.ownerDocument);
        }
      }
    };


    /**
     * Stops polling for intersection changes.
     * @param {!Document} doc
     * @private
     */
    IntersectionObserver.prototype._unmonitorIntersections = function(doc) {
      var index = this._monitoringDocuments.indexOf(doc);
      if (index == -1) {
        return;
      }

      var rootDoc =
        (this.root && (this.root.ownerDocument || this.root)) || document;

      // Check if any dependent targets are still remaining.
      var hasDependentTargets =
          this._observationTargets.some(function(item) {
            var itemDoc = item.element.ownerDocument;
            // Target is in this context.
            if (itemDoc == doc) {
              return true;
            }
            // Target is nested in this context.
            while (itemDoc && itemDoc != rootDoc) {
              var frame = getFrameElement(itemDoc);
              itemDoc = frame && frame.ownerDocument;
              if (itemDoc == doc) {
                return true;
              }
            }
            return false;
          });
      if (hasDependentTargets) {
        return;
      }

      // Unsubscribe.
      var unsubscribe = this._monitoringUnsubscribes[index];
      this._monitoringDocuments.splice(index, 1);
      this._monitoringUnsubscribes.splice(index, 1);
      unsubscribe();

      // Also unmonitor the parent.
      if (doc != rootDoc) {
        var frame = getFrameElement(doc);
        if (frame) {
          this._unmonitorIntersections(frame.ownerDocument);
        }
      }
    };


    /**
     * Stops polling for intersection changes.
     * @param {!Document} doc
     * @private
     */
    IntersectionObserver.prototype._unmonitorAllIntersections = function() {
      var unsubscribes = this._monitoringUnsubscribes.slice(0);
      this._monitoringDocuments.length = 0;
      this._monitoringUnsubscribes.length = 0;
      for (var i = 0; i < unsubscribes.length; i++) {
        unsubscribes[i]();
      }
    };


    /**
     * Scans each observation target for intersection changes and adds them
     * to the internal entries queue. If new entries are found, it
     * schedules the callback to be invoked.
     * @private
     */
    IntersectionObserver.prototype._checkForIntersections = function() {
      if (!this.root && crossOriginUpdater && !crossOriginRect) {
        // Cross origin monitoring, but no initial data available yet.
        return;
      }

      var rootIsInDom = this._rootIsInDom();
      var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

      this._observationTargets.forEach(function(item) {
        var target = item.element;
        var targetRect = getBoundingClientRect(target);
        var rootContainsTarget = this._rootContainsTarget(target);
        var oldEntry = item.entry;
        var intersectionRect = rootIsInDom && rootContainsTarget &&
            this._computeTargetAndRootIntersection(target, targetRect, rootRect);

        var rootBounds = null;
        if (!this._rootContainsTarget(target)) {
          rootBounds = getEmptyRect();
        } else if (!crossOriginUpdater || this.root) {
          rootBounds = rootRect;
        }

        var newEntry = item.entry = new IntersectionObserverEntry({
          time: now(),
          target: target,
          boundingClientRect: targetRect,
          rootBounds: rootBounds,
          intersectionRect: intersectionRect
        });

        if (!oldEntry) {
          this._queuedEntries.push(newEntry);
        } else if (rootIsInDom && rootContainsTarget) {
          // If the new entry intersection ratio has crossed any of the
          // thresholds, add a new entry.
          if (this._hasCrossedThreshold(oldEntry, newEntry)) {
            this._queuedEntries.push(newEntry);
          }
        } else {
          // If the root is not in the DOM or target is not contained within
          // root but the previous entry for this target had an intersection,
          // add a new record indicating removal.
          if (oldEntry && oldEntry.isIntersecting) {
            this._queuedEntries.push(newEntry);
          }
        }
      }, this);

      if (this._queuedEntries.length) {
        this._callback(this.takeRecords(), this);
      }
    };


    /**
     * Accepts a target and root rect computes the intersection between then
     * following the algorithm in the spec.
     * TODO(philipwalton): at this time clip-path is not considered.
     * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
     * @param {Element} target The target DOM element
     * @param {Object} targetRect The bounding rect of the target.
     * @param {Object} rootRect The bounding rect of the root after being
     *     expanded by the rootMargin value.
     * @return {?Object} The final intersection rect object or undefined if no
     *     intersection is found.
     * @private
     */
    IntersectionObserver.prototype._computeTargetAndRootIntersection =
        function(target, targetRect, rootRect) {
      // If the element isn't displayed, an intersection can't happen.
      if (window.getComputedStyle(target).display == 'none') return;

      var intersectionRect = targetRect;
      var parent = getParentNode(target);
      var atRoot = false;

      while (!atRoot && parent) {
        var parentRect = null;
        var parentComputedStyle = parent.nodeType == 1 ?
            window.getComputedStyle(parent) : {};

        // If the parent isn't displayed, an intersection can't happen.
        if (parentComputedStyle.display == 'none') return null;

        if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {
          atRoot = true;
          if (parent == this.root || parent == document) {
            if (crossOriginUpdater && !this.root) {
              if (!crossOriginRect ||
                  crossOriginRect.width == 0 && crossOriginRect.height == 0) {
                // A 0-size cross-origin intersection means no-intersection.
                parent = null;
                parentRect = null;
                intersectionRect = null;
              } else {
                parentRect = crossOriginRect;
              }
            } else {
              parentRect = rootRect;
            }
          } else {
            // Check if there's a frame that can be navigated to.
            var frame = getParentNode(parent);
            var frameRect = frame && getBoundingClientRect(frame);
            var frameIntersect =
                frame &&
                this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
            if (frameRect && frameIntersect) {
              parent = frame;
              parentRect = convertFromParentRect(frameRect, frameIntersect);
            } else {
              parent = null;
              intersectionRect = null;
            }
          }
        } else {
          // If the element has a non-visible overflow, and it's not the <body>
          // or <html> element, update the intersection rect.
          // Note: <body> and <html> cannot be clipped to a rect that's not also
          // the document rect, so no need to compute a new intersection.
          var doc = parent.ownerDocument;
          if (parent != doc.body &&
              parent != doc.documentElement &&
              parentComputedStyle.overflow != 'visible') {
            parentRect = getBoundingClientRect(parent);
          }
        }

        // If either of the above conditionals set a new parentRect,
        // calculate new intersection data.
        if (parentRect) {
          intersectionRect = computeRectIntersection(parentRect, intersectionRect);
        }
        if (!intersectionRect) break;
        parent = parent && getParentNode(parent);
      }
      return intersectionRect;
    };


    /**
     * Returns the root rect after being expanded by the rootMargin value.
     * @return {ClientRect} The expanded root rect.
     * @private
     */
    IntersectionObserver.prototype._getRootRect = function() {
      var rootRect;
      if (this.root && !isDoc(this.root)) {
        rootRect = getBoundingClientRect(this.root);
      } else {
        // Use <html>/<body> instead of window since scroll bars affect size.
        var doc = isDoc(this.root) ? this.root : document;
        var html = doc.documentElement;
        var body = doc.body;
        rootRect = {
          top: 0,
          left: 0,
          right: html.clientWidth || body.clientWidth,
          width: html.clientWidth || body.clientWidth,
          bottom: html.clientHeight || body.clientHeight,
          height: html.clientHeight || body.clientHeight
        };
      }
      return this._expandRectByRootMargin(rootRect);
    };


    /**
     * Accepts a rect and expands it by the rootMargin value.
     * @param {DOMRect|ClientRect} rect The rect object to expand.
     * @return {ClientRect} The expanded rect.
     * @private
     */
    IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
      var margins = this._rootMarginValues.map(function(margin, i) {
        return margin.unit == 'px' ? margin.value :
            margin.value * (i % 2 ? rect.width : rect.height) / 100;
      });
      var newRect = {
        top: rect.top - margins[0],
        right: rect.right + margins[1],
        bottom: rect.bottom + margins[2],
        left: rect.left - margins[3]
      };
      newRect.width = newRect.right - newRect.left;
      newRect.height = newRect.bottom - newRect.top;

      return newRect;
    };


    /**
     * Accepts an old and new entry and returns true if at least one of the
     * threshold values has been crossed.
     * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
     *    particular target element or null if no previous entry exists.
     * @param {IntersectionObserverEntry} newEntry The current entry for a
     *    particular target element.
     * @return {boolean} Returns true if a any threshold has been crossed.
     * @private
     */
    IntersectionObserver.prototype._hasCrossedThreshold =
        function(oldEntry, newEntry) {

      // To make comparing easier, an entry that has a ratio of 0
      // but does not actually intersect is given a value of -1
      var oldRatio = oldEntry && oldEntry.isIntersecting ?
          oldEntry.intersectionRatio || 0 : -1;
      var newRatio = newEntry.isIntersecting ?
          newEntry.intersectionRatio || 0 : -1;

      // Ignore unchanged ratios
      if (oldRatio === newRatio) return;

      for (var i = 0; i < this.thresholds.length; i++) {
        var threshold = this.thresholds[i];

        // Return true if an entry matches a threshold or if the new ratio
        // and the old ratio are on the opposite sides of a threshold.
        if (threshold == oldRatio || threshold == newRatio ||
            threshold < oldRatio !== threshold < newRatio) {
          return true;
        }
      }
    };


    /**
     * Returns whether or not the root element is an element and is in the DOM.
     * @return {boolean} True if the root element is an element and is in the DOM.
     * @private
     */
    IntersectionObserver.prototype._rootIsInDom = function() {
      return !this.root || containsDeep(document, this.root);
    };


    /**
     * Returns whether or not the target element is a child of root.
     * @param {Element} target The target element to check.
     * @return {boolean} True if the target element is a child of root.
     * @private
     */
    IntersectionObserver.prototype._rootContainsTarget = function(target) {
      var rootDoc =
        (this.root && (this.root.ownerDocument || this.root)) || document;
      return (
        containsDeep(rootDoc, target) &&
        (!this.root || rootDoc == target.ownerDocument)
      );
    };


    /**
     * Adds the instance to the global IntersectionObserver registry if it isn't
     * already present.
     * @private
     */
    IntersectionObserver.prototype._registerInstance = function() {
      if (registry.indexOf(this) < 0) {
        registry.push(this);
      }
    };


    /**
     * Removes the instance from the global IntersectionObserver registry.
     * @private
     */
    IntersectionObserver.prototype._unregisterInstance = function() {
      var index = registry.indexOf(this);
      if (index != -1) registry.splice(index, 1);
    };


    /**
     * Returns the result of the performance.now() method or null in browsers
     * that don't support the API.
     * @return {number} The elapsed time since the page was requested.
     */
    function now() {
      return window.performance && performance.now && performance.now();
    }


    /**
     * Throttles a function and delays its execution, so it's only called at most
     * once within a given time period.
     * @param {Function} fn The function to throttle.
     * @param {number} timeout The amount of time that must pass before the
     *     function can be called again.
     * @return {Function} The throttled function.
     */
    function throttle(fn, timeout) {
      var timer = null;
      return function () {
        if (!timer) {
          timer = setTimeout(function() {
            fn();
            timer = null;
          }, timeout);
        }
      };
    }


    /**
     * Adds an event handler to a DOM node ensuring cross-browser compatibility.
     * @param {Node} node The DOM node to add the event handler to.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to add.
     * @param {boolean} opt_useCapture Optionally adds the even to the capture
     *     phase. Note: this only works in modern browsers.
     */
    function addEvent(node, event, fn, opt_useCapture) {
      if (typeof node.addEventListener == 'function') {
        node.addEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.attachEvent == 'function') {
        node.attachEvent('on' + event, fn);
      }
    }


    /**
     * Removes a previously added event handler from a DOM node.
     * @param {Node} node The DOM node to remove the event handler from.
     * @param {string} event The event name.
     * @param {Function} fn The event handler to remove.
     * @param {boolean} opt_useCapture If the event handler was added with this
     *     flag set to true, it should be set to true here in order to remove it.
     */
    function removeEvent(node, event, fn, opt_useCapture) {
      if (typeof node.removeEventListener == 'function') {
        node.removeEventListener(event, fn, opt_useCapture || false);
      }
      else if (typeof node.detatchEvent == 'function') {
        node.detatchEvent('on' + event, fn);
      }
    }


    /**
     * Returns the intersection between two rect objects.
     * @param {Object} rect1 The first rect.
     * @param {Object} rect2 The second rect.
     * @return {?Object|?ClientRect} The intersection rect or undefined if no
     *     intersection is found.
     */
    function computeRectIntersection(rect1, rect2) {
      var top = Math.max(rect1.top, rect2.top);
      var bottom = Math.min(rect1.bottom, rect2.bottom);
      var left = Math.max(rect1.left, rect2.left);
      var right = Math.min(rect1.right, rect2.right);
      var width = right - left;
      var height = bottom - top;

      return (width >= 0 && height >= 0) && {
        top: top,
        bottom: bottom,
        left: left,
        right: right,
        width: width,
        height: height
      } || null;
    }


    /**
     * Shims the native getBoundingClientRect for compatibility with older IE.
     * @param {Element} el The element whose bounding rect to get.
     * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
     */
    function getBoundingClientRect(el) {
      var rect;

      try {
        rect = el.getBoundingClientRect();
      } catch (err) {
        // Ignore Windows 7 IE11 "Unspecified error"
        // https://github.com/w3c/IntersectionObserver/pull/205
      }

      if (!rect) return getEmptyRect();

      // Older IE
      if (!(rect.width && rect.height)) {
        rect = {
          top: rect.top,
          right: rect.right,
          bottom: rect.bottom,
          left: rect.left,
          width: rect.right - rect.left,
          height: rect.bottom - rect.top
        };
      }
      return rect;
    }


    /**
     * Returns an empty rect object. An empty rect is returned when an element
     * is not in the DOM.
     * @return {ClientRect} The empty rect.
     */
    function getEmptyRect() {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        width: 0,
        height: 0
      };
    }


    /**
     * Ensure that the result has all of the necessary fields of the DOMRect.
     * Specifically this ensures that `x` and `y` fields are set.
     *
     * @param {?DOMRect|?ClientRect} rect
     * @return {?DOMRect}
     */
    function ensureDOMRect(rect) {
      // A `DOMRect` object has `x` and `y` fields.
      if (!rect || 'x' in rect) {
        return rect;
      }
      // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
      // for internally calculated Rect objects. For the purposes of
      // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
      // for these fields.
      return {
        top: rect.top,
        y: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        x: rect.left,
        right: rect.right,
        width: rect.width,
        height: rect.height
      };
    }


    /**
     * Inverts the intersection and bounding rect from the parent (frame) BCR to
     * the local BCR space.
     * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
     * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
     * @return {ClientRect} The local root bounding rect for the parent's children.
     */
    function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
      var top = parentIntersectionRect.top - parentBoundingRect.top;
      var left = parentIntersectionRect.left - parentBoundingRect.left;
      return {
        top: top,
        left: left,
        height: parentIntersectionRect.height,
        width: parentIntersectionRect.width,
        bottom: top + parentIntersectionRect.height,
        right: left + parentIntersectionRect.width
      };
    }


    /**
     * Checks to see if a parent element contains a child element (including inside
     * shadow DOM).
     * @param {Node} parent The parent element.
     * @param {Node} child The child element.
     * @return {boolean} True if the parent node contains the child node.
     */
    function containsDeep(parent, child) {
      var node = child;
      while (node) {
        if (node == parent) return true;

        node = getParentNode(node);
      }
      return false;
    }


    /**
     * Gets the parent node of an element or its host element if the parent node
     * is a shadow root.
     * @param {Node} node The node whose parent to get.
     * @return {Node|null} The parent node or null if no parent exists.
     */
    function getParentNode(node) {
      var parent = node.parentNode;

      if (node.nodeType == /* DOCUMENT */ 9 && node != document) {
        // If this node is a document node, look for the embedding frame.
        return getFrameElement(node);
      }

      // If the parent has element that is assigned through shadow root slot
      if (parent && parent.assignedSlot) {
        parent = parent.assignedSlot.parentNode;
      }

      if (parent && parent.nodeType == 11 && parent.host) {
        // If the parent is a shadow root, return the host element.
        return parent.host;
      }

      return parent;
    }

    /**
     * Returns true if `node` is a Document.
     * @param {!Node} node
     * @returns {boolean}
     */
    function isDoc(node) {
      return node && node.nodeType === 9;
    }


    // Exposes the constructors globally.
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;

    }());

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$1;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$1;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const LOCATION = {};
    const ROUTER = {};

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    function getLocation(source) {
      return {
        ...source.location,
        state: source.history.state,
        key: (source.history.state && source.history.state.key) || "initial"
      };
    }

    function createHistory(source, options) {
      const listeners = [];
      let location = getLocation(source);

      return {
        get location() {
          return location;
        },

        listen(listener) {
          listeners.push(listener);

          const popstateListener = () => {
            location = getLocation(source);
            listener({ location, action: "POP" });
          };

          source.addEventListener("popstate", popstateListener);

          return () => {
            source.removeEventListener("popstate", popstateListener);

            const index = listeners.indexOf(listener);
            listeners.splice(index, 1);
          };
        },

        navigate(to, { state, replace = false } = {}) {
          state = { ...state, key: Date.now() + "" };
          // try...catch iOS Safari limits to 100 pushState calls
          try {
            if (replace) {
              source.history.replaceState(state, null, to);
            } else {
              source.history.pushState(state, null, to);
            }
          } catch (e) {
            source.location[replace ? "replace" : "assign"](to);
          }

          location = getLocation(source);
          listeners.forEach(listener => listener({ location, action: "PUSH" }));
        }
      };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
      let index = 0;
      const stack = [{ pathname: initialPathname, search: "" }];
      const states = [];

      return {
        get location() {
          return stack[index];
        },
        addEventListener(name, fn) {},
        removeEventListener(name, fn) {},
        history: {
          get entries() {
            return stack;
          },
          get index() {
            return index;
          },
          get state() {
            return states[index];
          },
          pushState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            index++;
            stack.push({ pathname, search });
            states.push(state);
          },
          replaceState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            stack[index] = { pathname, search };
            states[index] = state;
          }
        }
      };
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = Boolean(
      typeof window !== "undefined" &&
        window.document &&
        window.document.createElement
    );
    const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
    const { navigate } = globalHistory;

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    const paramRe = /^:(.+)/;

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    function isRootSegment(segment) {
      return segment === "";
    }

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    function isDynamic(segment) {
      return paramRe.test(segment);
    }

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    function isSplat(segment) {
      return segment[0] === "*";
    }

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri) {
      return (
        uri
          // Strip starting/ending `/`
          .replace(/(^\/+|\/+$)/g, "")
          .split("/")
      );
    }

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    function stripSlashes(str) {
      return str.replace(/(^\/+|\/+$)/g, "");
    }

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
      const score = route.default
        ? 0
        : segmentize(route.path).reduce((score, segment) => {
            score += SEGMENT_POINTS;

            if (isRootSegment(segment)) {
              score += ROOT_POINTS;
            } else if (isDynamic(segment)) {
              score += DYNAMIC_POINTS;
            } else if (isSplat(segment)) {
              score -= SEGMENT_POINTS + SPLAT_PENALTY;
            } else {
              score += STATIC_POINTS;
            }

            return score;
          }, 0);

      return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
      return (
        routes
          .map(rankRoute)
          // If two routes have the exact same score, we go by index instead
          .sort((a, b) =>
            a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
          )
      );
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { path, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick$1(routes, uri) {
      let match;
      let default_;

      const [uriPathname] = uri.split("?");
      const uriSegments = segmentize(uriPathname);
      const isRootUri = uriSegments[0] === "";
      const ranked = rankRoutes(routes);

      for (let i = 0, l = ranked.length; i < l; i++) {
        const route = ranked[i].route;
        let missed = false;

        if (route.default) {
          default_ = {
            route,
            params: {},
            uri
          };
          continue;
        }

        const routeSegments = segmentize(route.path);
        const params = {};
        const max = Math.max(uriSegments.length, routeSegments.length);
        let index = 0;

        for (; index < max; index++) {
          const routeSegment = routeSegments[index];
          const uriSegment = uriSegments[index];

          if (routeSegment !== undefined && isSplat(routeSegment)) {
            // Hit a splat, just grab the rest, and return a match
            // uri:   /files/documents/work
            // route: /files/* or /files/*splatname
            const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

            params[splatName] = uriSegments
              .slice(index)
              .map(decodeURIComponent)
              .join("/");
            break;
          }

          if (uriSegment === undefined) {
            // URI is shorter than the route, no match
            // uri:   /users
            // route: /users/:userId
            missed = true;
            break;
          }

          let dynamicMatch = paramRe.exec(routeSegment);

          if (dynamicMatch && !isRootUri) {
            const value = decodeURIComponent(uriSegment);
            params[dynamicMatch[1]] = value;
          } else if (routeSegment !== uriSegment) {
            // Current segments don't match, not dynamic, not splat, so no match
            // uri:   /users/123/settings
            // route: /users/:id/profile
            missed = true;
            break;
          }
        }

        if (!missed) {
          match = {
            route,
            params,
            uri: "/" + uriSegments.slice(0, index).join("/")
          };
          break;
        }
      }

      return match || default_ || null;
    }

    /**
     * Check if the `path` matches the `uri`.
     * @param {string} path
     * @param {string} uri
     * @return {?object}
     */
    function match$1(route, uri) {
      return pick$1([route], uri);
    }

    /**
     * Combines the `basepath` and the `path` into one path.
     * @param {string} basepath
     * @param {string} path
     */
    function combinePaths(basepath, path) {
      return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
    }

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
      return (
        !event.defaultPrevented &&
        event.button === 0 &&
        !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
      );
    }

    function hostMatches(anchor) {
      const host = location.host;
      return (
        anchor.host == host ||
        // svelte seems to kill anchor.host value in ie11, so fall back to checking href
        anchor.href.indexOf(`https://${host}`) === 0 ||
        anchor.href.indexOf(`http://${host}`) === 0
      )
    }

    /* node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.35.0 */

    function create_fragment$t(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $base;
    	let $location;
    	let $routes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, ['default']);
    	let { basepath = "/" } = $$props;
    	let { url = null } = $$props;
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const routes = writable([]);
    	validate_store(routes, "routes");
    	component_subscribe($$self, routes, value => $$invalidate(7, $routes = value));
    	const activeRoute = writable(null);
    	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

    	// If locationContext is not set, this is the topmost Router in the tree.
    	// If the `url` prop is given we force the location to it.
    	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(6, $location = value));

    	// If routerContext is set, the routerBase of the parent Router
    	// will be the base for this Router's descendants.
    	// If routerContext is not set, the path and resolved uri will both
    	// have the value of the basepath prop.
    	const base = routerContext
    	? routerContext.routerBase
    	: writable({ path: basepath, uri: basepath });

    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate(5, $base = value));

    	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    		// If there is no activeRoute, the routerBase will be identical to the base.
    		if (activeRoute === null) {
    			return base;
    		}

    		const { path: basepath } = base;
    		const { route, uri } = activeRoute;

    		// Remove the potential /* or /*splatname from
    		// the end of the child Routes relative paths.
    		const path = route.default
    		? basepath
    		: route.path.replace(/\*.*$/, "");

    		return { path, uri };
    	});

    	function registerRoute(route) {
    		const { path: basepath } = $base;
    		let { path } = route;

    		// We store the original path in the _path property so we can reuse
    		// it when the basepath changes. The only thing that matters is that
    		// the route reference is intact, so mutation is fine.
    		route._path = path;

    		route.path = combinePaths(basepath, path);

    		if (typeof window === "undefined") {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match$1(route, $location.pathname);

    			if (matchingRoute) {
    				activeRoute.set(matchingRoute);
    				hasActiveRoute = true;
    			}
    		} else {
    			routes.update(rs => {
    				rs.push(route);
    				return rs;
    			});
    		}
    	}

    	function unregisterRoute(route) {
    		routes.update(rs => {
    			const index = rs.indexOf(route);
    			rs.splice(index, 1);
    			return rs;
    		});
    	}

    	if (!locationContext) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = globalHistory.listen(history => {
    				location.set(history.location);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute
    	});

    	const writable_props = ["basepath", "url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		derived,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		pick: pick$1,
    		match: match$1,
    		stripSlashes,
    		combinePaths,
    		basepath,
    		url,
    		locationContext,
    		routerContext,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		location,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute,
    		$base,
    		$location,
    		$routes
    	});

    	$$self.$inject_state = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$base*/ 32) {
    			// This reactive statement will update all the Routes' path when
    			// the basepath changes.
    			{
    				const { path: basepath } = $base;

    				routes.update(rs => {
    					rs.forEach(r => r.path = combinePaths(basepath, r._path));
    					return rs;
    				});
    			}
    		}

    		if ($$self.$$.dirty & /*$routes, $location*/ 192) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			{
    				const bestMatch = pick$1($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}
    	};

    	return [
    		routes,
    		location,
    		base,
    		basepath,
    		url,
    		$base,
    		$location,
    		$routes,
    		$$scope,
    		slots
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { basepath: 3, url: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.35.0 */

    const get_default_slot_changes$1 = dirty => ({
    	params: dirty & /*routeParams*/ 4,
    	location: dirty & /*$location*/ 16
    });

    const get_default_slot_context$1 = ctx => ({
    	params: /*routeParams*/ ctx[2],
    	location: /*$location*/ ctx[4]
    });

    // (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
    function create_if_block$j(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$f, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {:else}
    function create_else_block$7(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 532) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(43:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if component !== null}
    function create_if_block_1$f(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[4] },
    		/*routeParams*/ ctx[2],
    		/*routeProps*/ ctx[3]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$2(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 28)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
    					dirty & /*routeParams*/ 4 && get_spread_object(/*routeParams*/ ctx[2]),
    					dirty & /*routeProps*/ 8 && get_spread_object(/*routeProps*/ ctx[3])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(41:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$activeRoute*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Route", slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(1, $activeRoute = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

    	const route = {
    		path,
    		// If no path prop is given, this Route will act as the default Route
    		// that is rendered if no other Route in the Router is a match.
    		default: path === ""
    	};

    	let routeParams = {};
    	let routeProps = {};
    	registerRoute(route);

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway.
    	if (typeof window !== "undefined") {
    		onDestroy(() => {
    			unregisterRoute(route);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign$2(assign$2({}, $$props), exclude_internal_props($$new_props)));
    		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onDestroy,
    		ROUTER,
    		LOCATION,
    		path,
    		component,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		location,
    		route,
    		routeParams,
    		routeProps,
    		$activeRoute,
    		$location
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign$2(assign$2({}, $$props), $$new_props));
    		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
    		if ("routeParams" in $$props) $$invalidate(2, routeParams = $$new_props.routeParams);
    		if ("routeProps" in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeRoute*/ 2) {
    			if ($activeRoute && $activeRoute.route === route) {
    				$$invalidate(2, routeParams = $activeRoute.params);
    			}
    		}

    		{
    			const { path, component, ...rest } = $$props;
    			$$invalidate(3, routeProps = rest);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		$activeRoute,
    		routeParams,
    		routeProps,
    		$location,
    		activeRoute,
    		location,
    		route,
    		path,
    		$$scope,
    		slots
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { path: 8, component: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * An action to be added at a root element of your application to
     * capture all relative links and push them onto the history stack.
     *
     * Example:
     * ```html
     * <div use:links>
     *   <Router>
     *     <Route path="/" component={Home} />
     *     <Route path="/p/:projectId/:docId?" component={ProjectScreen} />
     *     {#each projects as project}
     *       <a href="/p/{project.id}">{project.title}</a>
     *     {/each}
     *   </Router>
     * </div>
     * ```
     */
    function links(node) {
      function findClosest(tagName, el) {
        while (el && el.tagName !== tagName) {
          el = el.parentNode;
        }
        return el;
      }

      function onClick(event) {
        const anchor = findClosest("A", event.target);

        if (
          anchor &&
          anchor.target === "" &&
          hostMatches(anchor) &&
          shouldNavigate(event) &&
          !anchor.hasAttribute("noroute")
        ) {
          event.preventDefault();
          navigate(anchor.pathname + anchor.search, { replace: anchor.hasAttribute("replace") });
        }
      }

      node.addEventListener("click", onClick);

      return {
        destroy() {
          node.removeEventListener("click", onClick);
        }
      };
    }

    /** Used for built-in method references. */
    var objectProto$d = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$d;

      return value === proto;
    }

    var _isPrototype = isPrototype;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = _overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys;

    /** Used for built-in method references. */
    var objectProto$c = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$d = objectProto$c.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!_isPrototype(object)) {
        return _nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$d.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys;

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = _freeGlobal || freeSelf || Function('return this')();

    var _root = root;

    /** Built-in value references. */
    var Symbol$1 = _root.Symbol;

    var _Symbol = Symbol$1;

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$c = objectProto$b.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$b.toString;

    /** Built-in value references. */
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$c.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag;

    /** Used for built-in method references. */
    var objectProto$a = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$a.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? _getRawTag(value)
        : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1$1 = isObject;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$1 = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction$1(value) {
      if (!isObject_1$1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = _baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1$1 = isFunction$1;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = _root['__core-js_shared__'];

    var _coreJsData = coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$9 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$b = objectProto$9.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty$b).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject_1$1(value) || _isMasked(value)) {
        return false;
      }
      var pattern = isFunction_1$1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    /* Built-in method references that are verified to be native. */
    var DataView$1 = _getNative(_root, 'DataView');

    var _DataView = DataView$1;

    /* Built-in method references that are verified to be native. */
    var Map$1 = _getNative(_root, 'Map');

    var _Map = Map$1;

    /* Built-in method references that are verified to be native. */
    var Promise$1 = _getNative(_root, 'Promise');

    var _Promise = Promise$1;

    /* Built-in method references that are verified to be native. */
    var Set$1 = _getNative(_root, 'Set');

    var _Set = Set$1;

    /* Built-in method references that are verified to be native. */
    var WeakMap$1 = _getNative(_root, 'WeakMap');

    var _WeakMap = WeakMap$1;

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]',
        objectTag$2 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag$3 = '[object Set]',
        weakMapTag$1 = '[object WeakMap]';

    var dataViewTag$2 = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = _toSource(_DataView),
        mapCtorString = _toSource(_Map),
        promiseCtorString = _toSource(_Promise),
        setCtorString = _toSource(_Set),
        weakMapCtorString = _toSource(_WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = _baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
        (_Map && getTag(new _Map) != mapTag$3) ||
        (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
        (_Set && getTag(new _Set) != setTag$3) ||
        (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
      getTag = function(value) {
        var result = _baseGetTag(value),
            Ctor = result == objectTag$2 ? value.constructor : undefined,
            ctorString = Ctor ? _toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag$2;
            case mapCtorString: return mapTag$3;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag$3;
            case weakMapCtorString: return weakMapTag$1;
          }
        }
        return result;
      };
    }

    var _getTag = getTag;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
    }

    var _baseIsArguments = baseIsArguments;

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$a = objectProto$8.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments$1 = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
      return isObjectLike_1(value) && hasOwnProperty$a.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
    };

    var isArguments_1 = isArguments$1;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray$2 = Array.isArray;

    var isArray_1 = isArray$2;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }

    var isLength_1 = isLength;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength_1(value.length) && !isFunction_1$1(value);
    }

    var isArrayLike_1 = isArrayLike;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse_1;

    module.exports = isBuffer;
    });

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag = '[object Function]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        objectTag$1 = '[object Object]',
        regexpTag$2 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
    typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
    typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag$1] =
    typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
    typedArrayTags[objectTag$1] = typedArrayTags[regexpTag$2] =
    typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike_1(value) &&
        isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary;

    var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && _freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    });

    /* Node.js helper references. */
    var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

    var isTypedArray_1 = isTypedArray;

    /** `Object#toString` result references. */
    var mapTag$1 = '[object Map]',
        setTag$1 = '[object Set]';

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$7.hasOwnProperty;

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike_1(value) &&
          (isArray_1(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer_1(value) || isTypedArray_1(value) || isArguments_1(value))) {
        return !value.length;
      }
      var tag = _getTag(value);
      if (tag == mapTag$1 || tag == setTag$1) {
        return !value.size;
      }
      if (_isPrototype(value)) {
        return !_baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty$9.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    var isEmpty_1 = isEmpty;

    /* src/Components/Logo.svelte generated by Svelte v3.35.0 */

    const file$q = "src/Components/Logo.svelte";

    function create_fragment$r(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "d", "M18.2,1.5c0-0.6-0.5-0.8-1.2-0.8c-3.4,0.1-5.4,4.3-5.5,7.9c-0.9-2.5-1.5-5.1-1.8-6.4C9.6,1.7,9.6,1.3,8.9,1.3\n    c-1.7,0-4.7-0.2-5.5,1.9C3,4.2,4.6,4.5,4.6,3.2c-0.1-1.4,1.3-1.6,2-1.6c0.9,0,1.3,0.1,1.2,1.7C7.5,6.1,6,10.8,3,10.8\n    c-1.1,0-1.4-0.7-1-1.1c0.2-0.2,0.3-0.3,0.3-0.6c0-0.4-0.3-0.6-0.6-0.6c-1.2,0-1.2,2.6,1.1,2.6c4.3,0,5.5-6.3,5.8-8.9l0.1,0\n    c1.4,5.4,2.9,12.6,9.2,12.6c2.9,0,3-1.8,1.9-1.8c-0.8,0-0.9,1.2-2.4,1.4c-2.2,0.2-3.8-1.8-5-4.3C11.3,8,13,1.6,16,1.8\n    c0.5,0,0.9,0.2,1.3,0.3C17.6,2.1,18.2,1.9,18.2,1.5\n    M16.8,11.9c-1,0.3-1.9-0.4-2.3-2.1c-0.5-1.7,0-2.8,1-3c1-0.3,1.9,0.4,2.4,2.1\n    C18.3,10.6,17.8,11.7,16.8,11.9\n    M18.9,8.6c-0.5-1.7-1.9-2.5-3.6-2c-1.7,0.5-2.5,1.9-2,3.6c0.5,1.7,1.9,2.5,3.6,2.1\n    C18.6,11.8,19.4,10.3,18.9,8.6\n    M26,2.9c-0.7-1.3-2.3-0.2-1.3,0.8c3.1,3,1.5,7.7-1.6,7.7c-1.5,0-2.3-1.1-2.3-2.3\n    c0-1.7,1.3-2.8,2.7-3.6c0.9-0.5,0.6-1.4-0.3-1.1C22,4.6,21.4,3,19.7,3c-1.4,0-2.2,0.9-2.2,1.8c0,0.7,0.5,1.6,1.2,1.6\n    c0.4,0,0.7-0.3,0.7-0.7c0-0.5-0.5-0.6-0.9-0.8c-1.1-0.4-0.5-1.4,0.5-1.2c1.7,0.2,2.4,2,4.1,1.4l0,0.1c-1.4,0.7-3.7,2.1-3.7,4.2\n    c0,1.6,1.2,2.9,2.8,2.9C26.4,12.3,28.1,6.6,26,2.9\n    M50.3,9.4c-0.1,2.4-2.1,2.6-3.7,2.3l1.2-4.5C49.3,7.4,50.3,7.9,50.3,9.4\n    M47.4,4.2l-1.8,6.5c-0.2,0.7-0.4,1-1,1H44c-0.6,0-0.6-0.4-0.4-1.1l2-7c0.2-0.7,0.6-0.8,1-0.8H47C47.8,2.9,47.7,3.4,47.4,4.2\n    M52.7,4.4c0-5.5-12.5-4.2-13.3,0.7c0,0.1,0,0.2,0,0.3c0,0.5,0.2,0.9,0.7,0.9c0.4,0,0.7-0.3,0.7-0.8c0-0.4-0.3-0.8-0.3-1.2\n    c0-3.1,10.7-5,10.9-0.1C51.6,5.7,50.4,7,48.9,7c-0.3,0-0.6,0-0.9-0.1l0.8-3.3C49,2.9,49.4,3,49.9,3V2.6h-5.3c-0.5,0-0.6,0.3-0.8,0.7\n    c-0.3,0.5-1.2,2.3-2.4,4c-0.3,0.5-1.9,2.9-2.3,2.9c-0.1,0-0.2-0.1-0.2-0.2L38,3.1c0-0.3-0.1-0.4-0.5-0.4h-3.4V3h0.5\n    c1.1,0,1.6,0.1,1.3,1.5c-0.6,4-4,11.3-8.9,11.3c-1,0-2.2-0.5-2.2-1.8c0-0.7,0.5-1,1.1-1c0.3,0,0.6,0.1,0.8,0.1\n    c0.3,0,0.6-0.3,0.6-0.6c0-0.5-0.6-0.7-1-0.7c-1.1,0-2,0.9-2,2c0,1.5,1.4,2.2,2.8,2.2C32.7,16,36,8.4,37,3.9h0l0.8,7.9\n    c0,0.4,0.4,0.5,0.7,0.2l5.9-8.4l0,0l-1.9,6.9c-0.3,1-0.7,1.2-1.7,1.2v0.3c2.3,0,4.6,0,6.9,0c1.8,0,3.9-0.7,3.9-2.9\n    c0-1.1-0.8-1.8-1.8-2.1C51.5,7.2,52.7,5.9,52.7,4.4\n    M58.3,4.8c-0.4,1.8-1.9,2.4-3.6,2L55.9,3C57.3,2.7,58.7,3.1,58.3,4.8 M59.7,4.6\n    c0-2.5-3.1-1.9-4.3-1.9c-1,0-1.6,0-2.3,0V3c0.3,0,1.7-0.1,1.5,0.7L52.2,11c-0.3,0.9-0.7,0.9-1.5,0.9v0.3c1.3,0,2.5,0,3.8,0v-0.3\n    c-0.7,0-1.3-0.1-1-1l1.2-3.6c0.9,0.2,1.1,0.4,1.4,1.2c1.1,2.2,1.6,6.7,6,6.7c1.5,0,2.9-1.1,2.9-1.9c0-0.3-0.3-0.5-0.5-0.5\n    c-0.2,0-0.4,0.2-0.5,0.4c-0.4,0.7-0.7,1.7-2.2,1.7c-3.2,0-3.5-4.1-4.2-6.4c-0.2-0.7-0.6-1-1.1-1.2C58,7.2,59.7,6.3,59.7,4.6");
    			attr_dev(path0, "class", "svelte-1ymxg37");
    			add_location(path0, file$q, 42, 2, 800);
    			attr_dev(path1, "d", "M30.6,11.8c-1.5,0-2.5-1.5-2.5-2.9c0-0.8,0.3-1.4,0.7-1.9c1.2,1.2,3.6,0.9,3.1-0.4C31.8,6.2,31.2,6,30.6,6\n    c-0.5,0-1,0.1-1.5,0.3l0.1,0.3c0.4-0.2,0.8-0.4,1.3-0.4c0.5,0,0.8,0.1,0.9,0.4c0.1,0.8-1.6,0.9-2.2,0l-0.1-0.3c0-0.1,0-0.2,0-0.3\n    c0-2.7,2.7-3.7,3.5-2.8c0.5,0.5-0.1,1-0.1,1.5c0,0.7,1.2,0.8,1.2-0.3c0-1.1-1-1.9-2.3-1.9c-1.6,0-3.2,1.1-3.2,2.7\n    c0,0.6,0.2,1.1,0.4,1.4c0,0,0,0,0,0c-1,0.7-1.7,1.8-1.7,3c0,1.6,1.5,2.7,3,2.7c2.6,0,4-2.4,3.9-4.4c0-1-1.1-0.8-1.1-0.1\n    c0,0.4,0.2,0.8,0.2,1.4C32.8,10.6,32,11.8,30.6,11.8");
    			attr_dev(path1, "class", "svelte-1ymxg37");
    			add_location(path1, file$q, 69, 2, 3369);
    			attr_dev(path2, "d", "M62.5,11.8c-1.5,0-2.5-1.5-2.5-2.9c0-0.8,0.3-1.4,0.7-1.9c1.2,1.2,3.6,0.9,3.1-0.4C63.7,6.2,63.1,6,62.6,6\n    c-0.5,0-1,0.1-1.5,0.3l0.1,0.3c0.4-0.2,0.8-0.4,1.3-0.4c0.5,0,0.8,0.1,0.9,0.4c0.1,0.8-1.6,0.9-2.2,0l-0.1-0.3c0-0.1,0-0.2,0-0.3\n    c0-2.7,2.7-3.7,3.5-2.8c0.5,0.5-0.1,1-0.1,1.5c0,0.7,1.2,0.8,1.2-0.3c0-1.1-1-1.9-2.3-1.9c-1.6,0-3.2,1.1-3.2,2.7\n    c0,0.6,0.2,1.1,0.4,1.4c0,0,0,0,0,0c-1,0.7-1.7,1.8-1.7,3c0,1.6,1.5,2.7,3,2.7c2.6,0,4-2.4,3.9-4.4c0-1-1.1-0.8-1.1-0.1\n    c0,0.4,0.2,0.8,0.2,1.4C64.7,10.6,64,11.8,62.5,11.8");
    			attr_dev(path2, "class", "svelte-1ymxg37");
    			add_location(path2, file$q, 75, 2, 3909);
    			attr_dev(svg, "class", "logo svelte-1ymxg37");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "Layer_1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "viewBox", "0 0 67.3 16.8");
    			set_style(svg, "enable-background", "new 0 0 67.3 16.8");
    			attr_dev(svg, "xml:space", "preserve");
    			toggle_class(svg, "white", /*white*/ ctx[0]);
    			toggle_class(svg, "black", /*black*/ ctx[1]);
    			add_location(svg, file$q, 29, 0, 520);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*white*/ 1) {
    				toggle_class(svg, "white", /*white*/ ctx[0]);
    			}

    			if (dirty & /*black*/ 2) {
    				toggle_class(svg, "black", /*black*/ ctx[1]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Logo", slots, []);
    	let { white = true } = $$props;
    	let { black = false } = $$props;
    	const writable_props = ["white", "black"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Logo> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("white" in $$props) $$invalidate(0, white = $$props.white);
    		if ("black" in $$props) $$invalidate(1, black = $$props.black);
    	};

    	$$self.$capture_state = () => ({ white, black });

    	$$self.$inject_state = $$props => {
    		if ("white" in $$props) $$invalidate(0, white = $$props.white);
    		if ("black" in $$props) $$invalidate(1, black = $$props.black);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [white, black];
    }

    class Logo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { white: 0, black: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Logo",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get white() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set white(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get black() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set black(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-media-query/src/MediaQuery.svelte generated by Svelte v3.35.0 */
    const get_default_slot_changes = dirty => ({ matches: dirty & /*matches*/ 1 });
    const get_default_slot_context = ctx => ({ matches: /*matches*/ ctx[0] });

    function create_fragment$q(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, matches*/ 9) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MediaQuery", slots, ['default']);
    	let { query } = $$props;
    	let mql;
    	let mqlListener;
    	let wasMounted = false;
    	let matches = false;

    	onMount(() => {
    		$$invalidate(2, wasMounted = true);

    		return () => {
    			removeActiveListener();
    		};
    	});

    	function addNewListener(query) {
    		mql = window.matchMedia(query);
    		mqlListener = v => $$invalidate(0, matches = v.matches);
    		mql.addListener(mqlListener);
    		$$invalidate(0, matches = mql.matches);
    	}

    	function removeActiveListener() {
    		if (mql && mqlListener) {
    			mql.removeListener(mqlListener);
    		}
    	}

    	const writable_props = ["query"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MediaQuery> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("query" in $$props) $$invalidate(1, query = $$props.query);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		query,
    		mql,
    		mqlListener,
    		wasMounted,
    		matches,
    		addNewListener,
    		removeActiveListener
    	});

    	$$self.$inject_state = $$props => {
    		if ("query" in $$props) $$invalidate(1, query = $$props.query);
    		if ("mql" in $$props) mql = $$props.mql;
    		if ("mqlListener" in $$props) mqlListener = $$props.mqlListener;
    		if ("wasMounted" in $$props) $$invalidate(2, wasMounted = $$props.wasMounted);
    		if ("matches" in $$props) $$invalidate(0, matches = $$props.matches);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*wasMounted, query*/ 6) {
    			{
    				if (wasMounted) {
    					removeActiveListener();
    					addNewListener(query);
    				}
    			}
    		}
    	};

    	return [matches, query, wasMounted, $$scope, slots];
    }

    class MediaQuery extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { query: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MediaQuery",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*query*/ ctx[1] === undefined && !("query" in props)) {
    			console.warn("<MediaQuery> was created without expected prop 'query'");
    		}
    	}

    	get query() {
    		throw new Error("<MediaQuery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set query(value) {
    		throw new Error("<MediaQuery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/SearchBox.svelte generated by Svelte v3.35.0 */
    const file$p = "src/Components/SearchBox.svelte";

    // (150:2) {#if !searchActive}
    function create_if_block_1$e(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "SEARCH";
    			attr_dev(span, "class", "search__open svelte-1e4q88q");
    			add_location(span, file$p, 150, 4, 3830);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			/*span_binding*/ ctx[8](span);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*showSearchBox*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*span_binding*/ ctx[8](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(150:2) {#if !searchActive}",
    		ctx
    	});

    	return block;
    }

    // (155:2) <MediaQuery query="(min-width: 800px)" let:matches>
    function create_default_slot$8(ctx) {
    	let input;
    	let input_style_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "ref", "search");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "search__input svelte-1e4q88q");

    			attr_dev(input, "style", input_style_value = /*matches*/ ctx[15]
    			? "width:" + /*inputWidth*/ ctx[3] + "px"
    			: "");

    			toggle_class(input, "search__input--active", /*searchActive*/ ctx[0]);
    			add_location(input, file$p, 155, 4, 3993);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*searchQuery*/ ctx[1]);
    			/*input_binding*/ ctx[10](input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[9]),
    					listen_dev(input, "click", click_handler, false, false, false),
    					listen_dev(input, "keypress", /*keypress_handler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*matches, inputWidth*/ 32776 && input_style_value !== (input_style_value = /*matches*/ ctx[15]
    			? "width:" + /*inputWidth*/ ctx[3] + "px"
    			: "")) {
    				attr_dev(input, "style", input_style_value);
    			}

    			if (dirty & /*searchQuery*/ 2 && input.value !== /*searchQuery*/ ctx[1]) {
    				set_input_value(input, /*searchQuery*/ ctx[1]);
    			}

    			if (dirty & /*searchActive*/ 1) {
    				toggle_class(input, "search__input--active", /*searchActive*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[10](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(155:2) <MediaQuery query=\\\"(min-width: 800px)\\\" let:matches>",
    		ctx
    	});

    	return block;
    }

    // (171:2) {#if searchActive}
    function create_if_block$i(ctx) {
    	let span;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "SEARCH";
    			attr_dev(span, "class", "search__submit svelte-1e4q88q");
    			add_location(span, file$p, 171, 4, 4436);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*submitSearch*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(171:2) {#if searchActive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div;
    	let t0;
    	let mediaquery;
    	let t1;
    	let current;
    	let if_block0 = !/*searchActive*/ ctx[0] && create_if_block_1$e(ctx);

    	mediaquery = new MediaQuery({
    			props: {
    				query: "(min-width: 800px)",
    				$$slots: {
    					default: [
    						create_default_slot$8,
    						({ matches }) => ({ 15: matches }),
    						({ matches }) => matches ? 32768 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block1 = /*searchActive*/ ctx[0] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			create_component(mediaquery.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "search svelte-1e4q88q");
    			toggle_class(div, "search--active", /*searchActive*/ ctx[0]);
    			add_location(div, file$p, 148, 0, 3747);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			mount_component(mediaquery, div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*searchActive*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$e(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const mediaquery_changes = {};

    			if (dirty & /*$$scope, matches, inputWidth, searchQuery, searchField, searchActive*/ 98319) {
    				mediaquery_changes.$$scope = { dirty, ctx };
    			}

    			mediaquery.$set(mediaquery_changes);

    			if (/*searchActive*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$i(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*searchActive*/ 1) {
    				toggle_class(div, "search--active", /*searchActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mediaquery.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mediaquery.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			destroy_component(mediaquery);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const click_handler = e => {
    	e.preventDefault();
    	e.stopPropagation();
    };

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SearchBox", slots, []);
    	const dispatch = createEventDispatcher();

    	// *** VARIABLES
    	let searchActive = false;

    	let searchQuery = "";
    	let searchField = {};
    	let submitWidth = 0;
    	let inputWidth = 0;
    	let { menuActive = false } = $$props;

    	// *** DOM REFERENCES
    	let openEl = {};

    	const showSearchBox = e => {
    		e.preventDefault();
    		e.stopPropagation();
    		$$invalidate(0, searchActive = true);
    		searchField.focus();
    	};

    	function resizeInput() {
    		submitWidth = openEl.offsetWidth;
    		$$invalidate(3, inputWidth = window.innerWidth - submitWidth - 60); // Subtract margins
    	}

    	const submitSearch = () => {
    		if (searchQuery.length > 0) {
    			navigate("/search/" + searchQuery);
    			dispatch("closeMenu", {});
    		} else {
    			$$invalidate(0, searchActive = false);
    		}

    		window.onresize = resizeInput;
    	};

    	onMount(async () => {
    		resizeInput();
    	});

    	const writable_props = ["menuActive"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchBox> was created with unknown prop '${key}'`);
    	});

    	function span_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			openEl = $$value;
    			$$invalidate(4, openEl);
    		});
    	}

    	function input_input_handler() {
    		searchQuery = this.value;
    		($$invalidate(1, searchQuery), $$invalidate(7, menuActive));
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			searchField = $$value;
    			$$invalidate(2, searchField);
    		});
    	}

    	const keypress_handler = e => e.keyCode === 13 ? submitSearch() : false;

    	$$self.$$set = $$props => {
    		if ("menuActive" in $$props) $$invalidate(7, menuActive = $$props.menuActive);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		navigate,
    		MediaQuery,
    		createEventDispatcher,
    		dispatch,
    		searchActive,
    		searchQuery,
    		searchField,
    		submitWidth,
    		inputWidth,
    		menuActive,
    		openEl,
    		showSearchBox,
    		resizeInput,
    		submitSearch
    	});

    	$$self.$inject_state = $$props => {
    		if ("searchActive" in $$props) $$invalidate(0, searchActive = $$props.searchActive);
    		if ("searchQuery" in $$props) $$invalidate(1, searchQuery = $$props.searchQuery);
    		if ("searchField" in $$props) $$invalidate(2, searchField = $$props.searchField);
    		if ("submitWidth" in $$props) submitWidth = $$props.submitWidth;
    		if ("inputWidth" in $$props) $$invalidate(3, inputWidth = $$props.inputWidth);
    		if ("menuActive" in $$props) $$invalidate(7, menuActive = $$props.menuActive);
    		if ("openEl" in $$props) $$invalidate(4, openEl = $$props.openEl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*menuActive*/ 128) {
    			{
    				if (!menuActive) {
    					$$invalidate(0, searchActive = false);
    					$$invalidate(1, searchQuery = "");
    				}
    			}
    		}
    	};

    	return [
    		searchActive,
    		searchQuery,
    		searchField,
    		inputWidth,
    		openEl,
    		showSearchBox,
    		submitSearch,
    		menuActive,
    		span_binding,
    		input_input_handler,
    		input_binding,
    		keypress_handler
    	];
    }

    class SearchBox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { menuActive: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchBox",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get menuActive() {
    		throw new Error("<SearchBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set menuActive(value) {
    		throw new Error("<SearchBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$8 = Object.prototype.hasOwnProperty;
    var propIsEnumerable$1 = Object.prototype.propertyIsEnumerable;

    function toObject$1(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject$1(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$8.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable$1.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    var isFunction_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function isFunction(x) {
        return typeof x === 'function';
    }
    exports.isFunction = isFunction;
    //# sourceMappingURL=isFunction.js.map
    });

    var config$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    exports.config = {
        Promise: undefined,
        set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
                var error = new Error();
                console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
            }
            else if (_enable_super_gross_mode_that_will_cause_bad_things) {
                console.log('RxJS: Back to a better error behavior. Thank you. <3');
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
        },
    };
    //# sourceMappingURL=config.js.map
    });

    var hostReportError_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function hostReportError(err) {
        setTimeout(function () { throw err; }, 0);
    }
    exports.hostReportError = hostReportError;
    //# sourceMappingURL=hostReportError.js.map
    });

    var Observer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });


    exports.empty = {
        closed: true,
        next: function (value) { },
        error: function (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        },
        complete: function () { }
    };
    //# sourceMappingURL=Observer.js.map
    });

    var isArray$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
    //# sourceMappingURL=isArray.js.map
    });

    var isObject_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject(x) {
        return x !== null && typeof x === 'object';
    }
    exports.isObject = isObject;
    //# sourceMappingURL=isObject.js.map
    });

    var UnsubscriptionError = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnsubscriptionErrorImpl = (function () {
        function UnsubscriptionErrorImpl(errors) {
            Error.call(this);
            this.message = errors ?
                errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
            return this;
        }
        UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
        return UnsubscriptionErrorImpl;
    })();
    exports.UnsubscriptionError = UnsubscriptionErrorImpl;
    //# sourceMappingURL=UnsubscriptionError.js.map
    });

    var Subscription_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });




    var Subscription = (function () {
        function Subscription(unsubscribe) {
            this.closed = false;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._unsubscribe = unsubscribe;
            }
        }
        Subscription.prototype.unsubscribe = function () {
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (_parentOrParents instanceof Subscription) {
                _parentOrParents.remove(this);
            }
            else if (_parentOrParents !== null) {
                for (var index = 0; index < _parentOrParents.length; ++index) {
                    var parent_1 = _parentOrParents[index];
                    parent_1.remove(this);
                }
            }
            if (isFunction_1.isFunction(_unsubscribe)) {
                try {
                    _unsubscribe.call(this);
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
            }
            if (isArray$1.isArray(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject_1.isObject(sub)) {
                        try {
                            sub.unsubscribe();
                        }
                        catch (e) {
                            errors = errors || [];
                            if (e instanceof UnsubscriptionError.UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                            }
                            else {
                                errors.push(e);
                            }
                        }
                    }
                }
            }
            if (errors) {
                throw new UnsubscriptionError.UnsubscriptionError(errors);
            }
        };
        Subscription.prototype.add = function (teardown) {
            var subscription = teardown;
            if (!teardown) {
                return Subscription.EMPTY;
            }
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default: {
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
            }
            var _parentOrParents = subscription._parentOrParents;
            if (_parentOrParents === null) {
                subscription._parentOrParents = this;
            }
            else if (_parentOrParents instanceof Subscription) {
                if (_parentOrParents === this) {
                    return subscription;
                }
                subscription._parentOrParents = [_parentOrParents, this];
            }
            else if (_parentOrParents.indexOf(this) === -1) {
                _parentOrParents.push(this);
            }
            else {
                return subscription;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions === null) {
                this._subscriptions = [subscription];
            }
            else {
                subscriptions.push(subscription);
            }
            return subscription;
        };
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    exports.Subscription = Subscription;
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError.UnsubscriptionError) ? err.errors : err); }, []);
    }
    //# sourceMappingURL=Subscription.js.map
    });

    var rxSubscriber = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rxSubscriber = (function () {
        return typeof Symbol === 'function'
            ? Symbol('rxSubscriber')
            : '@@rxSubscriber_' + Math.random();
    })();
    exports.$$rxSubscriber = exports.rxSubscriber;
    //# sourceMappingURL=rxSubscriber.js.map
    });

    var Subscriber_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });






    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    _this.destination = Observer.empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        _this.destination = Observer.empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                            _this.destination = destinationOrNext;
                            destinationOrNext.add(_this);
                        }
                        else {
                            _this.syncErrorThrowable = true;
                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                    break;
            }
            return _this;
        }
        Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _parentOrParents = this._parentOrParents;
            this._parentOrParents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parentOrParents = _parentOrParents;
            return this;
        };
        return Subscriber;
    }(Subscription_1.Subscription));
    exports.Subscriber = Subscriber;
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction_1.isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== Observer.empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction_1.isFunction(context.unsubscribe)) {
                        _this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = _this.unsubscribe.bind(_this);
                }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config$1.config.useDeprecatedSynchronousErrorHandling;
                if (this._error) {
                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    if (useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    hostReportError_1.hostReportError(err);
                }
                else {
                    if (useDeprecatedSynchronousErrorHandling) {
                        _parentSubscriber.syncErrorValue = err;
                        _parentSubscriber.syncErrorThrown = true;
                    }
                    else {
                        hostReportError_1.hostReportError(err);
                    }
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            if (!config$1.config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
            }
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                    parent.syncErrorValue = err;
                    parent.syncErrorThrown = true;
                    return true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                    return true;
                }
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));
    exports.SafeSubscriber = SafeSubscriber;
    //# sourceMappingURL=Subscriber.js.map
    });

    var filter_1$1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function filter(predicate, thisArg) {
        return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
        };
    }
    exports.filter = filter;
    var FilterOperator = (function () {
        function FilterOperator(predicate, thisArg) {
            this.predicate = predicate;
            this.thisArg = thisArg;
        }
        FilterOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
        };
        return FilterOperator;
    }());
    var FilterSubscriber = (function (_super) {
        __extends(FilterSubscriber, _super);
        function FilterSubscriber(destination, predicate, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.count = 0;
            return _this;
        }
        FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.predicate.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.destination.next(value);
            }
        };
        return FilterSubscriber;
    }(Subscriber_1.Subscriber));
    //# sourceMappingURL=filter.js.map
    });

    var filter_1 = filter_1$1.filter;

    var filter$5 = {
    	filter: filter_1
    };

    var map_1$1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    exports.map = map;
    var MapOperator = (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    exports.MapOperator = MapOperator;
    var MapSubscriber = (function (_super) {
        __extends(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber_1.Subscriber));
    //# sourceMappingURL=map.js.map
    });

    var map_1 = map_1$1.map;

    var map$4 = {
    	map: map_1
    };

    var isObj = function (x) {
    	var type = typeof x;
    	return x !== null && (type === 'object' || type === 'function');
    };

    var hasOwnProperty$7 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Sources cannot be null or undefined');
    	}

    	return Object(val);
    }

    function assignKey(to, from, key) {
    	var val = from[key];

    	if (val === undefined || val === null) {
    		return;
    	}

    	if (hasOwnProperty$7.call(to, key)) {
    		if (to[key] === undefined || to[key] === null) {
    			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
    		}
    	}

    	if (!hasOwnProperty$7.call(to, key) || !isObj(val)) {
    		to[key] = val;
    	} else {
    		to[key] = assign$1(Object(to[key]), from[key]);
    	}
    }

    function assign$1(to, from) {
    	if (to === from) {
    		return to;
    	}

    	from = Object(from);

    	for (var key in from) {
    		if (hasOwnProperty$7.call(from, key)) {
    			assignKey(to, from, key);
    		}
    	}

    	if (Object.getOwnPropertySymbols) {
    		var symbols = Object.getOwnPropertySymbols(from);

    		for (var i = 0; i < symbols.length; i++) {
    			if (propIsEnumerable.call(from, symbols[i])) {
    				assignKey(to, from, symbols[i]);
    			}
    		}
    	}

    	return to;
    }

    var deepAssign = function deepAssign(target) {
    	target = toObject(target);

    	for (var s = 1; s < arguments.length; s++) {
    		assign$1(target, arguments[s]);
    	}

    	return target;
    };

    var getSelection = function getSelection(sel) {
      if (typeof sel === 'string' || Array.isArray(sel)) {
        return {
          id: sel
        };
      }

      if (sel && sel.query) {
        return {
          query: sel.query
        };
      }

      var selectionOpts = ['* Document ID (<docId>)', '* Array of document IDs', '* Object containing `query`'].join('\n');
      throw new Error("Unknown selection - must be one of:\n\n".concat(selectionOpts));
    };

    var validators = createCommonjsModule(function (module, exports) {

    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    var VALID_ASSET_TYPES = ['image', 'file'];
    var VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];

    exports.dataset = function (name) {
      if (!/^(~[a-z0-9]{1}[-\w]{0,25}|[a-z0-9]{1}[-\w]{0,19})$/.test(name)) {
        throw new Error('Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 20 characters');
      }
    };

    exports.projectId = function (id) {
      if (!/^[-a-z0-9]+$/i.test(id)) {
        throw new Error('`projectId` can only contain only a-z, 0-9 and dashes');
      }
    };

    exports.validateAssetType = function (type) {
      if (VALID_ASSET_TYPES.indexOf(type) === -1) {
        throw new Error("Invalid asset type: ".concat(type, ". Must be one of ").concat(VALID_ASSET_TYPES.join(', ')));
      }
    };

    exports.validateObject = function (op, val) {
      if (val === null || _typeof(val) !== 'object' || Array.isArray(val)) {
        throw new Error("".concat(op, "() takes an object of properties"));
      }
    };

    exports.requireDocumentId = function (op, doc) {
      if (!doc._id) {
        throw new Error("".concat(op, "() requires that the document contains an ID (\"_id\" property)"));
      }

      exports.validateDocumentId(op, doc._id);
    };

    exports.validateDocumentId = function (op, id) {
      if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {
        throw new Error("".concat(op, "(): \"").concat(id, "\" is not a valid document ID"));
      }
    };

    exports.validateInsert = function (at, selector, items) {
      var signature = 'insert(at, selector, items)';

      if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
        var valid = VALID_INSERT_LOCATIONS.map(function (loc) {
          return "\"".concat(loc, "\"");
        }).join(', ');
        throw new Error("".concat(signature, " takes an \"at\"-argument which is one of: ").concat(valid));
      }

      if (typeof selector !== 'string') {
        throw new Error("".concat(signature, " takes a \"selector\"-argument which must be a string"));
      }

      if (!Array.isArray(items)) {
        throw new Error("".concat(signature, " takes an \"items\"-argument which must be an array"));
      }
    };

    exports.hasDataset = function (config) {
      if (!config.gradientMode && !config.dataset) {
        throw new Error('`dataset` must be provided to perform queries');
      }

      return config.dataset || '';
    };
    });

    function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









    var validateObject = validators.validateObject;
    var validateInsert = validators.validateInsert;

    function Patch(selection) {
      var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.selection = selection;
      this.operations = objectAssign({}, operations);
      this.client = client;
    }

    objectAssign(Patch.prototype, {
      clone: function clone() {
        return new Patch(this.selection, objectAssign({}, this.operations), this.client);
      },
      merge: function merge(props) {
        validateObject('merge', props);
        var stack = new Error().stack.toString().split('\n').filter(function (str) {
          return str.trim();
        }).slice(2);
        console.warn("The \"merge\" patch has been deprecated and will be removed in the future\n".concat(stack.join('\n')));
        return this._assign('merge', deepAssign(this.operations.merge || {}, props));
      },
      set: function set(props) {
        return this._assign('set', props);
      },
      diffMatchPatch: function diffMatchPatch(props) {
        validateObject('diffMatchPatch', props);
        return this._assign('diffMatchPatch', props);
      },
      unset: function unset(attrs) {
        if (!Array.isArray(attrs)) {
          throw new Error('unset(attrs) takes an array of attributes to unset, non-array given');
        }

        this.operations = objectAssign({}, this.operations, {
          unset: attrs
        });
        return this;
      },
      setIfMissing: function setIfMissing(props) {
        return this._assign('setIfMissing', props);
      },
      replace: function replace(props) {
        validateObject('replace', props);
        return this._set('set', {
          $: props
        }); // eslint-disable-line id-length
      },
      inc: function inc(props) {
        return this._assign('inc', props);
      },
      dec: function dec(props) {
        return this._assign('dec', props);
      },
      insert: function insert(at, selector, items) {
        var _this$_assign;

        validateInsert(at, selector, items);
        return this._assign('insert', (_this$_assign = {}, _defineProperty$3(_this$_assign, at, selector), _defineProperty$3(_this$_assign, "items", items), _this$_assign));
      },
      append: function append(selector, items) {
        return this.insert('after', "".concat(selector, "[-1]"), items);
      },
      prepend: function prepend(selector, items) {
        return this.insert('before', "".concat(selector, "[0]"), items);
      },
      splice: function splice(selector, start, deleteCount, items) {
        // Negative indexes doesn't mean the same in Sanity as they do in JS;
        // -1 means "actually at the end of the array", which allows inserting
        // at the end of the array without knowing its length. We therefore have
        // to substract negative indexes by one to match JS. If you want Sanity-
        // behaviour, just use `insert('replace', selector, items)` directly
        var delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
        var startIndex = start < 0 ? start - 1 : start;
        var delCount = delAll ? -1 : Math.max(0, start + deleteCount);
        var delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
        var rangeSelector = "".concat(selector, "[").concat(startIndex, ":").concat(delRange, "]");
        return this.insert('replace', rangeSelector, items || []);
      },
      ifRevisionId: function ifRevisionId(rev) {
        this.operations.ifRevisionID = rev;
        return this;
      },
      serialize: function serialize() {
        return objectAssign(getSelection(this.selection), this.operations);
      },
      toJSON: function toJSON() {
        return this.serialize();
      },
      commit: function commit() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!this.client) {
          throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
        }

        var returnFirst = typeof this.selection === 'string';
        var opts = objectAssign({
          returnFirst: returnFirst,
          returnDocuments: true
        }, options);
        return this.client.mutate({
          patch: this.serialize()
        }, opts);
      },
      reset: function reset() {
        this.operations = {};
        return this;
      },
      _set: function _set(op, props) {
        return this._assign(op, props, false);
      },
      _assign: function _assign(op, props) {
        var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        validateObject(op, props);
        this.operations = objectAssign({}, this.operations, _defineProperty$3({}, op, objectAssign({}, merge && this.operations[op] || {}, props)));
        return this;
      }
    });
    var patch = Patch;

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







    var defaultMutateOptions = {
      returnDocuments: false
    };

    function Transaction() {
      var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var client = arguments.length > 1 ? arguments[1] : undefined;
      var transactionId = arguments.length > 2 ? arguments[2] : undefined;
      this.trxId = transactionId;
      this.operations = operations;
      this.client = client;
    }

    objectAssign(Transaction.prototype, {
      clone: function clone() {
        return new Transaction(this.operations.slice(0), this.client, this.trxId);
      },
      create: function create(doc) {
        validators.validateObject('create', doc);
        return this._add({
          create: doc
        });
      },
      createIfNotExists: function createIfNotExists(doc) {
        var op = 'createIfNotExists';
        validators.validateObject(op, doc);
        validators.requireDocumentId(op, doc);
        return this._add(_defineProperty$2({}, op, doc));
      },
      createOrReplace: function createOrReplace(doc) {
        var op = 'createOrReplace';
        validators.validateObject(op, doc);
        validators.requireDocumentId(op, doc);
        return this._add(_defineProperty$2({}, op, doc));
      },
      delete: function _delete(documentId) {
        validators.validateDocumentId('delete', documentId);
        return this._add({
          delete: {
            id: documentId
          }
        });
      },
      patch: function patch$1(documentId, patchOps) {
        var isBuilder = typeof patchOps === 'function';
        var isPatch = documentId instanceof patch; // transaction.patch(client.patch('documentId').inc({visits: 1}))

        if (isPatch) {
          return this._add({
            patch: documentId.serialize()
          });
        } // patch => patch.inc({visits: 1}).set({foo: 'bar'})


        if (isBuilder) {
          var patch$1 = patchOps(new patch(documentId, {}, this.client));

          if (!(patch$1 instanceof patch)) {
            throw new Error('function passed to `patch()` must return the patch');
          }

          return this._add({
            patch: patch$1.serialize()
          });
        }

        return this._add({
          patch: objectAssign({
            id: documentId
          }, patchOps)
        });
      },
      transactionId: function transactionId(id) {
        if (!id) {
          return this.trxId;
        }

        this.trxId = id;
        return this;
      },
      serialize: function serialize() {
        return this.operations.slice();
      },
      toJSON: function toJSON() {
        return this.serialize();
      },
      commit: function commit(options) {
        if (!this.client) {
          throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
        }

        return this.client.mutate(this.serialize(), objectAssign({
          transactionId: this.trxId
        }, defaultMutateOptions, options || {}));
      },
      reset: function reset() {
        this.operations = [];
        return this;
      },
      _add: function _add(mut) {
        this.operations.push(mut);
        return this;
      }
    });
    var transaction = Transaction;

    var enc$1 = encodeURIComponent;

    var encodeQueryString = function (_ref) {
      var query = _ref.query,
          _ref$params = _ref.params,
          params = _ref$params === void 0 ? {} : _ref$params,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options;
      var base = "?query=".concat(enc$1(query));
      var qString = Object.keys(params).reduce(function (qs, param) {
        return "".concat(qs, "&").concat(enc$1("$".concat(param)), "=").concat(enc$1(JSON.stringify(params[param])));
      }, base);
      return Object.keys(options).reduce(function (qs, option) {
        // Only include the option if it is truthy
        return options[option] ? "".concat(qs, "&").concat(enc$1(option), "=").concat(enc$1(options[option])) : qs;
      }, qString);
    };

    var canReportError_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    function canReportError(observer) {
        while (observer) {
            var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
                return false;
            }
            else if (destination && destination instanceof Subscriber_1.Subscriber) {
                observer = destination;
            }
            else {
                observer = null;
            }
        }
        return true;
    }
    exports.canReportError = canReportError;
    //# sourceMappingURL=canReportError.js.map
    });

    var toSubscriber_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });



    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber_1.Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber.rxSubscriber]) {
                return nextOrObserver[rxSubscriber.rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber_1.Subscriber(Observer.empty);
        }
        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }
    exports.toSubscriber = toSubscriber;
    //# sourceMappingURL=toSubscriber.js.map
    });

    var observable$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
    //# sourceMappingURL=observable.js.map
    });

    var noop_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function noop() { }
    exports.noop = noop;
    //# sourceMappingURL=noop.js.map
    });

    var pipe_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
        if (!fns) {
            return noop_1.noop;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }
    exports.pipeFromArray = pipeFromArray;
    //# sourceMappingURL=pipe.js.map
    });

    var Observable_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });





    var Observable = (function () {
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
            if (operator) {
                sink.add(operator.call(sink, this.source));
            }
            else {
                sink.add(this.source || (config$1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                    this._subscribe(sink) :
                    this._trySubscribe(sink));
            }
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                    sink.syncErrorThrowable = false;
                    if (sink.syncErrorThrown) {
                        throw sink.syncErrorValue;
                    }
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                    sink.syncErrorThrown = true;
                    sink.syncErrorValue = err;
                }
                if (canReportError_1.canReportError(sink)) {
                    sink.error(err);
                }
                else {
                    console.warn(err);
                }
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        if (subscription) {
                            subscription.unsubscribe();
                        }
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
        };
        Observable.prototype[observable$1.observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipe_1.pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    exports.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
        if (!promiseCtor) {
            promiseCtor = config$1.config.Promise || Promise;
        }
        if (!promiseCtor) {
            throw new Error('no Promise impl found');
        }
        return promiseCtor;
    }
    //# sourceMappingURL=Observable.js.map
    });

    var scan_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function scan(accumulator, seed) {
        var hasSeed = false;
        if (arguments.length >= 2) {
            hasSeed = true;
        }
        return function scanOperatorFunction(source) {
            return source.lift(new ScanOperator(accumulator, seed, hasSeed));
        };
    }
    exports.scan = scan;
    var ScanOperator = (function () {
        function ScanOperator(accumulator, seed, hasSeed) {
            if (hasSeed === void 0) { hasSeed = false; }
            this.accumulator = accumulator;
            this.seed = seed;
            this.hasSeed = hasSeed;
        }
        ScanOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
        };
        return ScanOperator;
    }());
    var ScanSubscriber = (function (_super) {
        __extends(ScanSubscriber, _super);
        function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
            var _this = _super.call(this, destination) || this;
            _this.accumulator = accumulator;
            _this._seed = _seed;
            _this.hasSeed = hasSeed;
            _this.index = 0;
            return _this;
        }
        Object.defineProperty(ScanSubscriber.prototype, "seed", {
            get: function () {
                return this._seed;
            },
            set: function (value) {
                this.hasSeed = true;
                this._seed = value;
            },
            enumerable: true,
            configurable: true
        });
        ScanSubscriber.prototype._next = function (value) {
            if (!this.hasSeed) {
                this.seed = value;
                this.destination.next(value);
            }
            else {
                return this._tryNext(value);
            }
        };
        ScanSubscriber.prototype._tryNext = function (value) {
            var index = this.index++;
            var result;
            try {
                result = this.accumulator(this.seed, value, index);
            }
            catch (err) {
                this.destination.error(err);
            }
            this.seed = result;
            this.destination.next(result);
        };
        return ScanSubscriber;
    }(Subscriber_1.Subscriber));
    //# sourceMappingURL=scan.js.map
    });

    var ArgumentOutOfRangeError = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var ArgumentOutOfRangeErrorImpl = (function () {
        function ArgumentOutOfRangeErrorImpl() {
            Error.call(this);
            this.message = 'argument out of range';
            this.name = 'ArgumentOutOfRangeError';
            return this;
        }
        ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
        return ArgumentOutOfRangeErrorImpl;
    })();
    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
    //# sourceMappingURL=ArgumentOutOfRangeError.js.map
    });

    var empty_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
    function empty(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty;
    function emptyScheduled(scheduler) {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }
    //# sourceMappingURL=empty.js.map
    });

    var takeLast_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });



    function takeLast(count) {
        return function takeLastOperatorFunction(source) {
            if (count === 0) {
                return empty_1.empty();
            }
            else {
                return source.lift(new TakeLastOperator(count));
            }
        };
    }
    exports.takeLast = takeLast;
    var TakeLastOperator = (function () {
        function TakeLastOperator(total) {
            this.total = total;
            if (this.total < 0) {
                throw new ArgumentOutOfRangeError.ArgumentOutOfRangeError;
            }
        }
        TakeLastOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
        };
        return TakeLastOperator;
    }());
    var TakeLastSubscriber = (function (_super) {
        __extends(TakeLastSubscriber, _super);
        function TakeLastSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.ring = new Array();
            _this.count = 0;
            return _this;
        }
        TakeLastSubscriber.prototype._next = function (value) {
            var ring = this.ring;
            var total = this.total;
            var count = this.count++;
            if (ring.length < total) {
                ring.push(value);
            }
            else {
                var index = count % total;
                ring[index] = value;
            }
        };
        TakeLastSubscriber.prototype._complete = function () {
            var destination = this.destination;
            var count = this.count;
            if (count > 0) {
                var total = this.count >= this.total ? this.total : this.count;
                var ring = this.ring;
                for (var i = 0; i < total; i++) {
                    var idx = (count++) % total;
                    destination.next(ring[idx]);
                }
            }
            destination.complete();
        };
        return TakeLastSubscriber;
    }(Subscriber_1.Subscriber));
    //# sourceMappingURL=takeLast.js.map
    });

    var defaultIfEmpty_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function defaultIfEmpty(defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
    }
    exports.defaultIfEmpty = defaultIfEmpty;
    var DefaultIfEmptyOperator = (function () {
        function DefaultIfEmptyOperator(defaultValue) {
            this.defaultValue = defaultValue;
        }
        DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
        };
        return DefaultIfEmptyOperator;
    }());
    var DefaultIfEmptySubscriber = (function (_super) {
        __extends(DefaultIfEmptySubscriber, _super);
        function DefaultIfEmptySubscriber(destination, defaultValue) {
            var _this = _super.call(this, destination) || this;
            _this.defaultValue = defaultValue;
            _this.isEmpty = true;
            return _this;
        }
        DefaultIfEmptySubscriber.prototype._next = function (value) {
            this.isEmpty = false;
            this.destination.next(value);
        };
        DefaultIfEmptySubscriber.prototype._complete = function () {
            if (this.isEmpty) {
                this.destination.next(this.defaultValue);
            }
            this.destination.complete();
        };
        return DefaultIfEmptySubscriber;
    }(Subscriber_1.Subscriber));
    //# sourceMappingURL=defaultIfEmpty.js.map
    });

    var reduce_1$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });




    function reduce(accumulator, seed) {
        if (arguments.length >= 2) {
            return function reduceOperatorFunctionWithSeed(source) {
                return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
            };
        }
        return function reduceOperatorFunction(source) {
            return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
        };
    }
    exports.reduce = reduce;
    //# sourceMappingURL=reduce.js.map
    });

    var reduce_1 = reduce_1$1.reduce;

    var reduce$1 = {
    	reduce: reduce_1
    };

    var Observable = Observable_1.Observable;



    var map$3 = map$4.map;

    var filter$4 = filter$5.filter;

    var reduce = reduce$1.reduce;
    /*
     A minimal rxjs based observable that align as closely as possible with the current es-observable spec,
     without the static factory methods
     */


    function SanityObservableMinimal() {
      Observable.apply(this, arguments); // eslint-disable-line prefer-rest-params
    }

    SanityObservableMinimal.prototype = Object.create(objectAssign(Object.create(null), Observable.prototype));
    Object.defineProperty(SanityObservableMinimal.prototype, 'constructor', {
      value: SanityObservableMinimal,
      enumerable: false,
      writable: true,
      configurable: true
    });

    SanityObservableMinimal.prototype.lift = function lift(operator) {
      var observable = new SanityObservableMinimal();
      observable.source = this;
      observable.operator = operator;
      return observable;
    };

    function createDeprecatedMemberOp(name, op) {
      var hasWarned = false;
      return function deprecatedOperator() {
        if (!hasWarned) {
          hasWarned = true;
          console.warn(new Error("Calling observable.".concat(name, "(...) is deprecated. Please use observable.pipe(").concat(name, "(...)) instead")));
        }

        return this.pipe(op.apply(this, arguments));
      };
    }

    SanityObservableMinimal.prototype.map = createDeprecatedMemberOp('map', map$3);
    SanityObservableMinimal.prototype.filter = createDeprecatedMemberOp('filter', filter$4);
    SanityObservableMinimal.prototype.reduce = createDeprecatedMemberOp('filter', reduce);
    var SanityObservableMinimal_1 = SanityObservableMinimal;

    var minimal = SanityObservableMinimal_1;

    var eventsource = createCommonjsModule(function (module) {
    (function (root, factory) {
      /* global define */
      if (module.exports) {
        // CommonJS
        module.exports = factory();
      } else {
        // Browser globals (root is window)
        if (commonjsGlobal.EventSource && !commonjsGlobal._eventSourceImportPrefix) {
          return
        }

        var evsImportName = (root._eventSourceImportPrefix || '') + 'EventSource';
        root[evsImportName] = factory();
      }
    })(typeof self === 'undefined' ? commonjsGlobal : self, function () {
      var EventSource = function (url, options) {
        if (!url || typeof url != 'string') {
          throw new SyntaxError('Not enough arguments')
        }

        this.URL = url;
        this.setOptions(options);
        var evs = this;
        setTimeout(function () {
          evs.poll();
        }, 0);
      };

      EventSource.prototype = {
        CONNECTING: 0,

        OPEN: 1,

        CLOSED: 2,

        defaultOptions: {
          loggingEnabled: false,

          loggingPrefix: 'eventsource',

          interval: 500, // milliseconds

          bufferSizeLimit: 256 * 1024, // bytes

          silentTimeout: 300000, // milliseconds

          getArgs: {
            evs_buffer_size_limit: 256 * 1024,
          },

          xhrHeaders: {
            Accept: 'text/event-stream',
            'Cache-Control': 'no-cache',
            'X-Requested-With': 'XMLHttpRequest',
          },
        },

        setOptions: function (options) {
          var defaults = this.defaultOptions;
          var option;

          // set all default options...
          for (option in defaults) {
            if (defaults.hasOwnProperty(option)) {
              this[option] = defaults[option];
            }
          }

          // override with what is in options
          for (option in options) {
            if (option in defaults && options.hasOwnProperty(option)) {
              this[option] = options[option];
            }
          }

          // if getArgs option is enabled
          // ensure evs_buffer_size_limit corresponds to bufferSizeLimit
          if (this.getArgs && this.bufferSizeLimit) {
            this.getArgs.evs_buffer_size_limit = this.bufferSizeLimit;
          }

          // if console is not available, force loggingEnabled to false
          // eslint-disable-next-line no-console
          if (typeof console === 'undefined' || typeof console.log === 'undefined') {
            this.loggingEnabled = false;
          }
        },

        log: function (message) {
          if (this.loggingEnabled) {
            // eslint-disable-next-line no-console
            console.log('[' + this.loggingPrefix + ']:' + message);
          }
        },

        poll: function () {
          try {
            if (this.readyState == this.CLOSED) {
              return
            }

            this.cleanup();
            this.readyState = this.CONNECTING;
            this.cursor = 0;
            this.cache = '';
            this._xhr = new this.XHR(this);
            this.resetNoActivityTimer();
          } catch (err) {
            // in an attempt to silence the errors
            this.log('There were errors inside the pool try-catch');
            this.dispatchEvent('error', {type: 'error', data: err.message});
          }
        },

        pollAgain: function (interval) {
          // schedule poll to be called after interval milliseconds
          var evs = this;
          evs.readyState = evs.CONNECTING;
          evs.dispatchEvent('error', {
            type: 'error',
            data: 'Reconnecting ',
          });
          this._pollTimer = setTimeout(function () {
            evs.poll();
          }, interval || 0);
        },

        cleanup: function () {
          this.log('evs cleaning up');

          if (this._pollTimer) {
            clearInterval(this._pollTimer);
            this._pollTimer = null;
          }

          if (this._noActivityTimer) {
            clearInterval(this._noActivityTimer);
            this._noActivityTimer = null;
          }

          if (this._xhr) {
            this._xhr.abort();
            this._xhr = null;
          }
        },

        resetNoActivityTimer: function () {
          if (this.silentTimeout) {
            if (this._noActivityTimer) {
              clearInterval(this._noActivityTimer);
            }
            var evs = this;
            this._noActivityTimer = setTimeout(function () {
              evs.log('Timeout! silentTImeout:' + evs.silentTimeout);
              evs.pollAgain();
            }, this.silentTimeout);
          }
        },

        close: function () {
          this.readyState = this.CLOSED;
          this.log('Closing connection. readyState: ' + this.readyState);
          this.cleanup();
        },

        _onxhrdata: function () {
          var request = this._xhr;

          if (request.isReady() && !request.hasError()) {
            // reset the timer, as we have activity
            this.resetNoActivityTimer();

            // move this EventSource to OPEN state...
            if (this.readyState == this.CONNECTING) {
              this.readyState = this.OPEN;
              this.dispatchEvent('open', {type: 'open'});
            }

            var buffer = request.getBuffer();

            if (buffer.length > this.bufferSizeLimit) {
              this.log('buffer.length > this.bufferSizeLimit');
              this.pollAgain();
            }

            if (this.cursor == 0 && buffer.length > 0) {
              // skip byte order mark \uFEFF character if it starts the stream
              if (buffer.substring(0, 1) == '\uFEFF') {
                this.cursor = 1;
              }
            }

            var lastMessageIndex = this.lastMessageIndex(buffer);
            if (lastMessageIndex[0] >= this.cursor) {
              var newcursor = lastMessageIndex[1];
              var toparse = buffer.substring(this.cursor, newcursor);
              this.parseStream(toparse);
              this.cursor = newcursor;
            }

            // if request is finished, reopen the connection
            if (request.isDone()) {
              this.log('request.isDone(). reopening the connection');
              this.pollAgain(this.interval);
            }
          } else if (this.readyState !== this.CLOSED) {
            this.log('this.readyState !== this.CLOSED');
            this.pollAgain(this.interval);

            //MV: Unsure why an error was previously dispatched
          }
        },

        parseStream: function (chunk) {
          // normalize line separators (\r\n,\r,\n) to \n
          // remove white spaces that may precede \n
          chunk = this.cache + this.normalizeToLF(chunk);

          var events = chunk.split('\n\n');

          var i, j, eventType, datas, line, retry;

          for (i = 0; i < events.length - 1; i++) {
            eventType = 'message';
            datas = [];
            var parts = events[i].split('\n');

            for (j = 0; j < parts.length; j++) {
              line = this.trimWhiteSpace(parts[j]);

              if (line.indexOf('event') == 0) {
                eventType = line.replace(/event:?\s*/, '');
              } else if (line.indexOf('retry') == 0) {
                retry = parseInt(line.replace(/retry:?\s*/, ''), 10);
                if (!isNaN(retry)) {
                  this.interval = retry;
                }
              } else if (line.indexOf('data') == 0) {
                datas.push(line.replace(/data:?\s*/, ''));
              } else if (line.indexOf('id:') == 0) {
                this.lastEventId = line.replace(/id:?\s*/, '');
              } else if (line.indexOf('id') == 0) {
                // this resets the id

                this.lastEventId = null;
              }
            }

            if (datas.length && this.readyState != this.CLOSED) {
              // dispatch a new event
              var event = new MessageEvent(
                eventType,
                datas.join('\n'),
                typeof window !== 'undefined' && typeof window.location !== 'undefined'
                  ? window.location.origin
                  : null,
                this.lastEventId
              );
              this.dispatchEvent(eventType, event);
            }
          }

          this.cache = events[events.length - 1];
        },

        dispatchEvent: function (type, event) {
          var handlers = this['_' + type + 'Handlers'];

          if (handlers) {
            for (var i = 0; i < handlers.length; i++) {
              handlers[i].call(this, event);
            }
          }

          if (this['on' + type]) {
            this['on' + type].call(this, event);
          }
        },

        addEventListener: function (type, handler) {
          if (!this['_' + type + 'Handlers']) {
            this['_' + type + 'Handlers'] = [];
          }

          this['_' + type + 'Handlers'].push(handler);
        },

        removeEventListener: function (type, handler) {
          var handlers = this['_' + type + 'Handlers'];
          if (!handlers) {
            return
          }
          for (var i = handlers.length - 1; i >= 0; --i) {
            if (handlers[i] === handler) {
              handlers.splice(i, 1);
              break
            }
          }
        },

        _pollTimer: null,

        _noactivityTimer: null,

        _xhr: null,

        lastEventId: null,

        cache: '',

        cursor: 0,

        onerror: null,

        onmessage: null,

        onopen: null,

        readyState: 0,

        // ===================================================================
        // helpers functions
        // those are attached to prototype to ease reuse and testing...

        urlWithParams: function (baseURL, params) {
          var encodedArgs = [];

          if (params) {
            var key, urlarg;
            var urlize = encodeURIComponent;

            for (key in params) {
              if (params.hasOwnProperty(key)) {
                urlarg = urlize(key) + '=' + urlize(params[key]);
                encodedArgs.push(urlarg);
              }
            }
          }

          if (encodedArgs.length > 0) {
            if (baseURL.indexOf('?') == -1) return baseURL + '?' + encodedArgs.join('&')
            return baseURL + '&' + encodedArgs.join('&')
          }
          return baseURL
        },

        lastMessageIndex: function (text) {
          var ln2 = text.lastIndexOf('\n\n');
          var lr2 = text.lastIndexOf('\r\r');
          var lrln2 = text.lastIndexOf('\r\n\r\n');

          if (lrln2 > Math.max(ln2, lr2)) {
            return [lrln2, lrln2 + 4]
          }
          return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]
        },

        trimWhiteSpace: function (str) {
          // to remove whitespaces left and right of string

          var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
          return str.replace(reTrim, '')
        },

        normalizeToLF: function (str) {
          // replace \r and \r\n with \n
          return str.replace(/\r\n|\r/g, '\n')
        },
      };

      if (isOldIE()) {
        EventSource.isPolyfill = 'IE_8-9';

        // patch EventSource defaultOptions
        var defaults = EventSource.prototype.defaultOptions;
        defaults.xhrHeaders = null; // no headers will be sent
        defaults.getArgs.evs_preamble = 2048 + 8;

        // EventSource will send request using Internet Explorer XDomainRequest
        EventSource.prototype.XHR = function (evs) {
          /* global XDomainRequest */
          var request = new XDomainRequest();
          this._request = request;

          // set handlers
          request.onprogress = function () {
            request._ready = true;
            evs._onxhrdata();
          };

          request.onload = function () {
            this._loaded = true;
            evs._onxhrdata();
          };

          request.onerror = function () {
            this._failed = true;
            evs.readyState = evs.CLOSED;
            evs.dispatchEvent('error', {
              type: 'error',
              data: 'XDomainRequest error',
            });
          };

          request.ontimeout = function () {
            this._failed = true;
            evs.readyState = evs.CLOSED;
            evs.dispatchEvent('error', {
              type: 'error',
              data: 'XDomainRequest timed out',
            });
          };

          // XDomainRequest does not allow setting custom headers
          // If EventSource has enabled the use of GET arguments
          // we add parameters to URL so that server can adapt the stream...
          var reqGetArgs = {};
          if (evs.getArgs) {
            // copy evs.getArgs in reqGetArgs
            var defaultArgs = evs.getArgs;
            for (var key in defaultArgs) {
              if (defaultArgs.hasOwnProperty(key)) {
                reqGetArgs[key] = defaultArgs[key];
              }
            }
            if (evs.lastEventId) {
              reqGetArgs.evs_last_event_id = evs.lastEventId;
            }
          }
          // send the request

          request.open('GET', evs.urlWithParams(evs.URL, reqGetArgs));
          request.send();
        };

        EventSource.prototype.XHR.prototype = {
          useXDomainRequest: true,

          _request: null,

          _ready: false, // true when progress events are dispatched

          _loaded: false, // true when request has been loaded

          _failed: false, // true if when request is in error

          isReady: function () {
            return this._request._ready
          },

          isDone: function () {
            return this._request._loaded
          },

          hasError: function () {
            return this._request._failed
          },

          getBuffer: function () {
            var rv = '';
            try {
              rv = this._request.responseText || '';
            } catch (err) {
              // intentional noop
            }
            return rv
          },

          abort: function () {
            if (this._request) {
              this._request.abort();
            }
          },
        };
      } else {
        EventSource.isPolyfill = 'XHR';

        // EventSource will send request using XMLHttpRequest
        EventSource.prototype.XHR = function (evs) {
          var request = new XMLHttpRequest();
          this._request = request;
          evs._xhr = this;

          // set handlers
          request.onreadystatechange = function () {
            if (request.readyState > 1 && evs.readyState != evs.CLOSED) {
              if (request.status == 200 || (request.status >= 300 && request.status < 400)) {
                evs._onxhrdata();
              } else {
                request._failed = true;
                evs.readyState = evs.CLOSED;
                evs.dispatchEvent('error', {
                  type: 'error',
                  data: 'The server responded with ' + request.status,
                });
                evs.close();
              }
            }
          };

          request.onprogress = function () {
            // intentional noop
          };

          request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true);

          var headers = evs.xhrHeaders; // maybe null
          for (var header in headers) {
            if (headers.hasOwnProperty(header)) {
              request.setRequestHeader(header, headers[header]);
            }
          }
          if (evs.lastEventId) {
            request.setRequestHeader('Last-Event-Id', evs.lastEventId);
          }

          request.send();
        };

        EventSource.prototype.XHR.prototype = {
          useXDomainRequest: false,

          _request: null,

          _failed: false, // true if we have had errors...

          isReady: function () {
            return this._request.readyState >= 2
          },

          isDone: function () {
            return this._request.readyState == 4
          },

          hasError: function () {
            return this._failed || this._request.status >= 400
          },

          getBuffer: function () {
            var rv = '';
            try {
              rv = this._request.responseText || '';
            } catch (err) {
              // intentional noop
            }
            return rv
          },

          abort: function () {
            if (this._request) {
              this._request.abort();
            }
          },
        };
      }

      function MessageEvent(type, data, origin, lastEventId) {
        this.bubbles = false;
        this.cancelBubble = false;
        this.cancelable = false;
        this.data = data || null;
        this.origin = origin || '';
        this.lastEventId = lastEventId || '';
        this.type = type || 'message';
      }

      function isOldIE() {
        //return true if we are in IE8 or IE9
        return Boolean(
          typeof window !== 'undefined' &&
            window.XDomainRequest &&
            window.XMLHttpRequest &&
            new XMLHttpRequest().responseType === undefined
        )
      }

      return EventSource
    });
    });

    /* eslint-disable no-var */


    var browser = window.EventSource || eventsource.EventSource;

    var pick = function (obj, props) {
      return props.reduce(function (selection, prop) {
        if (typeof obj[prop] === 'undefined') {
          return selection;
        }

        selection[prop] = obj[prop];
        return selection;
      }, {});
    };

    var defaults$1 = function (obj, defaults) {
      return Object.keys(defaults).concat(Object.keys(obj)).reduce(function (target, prop) {
        target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];
        return target;
      }, {});
    };

    var baseUrl$1 = 'https://docs.sanity.io/help/';

    var generateHelpUrl$1 = function generateHelpUrl(slug) {
      return baseUrl$1 + slug
    };

    var once = function (fn) {
      var didCall = false;
      var returnValue;
      return function () {
        if (didCall) {
          return returnValue;
        }

        returnValue = fn.apply(void 0, arguments);
        didCall = true;
        return returnValue;
      };
    };

    var tokenWarning = ['Using token with listeners is not supported in browsers. ', "For more info, see ".concat(generateHelpUrl$1('js-client-listener-tokens-browser'), ".")]; // eslint-disable-next-line no-console

    var printTokenWarning = once(function () {
      return console.warn(tokenWarning.join(' '));
    });
    var isWindowEventSource = Boolean(typeof window !== 'undefined' && window.EventSource);
    var EventSource = isWindowEventSource ? window.EventSource // Native browser EventSource
    : browser; // Node.js, IE etc

    var possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat'];
    var defaultOptions$1 = {
      includeResult: true
    };

    var listen = function listen(query, params) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var options = defaults$1(opts, defaultOptions$1);
      var listenOpts = pick(options, possibleOptions);
      var qs = encodeQueryString({
        query: query,
        params: params,
        options: listenOpts
      });
      var _this$clientConfig = this.clientConfig,
          url = _this$clientConfig.url,
          token = _this$clientConfig.token,
          withCredentials = _this$clientConfig.withCredentials;
      var uri = "".concat(url).concat(this.getDataUrl('listen', qs));
      var listenFor = options.events ? options.events : ['mutation'];
      var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;

      if (token && isWindowEventSource) {
        printTokenWarning();
      }

      var esOptions = {};

      if (token || withCredentials) {
        esOptions.withCredentials = true;
      }

      if (token) {
        esOptions.headers = {
          Authorization: "Bearer ".concat(token)
        };
      }

      return new minimal(function (observer) {
        var es = getEventSource();
        var reconnectTimer;
        var stopped = false;

        function onError() {
          if (stopped) {
            return;
          }

          emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt

          if (stopped) {
            return;
          } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),
          // we should never be in a disconnected state. By default, EventSource will reconnect
          // automatically, in which case it sets readyState to `CONNECTING`, but in some cases
          // (like when a laptop lid is closed), it closes the connection. In these cases we need
          // to explicitly reconnect.


          if (es.readyState === EventSource.CLOSED) {
            unsubscribe();
            clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(open, 100);
          }
        }

        function onChannelError(err) {
          observer.error(cooerceError(err));
        }

        function onMessage(evt) {
          var event = parseEvent(evt);
          return event instanceof Error ? observer.error(event) : observer.next(event);
        }

        function onDisconnect(evt) {
          stopped = true;
          unsubscribe();
          observer.complete();
        }

        function unsubscribe() {
          es.removeEventListener('error', onError, false);
          es.removeEventListener('channelError', onChannelError, false);
          es.removeEventListener('disconnect', onDisconnect, false);
          listenFor.forEach(function (type) {
            return es.removeEventListener(type, onMessage, false);
          });
          es.close();
        }

        function emitReconnect() {
          if (shouldEmitReconnect) {
            observer.next({
              type: 'reconnect'
            });
          }
        }

        function getEventSource() {
          var evs = new EventSource(uri, esOptions);
          evs.addEventListener('error', onError, false);
          evs.addEventListener('channelError', onChannelError, false);
          evs.addEventListener('disconnect', onDisconnect, false);
          listenFor.forEach(function (type) {
            return evs.addEventListener(type, onMessage, false);
          });
          return evs;
        }

        function open() {
          es = getEventSource();
        }

        function stop() {
          stopped = true;
          unsubscribe();
        }

        return stop;
      });
    };

    function parseEvent(event) {
      try {
        var data = event.data && JSON.parse(event.data) || {};
        return objectAssign({
          type: event.type
        }, data);
      } catch (err) {
        return err;
      }
    }

    function cooerceError(err) {
      if (err instanceof Error) {
        return err;
      }

      var evt = parseEvent(err);
      return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
    }

    function extractErrorMessage(err) {
      if (!err.error) {
        return err.message || 'Unknown listener error';
      }

      if (err.error.description) {
        return err.error.description;
      }

      return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);
    }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



    var filter$3 = filter$5.filter;

    var map$2 = map$4.map;













    var excludeFalsey = function excludeFalsey(param, defValue) {
      var value = typeof param === 'undefined' ? defValue : param;
      return param === false ? undefined : value;
    };

    var getMutationQuery = function getMutationQuery() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        returnIds: true,
        returnDocuments: excludeFalsey(options.returnDocuments, true),
        visibility: options.visibility || 'sync'
      };
    };

    var isResponse = function isResponse(event) {
      return event.type === 'response';
    };

    var getBody = function getBody(event) {
      return event.body;
    };

    var indexBy = function indexBy(docs, attr) {
      return docs.reduce(function (indexed, doc) {
        indexed[attr(doc)] = doc;
        return indexed;
      }, Object.create(null));
    };

    var toPromise$1 = function toPromise(observable) {
      return observable.toPromise();
    };

    var getQuerySizeLimit = 11264;
    var dataMethods = {
      listen: listen,
      getDataUrl: function getDataUrl(operation, path) {
        var config = this.clientConfig;
        var catalog = config.gradientMode ? config.namespace : validators.hasDataset(config);
        var baseUri = "/".concat(operation, "/").concat(catalog);
        var uri = path ? "".concat(baseUri, "/").concat(path) : baseUri;
        return (this.clientConfig.gradientMode ? uri : "/data".concat(uri)).replace(/\/($|\?)/, '$1');
      },
      fetch: function fetch(query, params) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var mapResponse = options.filterResponse === false ? function (res) {
          return res;
        } : function (res) {
          return res.result;
        };

        var observable = this._dataRequest('query', {
          query: query,
          params: params
        }, options).pipe(map$2(mapResponse));

        return this.isPromiseAPI() ? toPromise$1(observable) : observable;
      },
      getDocument: function getDocument(id) {
        var options = {
          uri: this.getDataUrl('doc', id),
          json: true
        };

        var observable = this._requestObservable(options).pipe(filter$3(isResponse), map$2(function (event) {
          return event.body.documents && event.body.documents[0];
        }));

        return this.isPromiseAPI() ? toPromise$1(observable) : observable;
      },
      getDocuments: function getDocuments(ids) {
        var options = {
          uri: this.getDataUrl('doc', ids.join(',')),
          json: true
        };

        var observable = this._requestObservable(options).pipe(filter$3(isResponse), map$2(function (event) {
          var indexed = indexBy(event.body.documents || [], function (doc) {
            return doc._id;
          });
          return ids.map(function (id) {
            return indexed[id] || null;
          });
        }));

        return this.isPromiseAPI() ? toPromise$1(observable) : observable;
      },
      create: function create(doc, options) {
        return this._create(doc, 'create', options);
      },
      createIfNotExists: function createIfNotExists(doc, options) {
        validators.requireDocumentId('createIfNotExists', doc);
        return this._create(doc, 'createIfNotExists', options);
      },
      createOrReplace: function createOrReplace(doc, options) {
        validators.requireDocumentId('createOrReplace', doc);
        return this._create(doc, 'createOrReplace', options);
      },
      patch: function patch$1(selector, operations) {
        return new patch(selector, operations, this);
      },
      delete: function _delete(selection, options) {
        return this.dataRequest('mutate', {
          mutations: [{
            delete: getSelection(selection)
          }]
        }, options);
      },
      mutate: function mutate(mutations, options) {
        var mut = mutations instanceof patch || mutations instanceof transaction ? mutations.serialize() : mutations;
        var muts = Array.isArray(mut) ? mut : [mut];
        var transactionId = options && options.transactionId;
        return this.dataRequest('mutate', {
          mutations: muts,
          transactionId: transactionId
        }, options);
      },
      transaction: function transaction$1(operations) {
        return new transaction(operations, this);
      },
      dataRequest: function dataRequest(endpoint, body) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var request = this._dataRequest(endpoint, body, options);

        return this.isPromiseAPI() ? toPromise$1(request) : request;
      },
      _dataRequest: function _dataRequest(endpoint, body) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isMutation = endpoint === 'mutate'; // Check if the query string is within a configured threshold,
        // in which case we can use GET. Otherwise, use POST.

        var strQuery = !isMutation && encodeQueryString(body);
        var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
        var stringQuery = useGet ? strQuery : '';
        var returnFirst = options.returnFirst;
        var timeout = options.timeout,
            token = options.token;
        var uri = this.getDataUrl(endpoint, stringQuery);
        var reqOptions = {
          method: useGet ? 'GET' : 'POST',
          uri: uri,
          json: true,
          body: useGet ? undefined : body,
          query: isMutation && getMutationQuery(options),
          timeout: timeout,
          token: token
        };
        return this._requestObservable(reqOptions).pipe(filter$3(isResponse), map$2(getBody), map$2(function (res) {
          if (!isMutation) {
            return res;
          } // Should we return documents?


          var results = res.results || [];

          if (options.returnDocuments) {
            return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
              return mut.document;
            });
          } // Return a reduced subset


          var key = returnFirst ? 'documentId' : 'documentIds';
          var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
            return mut.id;
          });
          return _defineProperty$1({
            transactionId: res.transactionId,
            results: results
          }, key, ids);
        }));
      },
      _create: function _create(doc, op) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var mutation = _defineProperty$1({}, op, doc);

        var opts = objectAssign({
          returnFirst: true,
          returnDocuments: true
        }, options);
        return this.dataRequest('mutate', {
          mutations: [mutation]
        }, opts);
      }
    };

    function DatasetsClient(client) {
      this.request = client.request.bind(client);
    }

    objectAssign(DatasetsClient.prototype, {
      create: function create(name, options) {
        return this._modify('PUT', name, options);
      },
      edit: function edit(name, options) {
        return this._modify('PATCH', name, options);
      },
      delete: function _delete(name) {
        return this._modify('DELETE', name);
      },
      list: function list() {
        return this.request({
          uri: '/datasets'
        });
      },
      _modify: function _modify(method, name, body) {
        validators.dataset(name);
        return this.request({
          method: method,
          uri: "/datasets/".concat(name),
          body: body
        });
      }
    });
    var datasetsClient = DatasetsClient;

    function ProjectsClient(client) {
      this.client = client;
    }

    objectAssign(ProjectsClient.prototype, {
      list: function list() {
        return this.client.request({
          uri: '/projects'
        });
      },
      getById: function getById(id) {
        return this.client.request({
          uri: "/projects/".concat(id)
        });
      }
    });
    var projectsClient = ProjectsClient;

    var queryString = function (params) {
      var qs = [];

      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(params[key])));
        }
      }

      return qs.length > 0 ? "?".concat(qs.join('&')) : '';
    };

    function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1(); }

    function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

    function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

    function _iterableToArrayLimit$1(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }



    var map$1 = map$4.map;

    var filter$2 = filter$5.filter;





    function AssetsClient(client) {
      this.client = client;
    }

    function toDocument(body) {
      // todo: rewrite to just return body.document in a while
      var document = body.document;
      Object.defineProperty(document, 'document', {
        enumerable: false,
        get: function get() {
          // eslint-disable-next-line no-console
          console.warn('The promise returned from client.asset.upload(...) now resolves with the asset document');
          return document;
        }
      });
      return document;
    }

    function optionsFromFile(opts, file) {
      if (typeof window === 'undefined' || !(file instanceof window.File)) {
        return opts;
      }

      return objectAssign({
        filename: opts.preserveFilename === false ? undefined : file.name,
        contentType: file.type
      }, opts);
    }

    objectAssign(AssetsClient.prototype, {
      /**
       * Upload an asset
       *
       * @param  {String} assetType `image` or `file`
       * @param  {File|Blob|Buffer|ReadableStream} body File to upload
       * @param  {Object}  opts Options for the upload
       * @param  {Boolean} opts.preserveFilename Whether or not to preserve the original filename (default: true)
       * @param  {String}  opts.filename Filename for this file (optional)
       * @param  {Number}  opts.timeout  Milliseconds to wait before timing the request out (default: 0)
       * @param  {String}  opts.contentType Mime type of the file
       * @param  {Array}   opts.extract Array of metadata parts to extract from image.
       *                                 Possible values: `location`, `exif`, `image`, `palette`
       * @param  {String}  opts.label Label
       * @param  {String}  opts.title Title
       * @param  {String}  opts.description Description
       * @param  {String}  opts.creditLine The credit to person(s) and/or organization(s) required by the supplier of the image to be used when published
       * @param  {Object}  opts.source Source data (when the asset is from an external service)
       * @param  {String}  opts.source.id The (u)id of the asset within the source, i.e. 'i-f323r1E'
       *                                  Required if source is defined
       * @param  {String}  opts.source.name The name of the source, i.e. 'unsplash'
       *                                  Required if source is defined
       * @param  {String}  opts.source.url A url to where to find the asset, or get more info about it in the source
       *                                  Optional
       * @return {Promise} Resolves with the created asset document
       */
      upload: function upload(assetType, body) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        validators.validateAssetType(assetType); // If an empty array is given, explicitly set `none` to override API defaults

        var meta = opts.extract || undefined;

        if (meta && !meta.length) {
          meta = ['none'];
        }

        var dataset = validators.hasDataset(this.client.clientConfig);
        var assetEndpoint = assetType === 'image' ? 'images' : 'files';
        var options = optionsFromFile(opts, body);
        var label = options.label,
            title = options.title,
            description = options.description,
            creditLine = options.creditLine,
            filename = options.filename,
            source = options.source;
        var query = {
          label: label,
          title: title,
          description: description,
          filename: filename,
          meta: meta,
          creditLine: creditLine
        };

        if (source) {
          query.sourceId = source.id;
          query.sourceName = source.name;
          query.sourceUrl = source.url;
        }

        var observable = this.client._requestObservable({
          method: 'POST',
          timeout: options.timeout || 0,
          uri: "/assets/".concat(assetEndpoint, "/").concat(dataset),
          headers: options.contentType ? {
            'Content-Type': options.contentType
          } : {},
          query: query,
          body: body
        });

        return this.client.isPromiseAPI() ? observable.pipe(filter$2(function (event) {
          return event.type === 'response';
        }), map$1(function (event) {
          return toDocument(event.body);
        })).toPromise() : observable;
      },
      delete: function _delete(type, id) {
        // eslint-disable-next-line no-console
        console.warn('client.assets.delete() is deprecated, please use client.delete(<document-id>)');
        var docId = id || '';

        if (!/^(image|file)-/.test(docId)) {
          docId = "".concat(type, "-").concat(docId);
        } else if (type._id) {
          // We could be passing an entire asset document instead of an ID
          docId = type._id;
        }

        validators.hasDataset(this.client.clientConfig);
        return this.client.delete(docId);
      },
      getImageUrl: function getImageUrl(ref, query) {
        var id = ref._ref || ref;

        if (typeof id !== 'string') {
          throw new Error('getImageUrl() needs either an object with a _ref, or a string with an asset document ID');
        }

        if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
          throw new Error("Unsupported asset ID \"".concat(id, "\". URL generation only works for auto-generated IDs."));
        }

        var _id$split = id.split('-'),
            _id$split2 = _slicedToArray$1(_id$split, 4),
            assetId = _id$split2[1],
            size = _id$split2[2],
            format = _id$split2[3];

        validators.hasDataset(this.client.clientConfig);
        var _this$client$clientCo = this.client.clientConfig,
            projectId = _this$client$clientCo.projectId,
            dataset = _this$client$clientCo.dataset;
        var qs = query ? queryString(query) : '';
        return "https://cdn.sanity.io/images/".concat(projectId, "/").concat(dataset, "/").concat(assetId, "-").concat(size, ".").concat(format).concat(qs);
      }
    });
    var assetsClient = AssetsClient;

    function UsersClient(client) {
      this.client = client;
    }

    objectAssign(UsersClient.prototype, {
      getById: function getById(id) {
        return this.client.request({
          uri: "/users/".concat(id)
        });
      }
    });
    var usersClient = UsersClient;

    function AuthClient(client) {
      this.client = client;
    }

    objectAssign(AuthClient.prototype, {
      getLoginProviders: function getLoginProviders() {
        return this.client.request({
          uri: '/auth/providers'
        });
      },
      logout: function logout() {
        return this.client.request({
          uri: '/auth/logout',
          method: 'POST'
        });
      }
    });
    var authClient = AuthClient;

    var nanoPubsub = function Pubsub() {
      var subscribers = [];
      return {
        subscribe: subscribe,
        publish: publish
      }
      function subscribe(subscriber) {
        subscribers.push(subscriber);
        return function unsubscribe() {
          var idx = subscribers.indexOf(subscriber);
          if (idx > -1) {
            subscribers.splice(idx, 1);
          }
        }
      }
      function publish() {
        for (var i = 0; i < subscribers.length; i++) {
          subscribers[i].apply(null, arguments);
        }
      }
    };

    var middlewareReducer = function (middleware) {
      var applyMiddleware = function applyMiddleware(hook, defaultValue) {
        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        var bailEarly = hook === 'onError';

        var value = defaultValue;
        for (var i = 0; i < middleware[hook].length; i++) {
          var handler = middleware[hook][i];
          value = handler.apply(undefined, [value].concat(args));

          if (bailEarly && !value) {
            break;
          }
        }

        return value;
      };

      return applyMiddleware;
    };

    /**
     * Check if we're required to add a port number.
     *
     * @see https://url.spec.whatwg.org/#default-port
     * @param {Number|String} port Port number we need to check
     * @param {String} protocol Protocol we need to check against.
     * @returns {Boolean} Is it a default port for the given protocol
     * @api private
     */
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(':')[0];
      port = +port;

      if (!port) return false;

      switch (protocol) {
        case 'http':
        case 'ws':
        return port !== 80;

        case 'https':
        case 'wss':
        return port !== 443;

        case 'ftp':
        return port !== 21;

        case 'gopher':
        return port !== 70;

        case 'file':
        return false;
      }

      return port !== 0;
    };

    var has$3 = Object.prototype.hasOwnProperty
      , undef;

    /**
     * Decode a URI encoded string.
     *
     * @param {String} input The URI encoded string.
     * @returns {String|Null} The decoded string.
     * @api private
     */
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, ' '));
      } catch (e) {
        return null;
      }
    }

    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?&]+)=?([^&]*)/g
        , result = {}
        , part;

      while (part = parser.exec(query)) {
        var key = decode(part[1])
          , value = decode(part[2]);

        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        // In the case if failed decoding, we want to omit the key/value pairs
        // from the result.
        //
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }

      return result;
    }

    /**
     * Transform a query string to an object.
     *
     * @param {Object} obj Object that should be transformed.
     * @param {String} prefix Optional prefix.
     * @returns {String}
     * @api public
     */
    function querystringify(obj, prefix) {
      prefix = prefix || '';

      var pairs = []
        , value
        , key;

      //
      // Optionally prefix with a '?' if needed
      //
      if ('string' !== typeof prefix) prefix = '?';

      for (key in obj) {
        if (has$3.call(obj, key)) {
          value = obj[key];

          //
          // Edge cases where we actually want to encode the value to an empty
          // string instead of the stringified value.
          //
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = '';
          }

          key = encodeURIComponent(key);
          value = encodeURIComponent(value);

          //
          // If we failed to encode the strings, we should bail out as we don't
          // want to add invalid strings to the query.
          //
          if (key === null || value === null) continue;
          pairs.push(key +'='+ value);
        }
      }

      return pairs.length ? prefix + pairs.join('&') : '';
    }

    //
    // Expose the module.
    //
    var stringify = querystringify;
    var parse = querystring;

    var querystringify_1 = {
    	stringify: stringify,
    	parse: parse
    };

    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
      , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
      , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
      , left = new RegExp('^'+ whitespace +'+');

    /**
     * Trim a given string.
     *
     * @param {String} str String to trim.
     * @public
     */
    function trimLeft(str) {
      return (str ? str : '').toString().replace(left, '');
    }

    /**
     * These are the parse rules for the URL parser, it informs the parser
     * about:
     *
     * 0. The char it Needs to parse, if it's a string it should be done using
     *    indexOf, RegExp using exec and NaN means set as current value.
     * 1. The property we should set when parsing this value.
     * 2. Indication if it's backwards or forward parsing, when set as number it's
     *    the value of extra chars that should be split off.
     * 3. Inherit from location if non existing in the parser.
     * 4. `toLowerCase` the resulting value.
     */
    var rules = [
      ['#', 'hash'],                        // Extract from the back.
      ['?', 'query'],                       // Extract from the back.
      function sanitize(address) {          // Sanitize what is left of the address
        return address.replace('\\', '/');
      },
      ['/', 'pathname'],                    // Extract from the back.
      ['@', 'auth', 1],                     // Extract from the front.
      [NaN, 'host', undefined, 1, 1],       // Set left over value.
      [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    ];

    /**
     * These properties should not be copied or inherited from. This is only needed
     * for all non blob URL's as a blob URL does not include a hash, only the
     * origin.
     *
     * @type {Object}
     * @private
     */
    var ignore = { hash: 1, query: 1 };

    /**
     * The location object differs when your code is loaded through a normal page,
     * Worker or through a worker using a blob. And with the blobble begins the
     * trouble as the location object will contain the URL of the blob, not the
     * location of the page where our code is loaded in. The actual origin is
     * encoded in the `pathname` so we can thankfully generate a good "default"
     * location from it so we can generate proper relative URL's again.
     *
     * @param {Object|String} loc Optional default location object.
     * @returns {Object} lolcation object.
     * @public
     */
    function lolcation(loc) {
      var globalVar;

      if (typeof window !== 'undefined') globalVar = window;
      else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
      else if (typeof self !== 'undefined') globalVar = self;
      else globalVar = {};

      var location = globalVar.location || {};
      loc = loc || location;

      var finaldestination = {}
        , type = typeof loc
        , key;

      if ('blob:' === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ('string' === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ('object' === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }

        if (finaldestination.slashes === undefined) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }

      return finaldestination;
    }

    /**
     * @typedef ProtocolExtract
     * @type Object
     * @property {String} protocol Protocol matched in the URL, in lowercase.
     * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
     * @property {String} rest Rest of the URL that is not part of the protocol.
     */

    /**
     * Extract protocol information from a URL with/without double slash ("//").
     *
     * @param {String} address URL we want to extract from.
     * @return {ProtocolExtract} Extracted information.
     * @private
     */
    function extractProtocol(address) {
      address = trimLeft(address);
      var match = protocolre.exec(address);

      return {
        protocol: match[1] ? match[1].toLowerCase() : '',
        slashes: !!match[2],
        rest: match[3]
      };
    }

    /**
     * Resolve a relative URL pathname against a base URL pathname.
     *
     * @param {String} relative Pathname of the relative URL.
     * @param {String} base Pathname of the base URL.
     * @return {String} Resolved pathname.
     * @private
     */
    function resolve(relative, base) {
      if (relative === '') return base;

      var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
        , i = path.length
        , last = path[i - 1]
        , unshift = false
        , up = 0;

      while (i--) {
        if (path[i] === '.') {
          path.splice(i, 1);
        } else if (path[i] === '..') {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }

      if (unshift) path.unshift('');
      if (last === '.' || last === '..') path.push('');

      return path.join('/');
    }

    /**
     * The actual URL instance. Instead of returning an object we've opted-in to
     * create an actual constructor as it's much more memory efficient and
     * faster and it pleases my OCD.
     *
     * It is worth noting that we should not use `URL` as class name to prevent
     * clashes with the global URL instance that got introduced in browsers.
     *
     * @constructor
     * @param {String} address URL we want to parse.
     * @param {Object|String} [location] Location defaults for relative paths.
     * @param {Boolean|Function} [parser] Parser for the query string.
     * @private
     */
    function Url(address, location, parser) {
      address = trimLeft(address);

      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }

      var relative, extracted, parse, instruction, index, key
        , instructions = rules.slice()
        , type = typeof location
        , url = this
        , i = 0;

      //
      // The following if statements allows this module two have compatibility with
      // 2 different API:
      //
      // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
      //    where the boolean indicates that the query string should also be parsed.
      //
      // 2. The `URL` interface of the browser which accepts a URL, object as
      //    arguments. The supplied object will be used as default values / fall-back
      //    for relative paths.
      //
      if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
      }

      if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

      location = lolcation(location);

      //
      // Extract protocol information before running the instructions.
      //
      extracted = extractProtocol(address || '');
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || '';
      address = extracted.rest;

      //
      // When the authority component is absent the URL starts with a path
      // component.
      //
      if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

      for (; i < instructions.length; i++) {
        instruction = instructions[i];

        if (typeof instruction === 'function') {
          address = instruction(address);
          continue;
        }

        parse = instruction[0];
        key = instruction[1];

        if (parse !== parse) {
          url[key] = address;
        } else if ('string' === typeof parse) {
          if (~(index = address.indexOf(parse))) {
            if ('number' === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if ((index = parse.exec(address))) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }

        url[key] = url[key] || (
          relative && instruction[3] ? location[key] || '' : ''
        );

        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }

      //
      // Also parse the supplied query string in to an object. If we're supplied
      // with a custom parser as function use that instead of the default build-in
      // parser.
      //
      if (parser) url.query = parser(url.query);

      //
      // If the URL is relative, resolve the pathname against the base URL.
      //
      if (
          relative
        && location.slashes
        && url.pathname.charAt(0) !== '/'
        && (url.pathname !== '' || location.pathname !== '')
      ) {
        url.pathname = resolve(url.pathname, location.pathname);
      }

      //
      // We should not add port numbers if they are already the default port number
      // for a given protocol. As the host also contains the port number we're going
      // override it with the hostname which contains no port number.
      //
      if (!requiresPort(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
      }

      //
      // Parse down the `auth` for the username and password.
      //
      url.username = url.password = '';
      if (url.auth) {
        instruction = url.auth.split(':');
        url.username = instruction[0] || '';
        url.password = instruction[1] || '';
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      //
      // The href is just the compiled result.
      //
      url.href = url.toString();
    }

    /**
     * This is convenience method for changing properties in the URL instance to
     * insure that they all propagate correctly.
     *
     * @param {String} part          Property we need to adjust.
     * @param {Mixed} value          The newly assigned value.
     * @param {Boolean|Function} fn  When setting the query, it will be the function
     *                               used to parse the query.
     *                               When setting the protocol, double slash will be
     *                               removed from the final url if it is true.
     * @returns {URL} URL instance for chaining.
     * @public
     */
    function set(part, value, fn) {
      var url = this;

      switch (part) {
        case 'query':
          if ('string' === typeof value && value.length) {
            value = (fn || querystringify_1.parse)(value);
          }

          url[part] = value;
          break;

        case 'port':
          url[part] = value;

          if (!requiresPort(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = '';
          } else if (value) {
            url.host = url.hostname +':'+ value;
          }

          break;

        case 'hostname':
          url[part] = value;

          if (url.port) value += ':'+ url.port;
          url.host = value;
          break;

        case 'host':
          url[part] = value;

          if (/:\d+$/.test(value)) {
            value = value.split(':');
            url.port = value.pop();
            url.hostname = value.join(':');
          } else {
            url.hostname = value;
            url.port = '';
          }

          break;

        case 'protocol':
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;

        case 'pathname':
        case 'hash':
          if (value) {
            var char = part === 'pathname' ? '/' : '#';
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;

        default:
          url[part] = value;
      }

      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];

        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      url.href = url.toString();

      return url;
    }

    /**
     * Transform the properties back in to a valid and full URL string.
     *
     * @param {Function} stringify Optional query stringify function.
     * @returns {String} Compiled version of the URL.
     * @public
     */
    function toString$1(stringify) {
      if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

      var query
        , url = this
        , protocol = url.protocol;

      if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

      var result = protocol + (url.slashes ? '//' : '');

      if (url.username) {
        result += url.username;
        if (url.password) result += ':'+ url.password;
        result += '@';
      }

      result += url.host + url.pathname;

      query = 'object' === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

      if (url.hash) result += url.hash;

      return result;
    }

    Url.prototype = { set: set, toString: toString$1 };

    //
    // Expose the URL parser and some additional properties that might be useful for
    // others or testing.
    //
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = querystringify_1;

    var urlParse = Url;

    var isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative';

    var has$2 = Object.prototype.hasOwnProperty;
    var defaultOptions = { timeout: isReactNative ? 60000 : 120000 };

    var defaultOptionsProcessor = function (opts) {
      var options = typeof opts === 'string' ? objectAssign({ url: opts }, defaultOptions) : objectAssign({}, defaultOptions, opts);

      // Parse URL into parts
      var url = urlParse(options.url, {}, // Don't use current browser location
      true // Parse query strings
      );

      // Normalize timeouts
      options.timeout = normalizeTimeout(options.timeout);

      // Shallow-merge (override) existing query params
      if (options.query) {
        url.query = objectAssign({}, url.query, removeUndefined(options.query));
      }

      // Implicit POST if we have not specified a method but have a body
      options.method = options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase();

      // Stringify URL
      options.url = url.toString(stringifyQueryString);

      return options;
    };

    function stringifyQueryString(obj) {
      var pairs = [];
      for (var key in obj) {
        if (has$2.call(obj, key)) {
          push(key, obj[key]);
        }
      }

      return pairs.length ? pairs.join('&') : '';

      function push(key, val) {
        if (Array.isArray(val)) {
          val.forEach(function (item) {
            return push(key, item);
          });
        } else {
          pairs.push([key, val].map(encodeURIComponent).join('='));
        }
      }
    }

    function normalizeTimeout(time) {
      if (time === false || time === 0) {
        return false;
      }

      if (time.connect || time.socket) {
        return time;
      }

      var delay = Number(time);
      if (isNaN(delay)) {
        return normalizeTimeout(defaultOptions.timeout);
      }

      return { connect: delay, socket: delay };
    }

    function removeUndefined(obj) {
      var target = {};
      for (var key in obj) {
        if (obj[key] !== undefined) {
          target[key] = obj[key];
        }
      }
      return target;
    }

    var validUrl = /^https?:\/\//i;

    var defaultOptionsValidator = function (options) {
      if (!validUrl.test(options.url)) {
        throw new Error("\"" + options.url + "\" is not a valid URL");
      }
    };

    /**
     * This file is only used for the browser version of `same-origin`.
     * Used to bring down the size of the browser bundle.
     */

    var regex = /^(?:(?:(?:([^:\/#\?]+:)?(?:(?:\/\/)((?:((?:[^:@\/#\?]+)(?:\:(?:[^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((?:\/?(?:[^\/\?#]+\/+)*)(?:[^\?#]*)))?(\?[^#]+)?)(#.*)?/;

    var urlParser = {
        regex: regex,
        parse: function(url) {
            var match = regex.exec(url);
            if (!match) {
                return {};
            }

            return {
                protocol: (match[1] || '').toLowerCase() || undefined,
                hostname: (match[5] || '').toLowerCase() || undefined,
                port: match[6] || undefined
            };
        }
    };

    var sameOrigin = function(uri1, uri2, ieMode) {
        if (uri1 === uri2) {
            return true;
        }

        var url1 = urlParser.parse(uri1, false, true);
        var url2 = urlParser.parse(uri2, false, true);

        var url1Port = url1.port|0 || (url1.protocol === 'https' ? 443 : 80);
        var url2Port = url2.port|0 || (url2.protocol === 'https' ? 443 : 80);

        var match = {
            proto: url1.protocol === url2.protocol,
            hostname: url1.hostname === url2.hostname,
            port: url1Port === url2Port
        };

        return ((match.proto && match.hostname) && (match.port || ieMode));
    };

    /* eslint no-invalid-this: 1 */

    var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
    var slice$1 = Array.prototype.slice;
    var toStr$6 = Object.prototype.toString;
    var funcType = '[object Function]';

    var implementation$2 = function bind(that) {
        var target = this;
        if (typeof target !== 'function' || toStr$6.call(target) !== funcType) {
            throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice$1.call(arguments, 1);

        var bound;
        var binder = function () {
            if (this instanceof bound) {
                var result = target.apply(
                    this,
                    args.concat(slice$1.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;
            } else {
                return target.apply(
                    that,
                    args.concat(slice$1.call(arguments))
                );
            }
        };

        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

        if (target.prototype) {
            var Empty = function Empty() {};
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
        }

        return bound;
    };

    var functionBind = Function.prototype.bind || implementation$2;

    var toStr$5 = Object.prototype.toString;

    var isArguments = function isArguments(value) {
    	var str = toStr$5.call(value);
    	var isArgs = str === '[object Arguments]';
    	if (!isArgs) {
    		isArgs = str !== '[object Array]' &&
    			value !== null &&
    			typeof value === 'object' &&
    			typeof value.length === 'number' &&
    			value.length >= 0 &&
    			toStr$5.call(value.callee) === '[object Function]';
    	}
    	return isArgs;
    };

    var keysShim$1;
    if (!Object.keys) {
    	// modified from https://github.com/es-shims/es5-shim
    	var has$1 = Object.prototype.hasOwnProperty;
    	var toStr$4 = Object.prototype.toString;
    	var isArgs = isArguments; // eslint-disable-line global-require
    	var isEnumerable = Object.prototype.propertyIsEnumerable;
    	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
    	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
    	var dontEnums = [
    		'toString',
    		'toLocaleString',
    		'valueOf',
    		'hasOwnProperty',
    		'isPrototypeOf',
    		'propertyIsEnumerable',
    		'constructor'
    	];
    	var equalsConstructorPrototype = function (o) {
    		var ctor = o.constructor;
    		return ctor && ctor.prototype === o;
    	};
    	var excludedKeys = {
    		$applicationCache: true,
    		$console: true,
    		$external: true,
    		$frame: true,
    		$frameElement: true,
    		$frames: true,
    		$innerHeight: true,
    		$innerWidth: true,
    		$onmozfullscreenchange: true,
    		$onmozfullscreenerror: true,
    		$outerHeight: true,
    		$outerWidth: true,
    		$pageXOffset: true,
    		$pageYOffset: true,
    		$parent: true,
    		$scrollLeft: true,
    		$scrollTop: true,
    		$scrollX: true,
    		$scrollY: true,
    		$self: true,
    		$webkitIndexedDB: true,
    		$webkitStorageInfo: true,
    		$window: true
    	};
    	var hasAutomationEqualityBug = (function () {
    		/* global window */
    		if (typeof window === 'undefined') { return false; }
    		for (var k in window) {
    			try {
    				if (!excludedKeys['$' + k] && has$1.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
    					try {
    						equalsConstructorPrototype(window[k]);
    					} catch (e) {
    						return true;
    					}
    				}
    			} catch (e) {
    				return true;
    			}
    		}
    		return false;
    	}());
    	var equalsConstructorPrototypeIfNotBuggy = function (o) {
    		/* global window */
    		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
    			return equalsConstructorPrototype(o);
    		}
    		try {
    			return equalsConstructorPrototype(o);
    		} catch (e) {
    			return false;
    		}
    	};

    	keysShim$1 = function keys(object) {
    		var isObject = object !== null && typeof object === 'object';
    		var isFunction = toStr$4.call(object) === '[object Function]';
    		var isArguments = isArgs(object);
    		var isString = isObject && toStr$4.call(object) === '[object String]';
    		var theKeys = [];

    		if (!isObject && !isFunction && !isArguments) {
    			throw new TypeError('Object.keys called on a non-object');
    		}

    		var skipProto = hasProtoEnumBug && isFunction;
    		if (isString && object.length > 0 && !has$1.call(object, 0)) {
    			for (var i = 0; i < object.length; ++i) {
    				theKeys.push(String(i));
    			}
    		}

    		if (isArguments && object.length > 0) {
    			for (var j = 0; j < object.length; ++j) {
    				theKeys.push(String(j));
    			}
    		} else {
    			for (var name in object) {
    				if (!(skipProto && name === 'prototype') && has$1.call(object, name)) {
    					theKeys.push(String(name));
    				}
    			}
    		}

    		if (hasDontEnumBug) {
    			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

    			for (var k = 0; k < dontEnums.length; ++k) {
    				if (!(skipConstructor && dontEnums[k] === 'constructor') && has$1.call(object, dontEnums[k])) {
    					theKeys.push(dontEnums[k]);
    				}
    			}
    		}
    		return theKeys;
    	};
    }
    var implementation$1 = keysShim$1;

    var slice = Array.prototype.slice;


    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) { return origKeys(o); } : implementation$1;

    var originalKeys = Object.keys;

    keysShim.shim = function shimObjectKeys() {
    	if (Object.keys) {
    		var keysWorksWithArguments = (function () {
    			// Safari 5.0 bug
    			var args = Object.keys(arguments);
    			return args && args.length === arguments.length;
    		}(1, 2));
    		if (!keysWorksWithArguments) {
    			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
    				if (isArguments(object)) {
    					return originalKeys(slice.call(object));
    				}
    				return originalKeys(object);
    			};
    		}
    	} else {
    		Object.keys = keysShim;
    	}
    	return Object.keys || keysShim;
    };

    var objectKeys = keysShim;

    var hasSymbols$2 = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

    var toStr$3 = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;

    var isFunction = function (fn) {
    	return typeof fn === 'function' && toStr$3.call(fn) === '[object Function]';
    };

    var arePropertyDescriptorsSupported = function () {
    	var obj = {};
    	try {
    		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
    		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
    		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
    			return false;
    		}
    		return obj.x === obj;
    	} catch (e) { /* this is IE 8. */
    		return false;
    	}
    };
    var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

    var defineProperty$1 = function (object, name, value, predicate) {
    	if (name in object && (!isFunction(predicate) || !predicate())) {
    		return;
    	}
    	if (supportsDescriptors) {
    		origDefineProperty(object, name, {
    			configurable: true,
    			enumerable: false,
    			value: value,
    			writable: true
    		});
    	} else {
    		object[name] = value;
    	}
    };

    var defineProperties = function (object, map) {
    	var predicates = arguments.length > 2 ? arguments[2] : {};
    	var props = objectKeys(map);
    	if (hasSymbols$2) {
    		props = concat.call(props, Object.getOwnPropertySymbols(map));
    	}
    	for (var i = 0; i < props.length; i += 1) {
    		defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
    	}
    };

    defineProperties.supportsDescriptors = !!supportsDescriptors;

    var defineProperties_1 = defineProperties;

    /* eslint complexity: [2, 17], max-statements: [2, 33] */
    var shams = function hasSymbols() {
    	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
    	if (typeof Symbol.iterator === 'symbol') { return true; }

    	var obj = {};
    	var sym = Symbol('test');
    	var symObj = Object(sym);
    	if (typeof sym === 'string') { return false; }

    	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
    	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

    	// temp disabled per https://github.com/ljharb/object.assign/issues/17
    	// if (sym instanceof Symbol) { return false; }
    	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    	// if (!(symObj instanceof Symbol)) { return false; }

    	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
    	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    	var symVal = 42;
    	obj[sym] = symVal;
    	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
    	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

    	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

    	var syms = Object.getOwnPropertySymbols(obj);
    	if (syms.length !== 1 || syms[0] !== sym) { return false; }

    	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

    	if (typeof Object.getOwnPropertyDescriptor === 'function') {
    		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
    	}

    	return true;
    };

    var origSymbol = commonjsGlobal.Symbol;


    var hasSymbols$1 = function hasNativeSymbols() {
    	if (typeof origSymbol !== 'function') { return false; }
    	if (typeof Symbol !== 'function') { return false; }
    	if (typeof origSymbol('foo') !== 'symbol') { return false; }
    	if (typeof Symbol('bar') !== 'symbol') { return false; }

    	return shams();
    };

    /* globals
    	Atomics,
    	SharedArrayBuffer,
    */

    var undefined$1; // eslint-disable-line no-shadow-restricted-names

    var $TypeError$3 = TypeError;

    var ThrowTypeError = Object.getOwnPropertyDescriptor
    	? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())
    	: function () { throw new $TypeError$3(); };

    var hasSymbols = hasSymbols$1();

    var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto
    var generatorFunction = undefined$1;
    var asyncFunction = undefined$1;
    var asyncGenFunction = undefined$1;

    var TypedArray = typeof Uint8Array === 'undefined' ? undefined$1 : getProto(Uint8Array);

    var INTRINSICS = {
    	'$ %Array%': Array,
    	'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    	'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer.prototype,
    	'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
    	'$ %ArrayPrototype%': Array.prototype,
    	'$ %ArrayProto_entries%': Array.prototype.entries,
    	'$ %ArrayProto_forEach%': Array.prototype.forEach,
    	'$ %ArrayProto_keys%': Array.prototype.keys,
    	'$ %ArrayProto_values%': Array.prototype.values,
    	'$ %AsyncFromSyncIteratorPrototype%': undefined$1,
    	'$ %AsyncFunction%': asyncFunction,
    	'$ %AsyncFunctionPrototype%': undefined$1,
    	'$ %AsyncGenerator%': undefined$1,
    	'$ %AsyncGeneratorFunction%': asyncGenFunction,
    	'$ %AsyncGeneratorPrototype%': undefined$1,
    	'$ %AsyncIteratorPrototype%': undefined$1,
    	'$ %Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    	'$ %Boolean%': Boolean,
    	'$ %BooleanPrototype%': Boolean.prototype,
    	'$ %DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    	'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined$1 : DataView.prototype,
    	'$ %Date%': Date,
    	'$ %DatePrototype%': Date.prototype,
    	'$ %decodeURI%': decodeURI,
    	'$ %decodeURIComponent%': decodeURIComponent,
    	'$ %encodeURI%': encodeURI,
    	'$ %encodeURIComponent%': encodeURIComponent,
    	'$ %Error%': Error,
    	'$ %ErrorPrototype%': Error.prototype,
    	'$ %eval%': eval, // eslint-disable-line no-eval
    	'$ %EvalError%': EvalError,
    	'$ %EvalErrorPrototype%': EvalError.prototype,
    	'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    	'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array.prototype,
    	'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    	'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array.prototype,
    	'$ %Function%': Function,
    	'$ %FunctionPrototype%': Function.prototype,
    	'$ %Generator%': undefined$1,
    	'$ %GeneratorFunction%': generatorFunction,
    	'$ %GeneratorPrototype%': undefined$1,
    	'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    	'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array.prototype,
    	'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    	'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined$1 : Int8Array.prototype,
    	'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    	'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array.prototype,
    	'$ %isFinite%': isFinite,
    	'$ %isNaN%': isNaN,
    	'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    	'$ %JSON%': JSON,
    	'$ %JSONParse%': JSON.parse,
    	'$ %Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    	'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
    	'$ %MapPrototype%': typeof Map === 'undefined' ? undefined$1 : Map.prototype,
    	'$ %Math%': Math,
    	'$ %Number%': Number,
    	'$ %NumberPrototype%': Number.prototype,
    	'$ %Object%': Object,
    	'$ %ObjectPrototype%': Object.prototype,
    	'$ %ObjProto_toString%': Object.prototype.toString,
    	'$ %ObjProto_valueOf%': Object.prototype.valueOf,
    	'$ %parseFloat%': parseFloat,
    	'$ %parseInt%': parseInt,
    	'$ %Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    	'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype,
    	'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined$1 : Promise.prototype.then,
    	'$ %Promise_all%': typeof Promise === 'undefined' ? undefined$1 : Promise.all,
    	'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined$1 : Promise.reject,
    	'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined$1 : Promise.resolve,
    	'$ %Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    	'$ %RangeError%': RangeError,
    	'$ %RangeErrorPrototype%': RangeError.prototype,
    	'$ %ReferenceError%': ReferenceError,
    	'$ %ReferenceErrorPrototype%': ReferenceError.prototype,
    	'$ %Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    	'$ %RegExp%': RegExp,
    	'$ %RegExpPrototype%': RegExp.prototype,
    	'$ %Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    	'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
    	'$ %SetPrototype%': typeof Set === 'undefined' ? undefined$1 : Set.prototype,
    	'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    	'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer.prototype,
    	'$ %String%': String,
    	'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined$1,
    	'$ %StringPrototype%': String.prototype,
    	'$ %Symbol%': hasSymbols ? Symbol : undefined$1,
    	'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined$1,
    	'$ %SyntaxError%': SyntaxError,
    	'$ %SyntaxErrorPrototype%': SyntaxError.prototype,
    	'$ %ThrowTypeError%': ThrowTypeError,
    	'$ %TypedArray%': TypedArray,
    	'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined$1,
    	'$ %TypeError%': $TypeError$3,
    	'$ %TypeErrorPrototype%': $TypeError$3.prototype,
    	'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    	'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array.prototype,
    	'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    	'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray.prototype,
    	'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    	'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array.prototype,
    	'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    	'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array.prototype,
    	'$ %URIError%': URIError,
    	'$ %URIErrorPrototype%': URIError.prototype,
    	'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    	'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap.prototype,
    	'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet,
    	'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet.prototype
    };


    var $replace = functionBind.call(Function.call, String.prototype.replace);

    /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
    var rePropName$1 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar$1 = /\\(\\)?/g; /** Used to match backslashes in property paths. */
    var stringToPath$1 = function stringToPath(string) {
    	var result = [];
    	$replace(string, rePropName$1, function (match, number, quote, subString) {
    		result[result.length] = quote ? $replace(subString, reEscapeChar$1, '$1') : (number || match);
    	});
    	return result;
    };
    /* end adaptation */

    var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    	var key = '$ ' + name;
    	if (!(key in INTRINSICS)) {
    		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
    	}

    	// istanbul ignore if // hopefully this is impossible to test :-)
    	if (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {
    		throw new $TypeError$3('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    	}

    	return INTRINSICS[key];
    };

    var GetIntrinsic = function GetIntrinsic(name, allowMissing) {
    	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    		throw new TypeError('"allowMissing" argument must be a boolean');
    	}

    	var parts = stringToPath$1(name);

    	if (parts.length === 0) {
    		return getBaseIntrinsic(name, allowMissing);
    	}

    	var value = getBaseIntrinsic('%' + parts[0] + '%', allowMissing);
    	for (var i = 1; i < parts.length; i += 1) {
    		if (value != null) {
    			value = value[parts[i]];
    		}
    	}
    	return value;
    };

    var src = functionBind.call(Function.call, Object.prototype.hasOwnProperty);

    var $TypeError$2 = GetIntrinsic('%TypeError%');
    var $SyntaxError = GetIntrinsic('%SyntaxError%');



    var predicates = {
    	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
    	'Property Descriptor': function isPropertyDescriptor(ES, Desc) {
    		if (ES.Type(Desc) !== 'Object') {
    			return false;
    		}
    		var allowed = {
    			'[[Configurable]]': true,
    			'[[Enumerable]]': true,
    			'[[Get]]': true,
    			'[[Set]]': true,
    			'[[Value]]': true,
    			'[[Writable]]': true
    		};

    		for (var key in Desc) { // eslint-disable-line
    			if (src(Desc, key) && !allowed[key]) {
    				return false;
    			}
    		}

    		var isData = src(Desc, '[[Value]]');
    		var IsAccessor = src(Desc, '[[Get]]') || src(Desc, '[[Set]]');
    		if (isData && IsAccessor) {
    			throw new $TypeError$2('Property Descriptors may not be both accessor and data descriptors');
    		}
    		return true;
    	}
    };

    var assertRecord = function assertRecord(ES, recordType, argumentName, value) {
    	var predicate = predicates[recordType];
    	if (typeof predicate !== 'function') {
    		throw new $SyntaxError('unknown record type: ' + recordType);
    	}
    	if (!predicate(ES, value)) {
    		throw new $TypeError$2(argumentName + ' must be a ' + recordType);
    	}
    };

    var $TypeError$1 = GetIntrinsic('%TypeError%');

    var isPropertyDescriptor = function IsPropertyDescriptor(ES, Desc) {
    	if (ES.Type(Desc) !== 'Object') {
    		return false;
    	}
    	var allowed = {
    		'[[Configurable]]': true,
    		'[[Enumerable]]': true,
    		'[[Get]]': true,
    		'[[Set]]': true,
    		'[[Value]]': true,
    		'[[Writable]]': true
    	};

        for (var key in Desc) { // eslint-disable-line
    		if (src(Desc, key) && !allowed[key]) {
    			return false;
    		}
    	}

    	if (ES.IsDataDescriptor(Desc) && ES.IsAccessorDescriptor(Desc)) {
    		throw new $TypeError$1('Property Descriptors may not be both accessor and data descriptors');
    	}
    	return true;
    };

    var _isNaN = Number.isNaN || function isNaN(a) {
    	return a !== a;
    };

    var $isNaN = Number.isNaN || function (a) { return a !== a; };

    var _isFinite = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

    var sign = function sign(number) {
    	return number >= 0 ? 1 : -1;
    };

    var mod = function mod(number, modulo) {
    	var remain = number % modulo;
    	return Math.floor(remain >= 0 ? remain : remain + modulo);
    };

    var $Function = GetIntrinsic('%Function%');
    var $apply = $Function.apply;
    var $call = $Function.call;

    var callBind = function callBind() {
    	return functionBind.apply($call, arguments);
    };

    var apply$1 = function applyBind() {
    	return functionBind.apply($apply, arguments);
    };
    callBind.apply = apply$1;

    var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

    var callBound = function callBoundIntrinsic(name, allowMissing) {
    	var intrinsic = GetIntrinsic(name, !!allowMissing);
    	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
    		return callBind(intrinsic);
    	}
    	return intrinsic;
    };

    var $strSlice = callBound('String.prototype.slice');

    var isPrefixOf = function isPrefixOf(prefix, string) {
    	if (prefix === string) {
    		return true;
    	}
    	if (prefix.length > string.length) {
    		return false;
    	}
    	return $strSlice(string, 0, prefix.length) === prefix;
    };

    var fnToStr = Function.prototype.toString;

    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
    	try {
    		var fnStr = fnToStr.call(value);
    		return constructorRegex.test(fnStr);
    	} catch (e) {
    		return false; // not a function
    	}
    };

    var tryFunctionObject = function tryFunctionToStr(value) {
    	try {
    		if (isES6ClassFn(value)) { return false; }
    		fnToStr.call(value);
    		return true;
    	} catch (e) {
    		return false;
    	}
    };
    var toStr$2 = Object.prototype.toString;
    var fnClass = '[object Function]';
    var genClass = '[object GeneratorFunction]';
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

    var isCallable = function isCallable(value) {
    	if (!value) { return false; }
    	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
    	if (typeof value === 'function' && !value.prototype) { return true; }
    	if (hasToStringTag) { return tryFunctionObject(value); }
    	if (isES6ClassFn(value)) { return false; }
    	var strClass = toStr$2.call(value);
    	return strClass === fnClass || strClass === genClass;
    };

    var isPrimitive = function isPrimitive(value) {
    	return value === null || (typeof value !== 'function' && typeof value !== 'object');
    };

    var toStr$1 = Object.prototype.toString;





    // http://ecma-international.org/ecma-262/5.1/#sec-8.12.8
    var ES5internalSlots = {
    	'[[DefaultValue]]': function (O) {
    		var actualHint;
    		if (arguments.length > 1) {
    			actualHint = arguments[1];
    		} else {
    			actualHint = toStr$1.call(O) === '[object Date]' ? String : Number;
    		}

    		if (actualHint === String || actualHint === Number) {
    			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
    			var value, i;
    			for (i = 0; i < methods.length; ++i) {
    				if (isCallable(O[methods[i]])) {
    					value = O[methods[i]]();
    					if (isPrimitive(value)) {
    						return value;
    					}
    				}
    			}
    			throw new TypeError('No default value');
    		}
    		throw new TypeError('invalid [[DefaultValue]] hint supplied');
    	}
    };

    // http://ecma-international.org/ecma-262/5.1/#sec-9.1
    var es5$1 = function ToPrimitive(input) {
    	if (isPrimitive(input)) {
    		return input;
    	}
    	if (arguments.length > 1) {
    		return ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);
    	}
    	return ES5internalSlots['[[DefaultValue]]'](input);
    };

    var $Object = GetIntrinsic('%Object%');
    var $EvalError = GetIntrinsic('%EvalError%');
    var $TypeError = GetIntrinsic('%TypeError%');
    var $String = GetIntrinsic('%String%');
    var $Date = GetIntrinsic('%Date%');
    var $Number = GetIntrinsic('%Number%');
    var $floor = GetIntrinsic('%Math.floor%');
    var $DateUTC = GetIntrinsic('%Date.UTC%');
    var $abs = GetIntrinsic('%Math.abs%');















    var $getUTCFullYear = callBound('Date.prototype.getUTCFullYear');

    var HoursPerDay = 24;
    var MinutesPerHour = 60;
    var SecondsPerMinute = 60;
    var msPerSecond = 1e3;
    var msPerMinute = msPerSecond * SecondsPerMinute;
    var msPerHour = msPerMinute * MinutesPerHour;
    var msPerDay = 86400000;

    // https://es5.github.io/#x9
    var ES5 = {
    	ToPrimitive: es5$1,

    	ToBoolean: function ToBoolean(value) {
    		return !!value;
    	},
    	ToNumber: function ToNumber(value) {
    		return +value; // eslint-disable-line no-implicit-coercion
    	},
    	ToInteger: function ToInteger(value) {
    		var number = this.ToNumber(value);
    		if (_isNaN(number)) { return 0; }
    		if (number === 0 || !_isFinite(number)) { return number; }
    		return sign(number) * Math.floor(Math.abs(number));
    	},
    	ToInt32: function ToInt32(x) {
    		return this.ToNumber(x) >> 0;
    	},
    	ToUint32: function ToUint32(x) {
    		return this.ToNumber(x) >>> 0;
    	},
    	ToUint16: function ToUint16(value) {
    		var number = this.ToNumber(value);
    		if (_isNaN(number) || number === 0 || !_isFinite(number)) { return 0; }
    		var posInt = sign(number) * Math.floor(Math.abs(number));
    		return mod(posInt, 0x10000);
    	},
    	ToString: function ToString(value) {
    		return $String(value);
    	},
    	ToObject: function ToObject(value) {
    		this.CheckObjectCoercible(value);
    		return $Object(value);
    	},
    	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
    		/* jshint eqnull:true */
    		if (value == null) {
    			throw new $TypeError(optMessage || 'Cannot call method on ' + value);
    		}
    		return value;
    	},
    	IsCallable: isCallable,
    	SameValue: function SameValue(x, y) {
    		if (x === y) { // 0 === -0, but they are not identical.
    			if (x === 0) { return 1 / x === 1 / y; }
    			return true;
    		}
    		return _isNaN(x) && _isNaN(y);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-8
    	Type: function Type(x) {
    		if (x === null) {
    			return 'Null';
    		}
    		if (typeof x === 'undefined') {
    			return 'Undefined';
    		}
    		if (typeof x === 'function' || typeof x === 'object') {
    			return 'Object';
    		}
    		if (typeof x === 'number') {
    			return 'Number';
    		}
    		if (typeof x === 'boolean') {
    			return 'Boolean';
    		}
    		if (typeof x === 'string') {
    			return 'String';
    		}
    	},

    	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
    	IsPropertyDescriptor: function IsPropertyDescriptor(Desc) {
    		return isPropertyDescriptor(this, Desc);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1
    	IsAccessorDescriptor: function IsAccessorDescriptor(Desc) {
    		if (typeof Desc === 'undefined') {
    			return false;
    		}

    		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

    		if (!src(Desc, '[[Get]]') && !src(Desc, '[[Set]]')) {
    			return false;
    		}

    		return true;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2
    	IsDataDescriptor: function IsDataDescriptor(Desc) {
    		if (typeof Desc === 'undefined') {
    			return false;
    		}

    		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

    		if (!src(Desc, '[[Value]]') && !src(Desc, '[[Writable]]')) {
    			return false;
    		}

    		return true;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3
    	IsGenericDescriptor: function IsGenericDescriptor(Desc) {
    		if (typeof Desc === 'undefined') {
    			return false;
    		}

    		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

    		if (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {
    			return true;
    		}

    		return false;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4
    	FromPropertyDescriptor: function FromPropertyDescriptor(Desc) {
    		if (typeof Desc === 'undefined') {
    			return Desc;
    		}

    		assertRecord(this, 'Property Descriptor', 'Desc', Desc);

    		if (this.IsDataDescriptor(Desc)) {
    			return {
    				value: Desc['[[Value]]'],
    				writable: !!Desc['[[Writable]]'],
    				enumerable: !!Desc['[[Enumerable]]'],
    				configurable: !!Desc['[[Configurable]]']
    			};
    		} else if (this.IsAccessorDescriptor(Desc)) {
    			return {
    				get: Desc['[[Get]]'],
    				set: Desc['[[Set]]'],
    				enumerable: !!Desc['[[Enumerable]]'],
    				configurable: !!Desc['[[Configurable]]']
    			};
    		} else {
    			throw new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');
    		}
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5
    	ToPropertyDescriptor: function ToPropertyDescriptor(Obj) {
    		if (this.Type(Obj) !== 'Object') {
    			throw new $TypeError('ToPropertyDescriptor requires an object');
    		}

    		var desc = {};
    		if (src(Obj, 'enumerable')) {
    			desc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);
    		}
    		if (src(Obj, 'configurable')) {
    			desc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);
    		}
    		if (src(Obj, 'value')) {
    			desc['[[Value]]'] = Obj.value;
    		}
    		if (src(Obj, 'writable')) {
    			desc['[[Writable]]'] = this.ToBoolean(Obj.writable);
    		}
    		if (src(Obj, 'get')) {
    			var getter = Obj.get;
    			if (typeof getter !== 'undefined' && !this.IsCallable(getter)) {
    				throw new TypeError('getter must be a function');
    			}
    			desc['[[Get]]'] = getter;
    		}
    		if (src(Obj, 'set')) {
    			var setter = Obj.set;
    			if (typeof setter !== 'undefined' && !this.IsCallable(setter)) {
    				throw new $TypeError('setter must be a function');
    			}
    			desc['[[Set]]'] = setter;
    		}

    		if ((src(desc, '[[Get]]') || src(desc, '[[Set]]')) && (src(desc, '[[Value]]') || src(desc, '[[Writable]]'))) {
    			throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
    		}
    		return desc;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-11.9.3
    	'Abstract Equality Comparison': function AbstractEqualityComparison(x, y) {
    		var xType = this.Type(x);
    		var yType = this.Type(y);
    		if (xType === yType) {
    			return x === y; // ES6+ specified this shortcut anyways.
    		}
    		if (x == null && y == null) {
    			return true;
    		}
    		if (xType === 'Number' && yType === 'String') {
    			return this['Abstract Equality Comparison'](x, this.ToNumber(y));
    		}
    		if (xType === 'String' && yType === 'Number') {
    			return this['Abstract Equality Comparison'](this.ToNumber(x), y);
    		}
    		if (xType === 'Boolean') {
    			return this['Abstract Equality Comparison'](this.ToNumber(x), y);
    		}
    		if (yType === 'Boolean') {
    			return this['Abstract Equality Comparison'](x, this.ToNumber(y));
    		}
    		if ((xType === 'String' || xType === 'Number') && yType === 'Object') {
    			return this['Abstract Equality Comparison'](x, this.ToPrimitive(y));
    		}
    		if (xType === 'Object' && (yType === 'String' || yType === 'Number')) {
    			return this['Abstract Equality Comparison'](this.ToPrimitive(x), y);
    		}
    		return false;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-11.9.6
    	'Strict Equality Comparison': function StrictEqualityComparison(x, y) {
    		var xType = this.Type(x);
    		var yType = this.Type(y);
    		if (xType !== yType) {
    			return false;
    		}
    		if (xType === 'Undefined' || xType === 'Null') {
    			return true;
    		}
    		return x === y; // shortcut for steps 4-7
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-11.8.5
    	// eslint-disable-next-line max-statements
    	'Abstract Relational Comparison': function AbstractRelationalComparison(x, y, LeftFirst) {
    		if (this.Type(LeftFirst) !== 'Boolean') {
    			throw new $TypeError('Assertion failed: LeftFirst argument must be a Boolean');
    		}
    		var px;
    		var py;
    		if (LeftFirst) {
    			px = this.ToPrimitive(x, $Number);
    			py = this.ToPrimitive(y, $Number);
    		} else {
    			py = this.ToPrimitive(y, $Number);
    			px = this.ToPrimitive(x, $Number);
    		}
    		var bothStrings = this.Type(px) === 'String' && this.Type(py) === 'String';
    		if (!bothStrings) {
    			var nx = this.ToNumber(px);
    			var ny = this.ToNumber(py);
    			if (_isNaN(nx) || _isNaN(ny)) {
    				return undefined;
    			}
    			if (_isFinite(nx) && _isFinite(ny) && nx === ny) {
    				return false;
    			}
    			if (nx === 0 && ny === 0) {
    				return false;
    			}
    			if (nx === Infinity) {
    				return false;
    			}
    			if (ny === Infinity) {
    				return true;
    			}
    			if (ny === -Infinity) {
    				return false;
    			}
    			if (nx === -Infinity) {
    				return true;
    			}
    			return nx < ny; // by now, these are both nonzero, finite, and not equal
    		}
    		if (isPrefixOf(py, px)) {
    			return false;
    		}
    		if (isPrefixOf(px, py)) {
    			return true;
    		}
    		return px < py; // both strings, neither a prefix of the other. shortcut for steps c-f
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10
    	msFromTime: function msFromTime(t) {
    		return mod(t, msPerSecond);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10
    	SecFromTime: function SecFromTime(t) {
    		return mod($floor(t / msPerSecond), SecondsPerMinute);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10
    	MinFromTime: function MinFromTime(t) {
    		return mod($floor(t / msPerMinute), MinutesPerHour);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.10
    	HourFromTime: function HourFromTime(t) {
    		return mod($floor(t / msPerHour), HoursPerDay);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.2
    	Day: function Day(t) {
    		return $floor(t / msPerDay);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.2
    	TimeWithinDay: function TimeWithinDay(t) {
    		return mod(t, msPerDay);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3
    	DayFromYear: function DayFromYear(y) {
    		return (365 * (y - 1970)) + $floor((y - 1969) / 4) - $floor((y - 1901) / 100) + $floor((y - 1601) / 400);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3
    	TimeFromYear: function TimeFromYear(y) {
    		return msPerDay * this.DayFromYear(y);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3
    	YearFromTime: function YearFromTime(t) {
    		// largest y such that this.TimeFromYear(y) <= t
    		return $getUTCFullYear(new $Date(t));
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.6
    	WeekDay: function WeekDay(t) {
    		return mod(this.Day(t) + 4, 7);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3
    	DaysInYear: function DaysInYear(y) {
    		if (mod(y, 4) !== 0) {
    			return 365;
    		}
    		if (mod(y, 100) !== 0) {
    			return 366;
    		}
    		if (mod(y, 400) !== 0) {
    			return 365;
    		}
    		return 366;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.3
    	InLeapYear: function InLeapYear(t) {
    		var days = this.DaysInYear(this.YearFromTime(t));
    		if (days === 365) {
    			return 0;
    		}
    		if (days === 366) {
    			return 1;
    		}
    		throw new $EvalError('Assertion failed: there are not 365 or 366 days in a year, got: ' + days);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.4
    	DayWithinYear: function DayWithinYear(t) {
    		return this.Day(t) - this.DayFromYear(this.YearFromTime(t));
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.4
    	MonthFromTime: function MonthFromTime(t) {
    		var day = this.DayWithinYear(t);
    		if (0 <= day && day < 31) {
    			return 0;
    		}
    		var leap = this.InLeapYear(t);
    		if (31 <= day && day < (59 + leap)) {
    			return 1;
    		}
    		if ((59 + leap) <= day && day < (90 + leap)) {
    			return 2;
    		}
    		if ((90 + leap) <= day && day < (120 + leap)) {
    			return 3;
    		}
    		if ((120 + leap) <= day && day < (151 + leap)) {
    			return 4;
    		}
    		if ((151 + leap) <= day && day < (181 + leap)) {
    			return 5;
    		}
    		if ((181 + leap) <= day && day < (212 + leap)) {
    			return 6;
    		}
    		if ((212 + leap) <= day && day < (243 + leap)) {
    			return 7;
    		}
    		if ((243 + leap) <= day && day < (273 + leap)) {
    			return 8;
    		}
    		if ((273 + leap) <= day && day < (304 + leap)) {
    			return 9;
    		}
    		if ((304 + leap) <= day && day < (334 + leap)) {
    			return 10;
    		}
    		if ((334 + leap) <= day && day < (365 + leap)) {
    			return 11;
    		}
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.5
    	DateFromTime: function DateFromTime(t) {
    		var m = this.MonthFromTime(t);
    		var d = this.DayWithinYear(t);
    		if (m === 0) {
    			return d + 1;
    		}
    		if (m === 1) {
    			return d - 30;
    		}
    		var leap = this.InLeapYear(t);
    		if (m === 2) {
    			return d - 58 - leap;
    		}
    		if (m === 3) {
    			return d - 89 - leap;
    		}
    		if (m === 4) {
    			return d - 119 - leap;
    		}
    		if (m === 5) {
    			return d - 150 - leap;
    		}
    		if (m === 6) {
    			return d - 180 - leap;
    		}
    		if (m === 7) {
    			return d - 211 - leap;
    		}
    		if (m === 8) {
    			return d - 242 - leap;
    		}
    		if (m === 9) {
    			return d - 272 - leap;
    		}
    		if (m === 10) {
    			return d - 303 - leap;
    		}
    		if (m === 11) {
    			return d - 333 - leap;
    		}
    		throw new $EvalError('Assertion failed: MonthFromTime returned an impossible value: ' + m);
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.12
    	MakeDay: function MakeDay(year, month, date) {
    		if (!_isFinite(year) || !_isFinite(month) || !_isFinite(date)) {
    			return NaN;
    		}
    		var y = this.ToInteger(year);
    		var m = this.ToInteger(month);
    		var dt = this.ToInteger(date);
    		var ym = y + $floor(m / 12);
    		var mn = mod(m, 12);
    		var t = $DateUTC(ym, mn, 1);
    		if (this.YearFromTime(t) !== ym || this.MonthFromTime(t) !== mn || this.DateFromTime(t) !== 1) {
    			return NaN;
    		}
    		return this.Day(t) + dt - 1;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.13
    	MakeDate: function MakeDate(day, time) {
    		if (!_isFinite(day) || !_isFinite(time)) {
    			return NaN;
    		}
    		return (day * msPerDay) + time;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.11
    	MakeTime: function MakeTime(hour, min, sec, ms) {
    		if (!_isFinite(hour) || !_isFinite(min) || !_isFinite(sec) || !_isFinite(ms)) {
    			return NaN;
    		}
    		var h = this.ToInteger(hour);
    		var m = this.ToInteger(min);
    		var s = this.ToInteger(sec);
    		var milli = this.ToInteger(ms);
    		var t = (h * msPerHour) + (m * msPerMinute) + (s * msPerSecond) + milli;
    		return t;
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-15.9.1.14
    	TimeClip: function TimeClip(time) {
    		if (!_isFinite(time) || $abs(time) > 8.64e15) {
    			return NaN;
    		}
    		return $Number(new $Date(this.ToNumber(time)));
    	},

    	// https://ecma-international.org/ecma-262/5.1/#sec-5.2
    	modulo: function modulo(x, y) {
    		return mod(x, y);
    	}
    };

    var es5 = ES5;

    var replace = functionBind.call(Function.call, String.prototype.replace);

    /* eslint-disable no-control-regex */
    var leftWhitespace = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
    var rightWhitespace = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
    /* eslint-enable no-control-regex */

    var implementation = function trim() {
    	var S = es5.ToString(es5.CheckObjectCoercible(this));
    	return replace(replace(S, leftWhitespace, ''), rightWhitespace, '');
    };

    var zeroWidthSpace = '\u200b';

    var polyfill = function getPolyfill() {
    	if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {
    		return String.prototype.trim;
    	}
    	return implementation;
    };

    var shim = function shimStringTrim() {
    	var polyfill$1 = polyfill();
    	defineProperties_1(String.prototype, { trim: polyfill$1 }, {
    		trim: function testTrim() {
    			return String.prototype.trim !== polyfill$1;
    		}
    	});
    	return polyfill$1;
    };

    var boundTrim = functionBind.call(Function.call, polyfill());

    defineProperties_1(boundTrim, {
    	getPolyfill: polyfill,
    	implementation: implementation,
    	shim: shim
    });

    var string_prototype_trim = boundTrim;

    var toStr = Object.prototype.toString;
    var hasOwnProperty$6 = Object.prototype.hasOwnProperty;

    var forEachArray = function forEachArray(array, iterator, receiver) {
        for (var i = 0, len = array.length; i < len; i++) {
            if (hasOwnProperty$6.call(array, i)) {
                if (receiver == null) {
                    iterator(array[i], i, array);
                } else {
                    iterator.call(receiver, array[i], i, array);
                }
            }
        }
    };

    var forEachString = function forEachString(string, iterator, receiver) {
        for (var i = 0, len = string.length; i < len; i++) {
            // no such thing as a sparse string.
            if (receiver == null) {
                iterator(string.charAt(i), i, string);
            } else {
                iterator.call(receiver, string.charAt(i), i, string);
            }
        }
    };

    var forEachObject = function forEachObject(object, iterator, receiver) {
        for (var k in object) {
            if (hasOwnProperty$6.call(object, k)) {
                if (receiver == null) {
                    iterator(object[k], k, object);
                } else {
                    iterator.call(receiver, object[k], k, object);
                }
            }
        }
    };

    var forEach = function forEach(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
            throw new TypeError('iterator must be a function');
        }

        var receiver;
        if (arguments.length >= 3) {
            receiver = thisArg;
        }

        if (toStr.call(list) === '[object Array]') {
            forEachArray(list, iterator, receiver);
        } else if (typeof list === 'string') {
            forEachString(list, iterator, receiver);
        } else {
            forEachObject(list, iterator, receiver);
        }
    };

    var forEach_1 = forEach;

    var isArray = function(arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };

    var parseHeaders = function (headers) {
      if (!headers)
        return {}

      var result = {};

      forEach_1(
          string_prototype_trim(headers).split('\n')
        , function (row) {
            var index = row.indexOf(':')
              , key = string_prototype_trim(row.slice(0, index)).toLowerCase()
              , value = string_prototype_trim(row.slice(index + 1));

            if (typeof(result[key]) === 'undefined') {
              result[key] = value;
            } else if (isArray(result[key])) {
              result[key].push(value);
            } else {
              result[key] = [ result[key], value ];
            }
          }
      );

      return result
    };

    /* eslint max-depth: ["error", 4] */


    var noop = function noop() {
      /* intentional noop */
    };

    var win = window;
    var XmlHttpRequest = win.XMLHttpRequest || noop;
    var hasXhr2 = 'withCredentials' in new XmlHttpRequest();
    var XDomainRequest$1 = hasXhr2 ? XmlHttpRequest : win.XDomainRequest;
    var adapter = 'xhr';

    var browserRequest = function (context, callback) {
      var opts = context.options;
      var options = context.applyMiddleware('finalizeOptions', opts);
      var timers = {};

      // Deep-checking window.location because of react native, where `location` doesn't exist
      var cors = win && win.location && !sameOrigin(win.location.href, options.url);

      // Allow middleware to inject a response, for instance in the case of caching or mocking
      var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {
        adapter: adapter,
        context: context
      });

      // If middleware injected a response, treat it as we normally would and return it
      // Do note that the injected response has to be reduced to a cross-environment friendly response
      if (injectedResponse) {
        var cbTimer = setTimeout(callback, 0, null, injectedResponse);
        var cancel = function cancel() {
          return clearTimeout(cbTimer);
        };
        return { abort: cancel };
      }

      // We'll want to null out the request on success/failure
      var xhr = cors ? new XDomainRequest$1() : new XmlHttpRequest();

      var isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest;
      var headers = options.headers;

      // Request state
      var aborted = false;
      var loaded = false;
      var timedOut = false;

      // Apply event handlers
      xhr.onerror = onError;
      xhr.ontimeout = onError;
      xhr.onabort = function () {
        aborted = true;
      };

      // IE9 must have onprogress be set to a unique function
      xhr.onprogress = function () {
        /* intentional noop */
      };

      var loadEvent = isXdr ? 'onload' : 'onreadystatechange';
      xhr[loadEvent] = function () {
        // Prevent request from timing out
        resetTimers();

        if (aborted || xhr.readyState !== 4 && !isXdr) {
          return;
        }

        // Will be handled by onError
        if (xhr.status === 0) {
          return;
        }

        onLoad();
      };

      // @todo two last options to open() is username/password
      xhr.open(options.method, options.url, true // Always async
      );

      // Some options need to be applied after open
      xhr.withCredentials = !!options.withCredentials;

      // Set headers
      if (headers && xhr.setRequestHeader) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (headers && isXdr) {
        throw new Error('Headers cannot be set on an XDomainRequest object');
      }

      if (options.rawBody) {
        xhr.responseType = 'arraybuffer';
      }

      // Let middleware know we're about to do a request
      context.applyMiddleware('onRequest', { options: options, adapter: adapter, request: xhr, context: context });

      xhr.send(options.body || null);

      // Figure out which timeouts to use (if any)
      var delays = options.timeout;
      if (delays) {
        timers.connect = setTimeout(function () {
          return timeoutRequest('ETIMEDOUT');
        }, delays.connect);
      }

      return { abort: abort };

      function abort() {
        aborted = true;

        if (xhr) {
          xhr.abort();
        }
      }

      function timeoutRequest(code) {
        timedOut = true;
        xhr.abort();
        var error = new Error(code === 'ESOCKETTIMEDOUT' ? 'Socket timed out on request to ' + options.url : 'Connection timed out on request to ' + options.url);
        error.code = code;
        context.channels.error.publish(error);
      }

      function resetTimers() {
        if (!delays) {
          return;
        }

        stopTimers();
        timers.socket = setTimeout(function () {
          return timeoutRequest('ESOCKETTIMEDOUT');
        }, delays.socket);
      }

      function stopTimers() {
        // Only clear the connect timeout if we've got a connection
        if (aborted || xhr.readyState >= 2 && timers.connect) {
          clearTimeout(timers.connect);
        }

        if (timers.socket) {
          clearTimeout(timers.socket);
        }
      }

      function onError() {
        if (loaded) {
          return;
        }

        // Clean up
        stopTimers();
        loaded = true;
        xhr = null;

        // Annoyingly, details are extremely scarce and hidden from us.
        // We only really know that it is a network error
        var err = new Error('Network error while attempting to reach ' + options.url);
        err.isNetworkError = true;
        err.request = options;
        callback(err);
      }

      function reduceResponse() {
        var statusCode = xhr.status;
        var statusMessage = xhr.statusText;

        if (isXdr && statusCode === undefined) {
          // IE8 CORS GET successful response doesn't have a status field, but body is fine
          statusCode = 200;
        } else if (statusCode > 12000 && statusCode < 12156) {
          // Yet another IE quirk where it emits weird status codes on network errors
          // https://support.microsoft.com/en-us/kb/193625
          return onError();
        } else {
          // Another IE bug where HTTP 204 somehow ends up as 1223
          statusCode = xhr.status === 1223 ? 204 : xhr.status;
          statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;
        }

        return {
          body: xhr.response || xhr.responseText,
          url: options.url,
          method: options.method,
          headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),
          statusCode: statusCode,
          statusMessage: statusMessage
        };
      }

      function onLoad() {
        if (aborted || loaded || timedOut) {
          return;
        }

        if (xhr.status === 0) {
          onError();
          return;
        }

        // Prevent being called twice
        stopTimers();
        loaded = true;
        callback(null, reduceResponse());
      }
    };

    var request$1 = browserRequest;

    // node-request in node, browser-request in browsers

    var channelNames = ['request', 'response', 'progress', 'error', 'abort'];
    var middlehooks = ['processOptions', 'validateOptions', 'interceptRequest', 'finalizeOptions', 'onRequest', 'onResponse', 'onError', 'onReturn', 'onHeaders'];

    var lib$1 = function createRequester() {
      var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var loadedMiddleware = [];
      var middleware = middlehooks.reduce(function (ware, name) {
        ware[name] = ware[name] || [];
        return ware;
      }, {
        processOptions: [defaultOptionsProcessor],
        validateOptions: [defaultOptionsValidator]
      });

      function request(opts) {
        var channels = channelNames.reduce(function (target, name) {
          target[name] = nanoPubsub();
          return target;
        }, {});

        // Prepare a middleware reducer that can be reused throughout the lifecycle
        var applyMiddleware = middlewareReducer(middleware);

        // Parse the passed options
        var options = applyMiddleware('processOptions', opts);

        // Validate the options
        applyMiddleware('validateOptions', options);

        // Build a context object we can pass to child handlers
        var context = { options: options, channels: channels, applyMiddleware: applyMiddleware

          // We need to hold a reference to the current, ongoing request,
          // in order to allow cancellation. In the case of the retry middleware,
          // a new request might be triggered
        };var ongoingRequest = null;
        var unsubscribe = channels.request.subscribe(function (ctx) {
          // Let request adapters (node/browser) perform the actual request
          ongoingRequest = request$1(ctx, function (err, res) {
            return onResponse(err, res, ctx);
          });
        });

        // If we abort the request, prevent further requests from happening,
        // and be sure to cancel any ongoing request (obviously)
        channels.abort.subscribe(function () {
          unsubscribe();
          if (ongoingRequest) {
            ongoingRequest.abort();
          }
        });

        // See if any middleware wants to modify the return value - for instance
        // the promise or observable middlewares
        var returnValue = applyMiddleware('onReturn', channels, context);

        // If return value has been modified by a middleware, we expect the middleware
        // to publish on the 'request' channel. If it hasn't been modified, we want to
        // trigger it right away
        if (returnValue === channels) {
          channels.request.publish(context);
        }

        return returnValue;

        function onResponse(reqErr, res, ctx) {
          var error = reqErr;
          var response = res;

          // We're processing non-errors first, in case a middleware converts the
          // response into an error (for instance, status >= 400 == HttpError)
          if (!error) {
            try {
              response = applyMiddleware('onResponse', res, ctx);
            } catch (err) {
              response = null;
              error = err;
            }
          }

          // Apply error middleware - if middleware return the same (or a different) error,
          // publish as an error event. If we *don't* return an error, assume it has been handled
          error = error && applyMiddleware('onError', error, ctx);

          // Figure out if we should publish on error/response channels
          if (error) {
            channels.error.publish(error);
          } else if (response) {
            channels.response.publish(response);
          }
        }
      }

      request.use = function use(newMiddleware) {
        if (!newMiddleware) {
          throw new Error('Tried to add middleware that resolved to falsey value');
        }

        if (typeof newMiddleware === 'function') {
          throw new Error('Tried to add middleware that was a function. It probably expects you to pass options to it.');
        }

        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
          throw new Error('Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event');
        }

        middlehooks.forEach(function (key) {
          if (newMiddleware[key]) {
            middleware[key].push(newMiddleware[key]);
          }
        });

        loadedMiddleware.push(newMiddleware);
        return request;
      };

      request.clone = function clone() {
        return createRequester(loadedMiddleware);
      };

      initMiddleware.forEach(request.use);

      return request;
    };

    var getIt = lib$1;

    var global_1 = createCommonjsModule(function (module) {

    /* eslint-disable no-negated-condition */
    if (typeof window !== 'undefined') {
      module.exports = window;
    } else if (typeof commonjsGlobal !== 'undefined') {
      module.exports = commonjsGlobal;
    } else if (typeof self !== 'undefined') {
      module.exports = self;
    } else {
      module.exports = {};
    }
    //# sourceMappingURL=global.js.map
    });

    var observable = function () {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var Observable = opts.implementation || global_1.Observable;
      if (!Observable) {
        throw new Error('`Observable` is not available in global scope, and no implementation was passed');
      }

      return {
        onReturn: function onReturn(channels, context) {
          return new Observable(function (observer) {
            channels.error.subscribe(function (err) {
              return observer.error(err);
            });
            channels.progress.subscribe(function (event) {
              return observer.next(objectAssign({ type: 'progress' }, event));
            });
            channels.response.subscribe(function (response) {
              observer.next(objectAssign({ type: 'response' }, response));
              observer.complete();
            });

            channels.request.publish(context);
            return function () {
              return channels.abort.publish();
            };
          });
        }
      };
    };

    /*!
     * isobject <https://github.com/jonschlinkert/isobject>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */

    var isobject = function isObject(val) {
      return val != null && typeof val === 'object' && Array.isArray(val) === false;
    };

    function isObjectObject(o) {
      return isobject(o) === true
        && Object.prototype.toString.call(o) === '[object Object]';
    }

    var isPlainObject = function isPlainObject(o) {
      var ctor,prot;

      if (isObjectObject(o) === false) return false;

      // If has modified constructor
      ctor = o.constructor;
      if (typeof ctor !== 'function') return false;

      // If has modified prototype
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;

      // If constructor does not have an Object-specific method
      if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
      }

      // Most likely a plain Object
      return true;
    };

    var _typeof$1 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




    var serializeTypes = ['boolean', 'string', 'number'];
    var isBuffer = function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
    };

    var jsonRequest = function () {
      return {
        processOptions: function processOptions(options) {
          var body = options.body;
          if (!body) {
            return options;
          }

          var isStream = typeof body.pipe === 'function';
          var shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body === 'undefined' ? 'undefined' : _typeof$1(body)) !== -1 || Array.isArray(body) || isPlainObject(body));

          if (!shouldSerialize) {
            return options;
          }

          return objectAssign({}, options, {
            body: JSON.stringify(options.body),
            headers: objectAssign({}, options.headers, {
              'Content-Type': 'application/json'
            })
          });
        }
      };
    };

    var jsonResponse = function (opts) {
      return {
        onResponse: function onResponse(response) {
          var contentType = response.headers['content-type'] || '';
          var shouldDecode = opts && opts.force || contentType.indexOf('application/json') !== -1;
          if (!response.body || !contentType || !shouldDecode) {
            return response;
          }

          return objectAssign({}, response, { body: tryParse(response.body) });
        },

        processOptions: function processOptions(options) {
          return objectAssign({}, options, {
            headers: objectAssign({ Accept: 'application/json' }, options.headers)
          });
        }
      };
    };

    function tryParse(body) {
      try {
        return JSON.parse(body);
      } catch (err) {
        err.message = 'Failed to parsed response body as JSON: ' + err.message;
        throw err;
      }
    }

    var browserProgress = function () {
      return {
        onRequest: function onRequest(evt) {
          if (evt.adapter !== 'xhr') {
            return;
          }

          var xhr = evt.request;
          var context = evt.context;

          if ('upload' in xhr && 'onprogress' in xhr.upload) {
            xhr.upload.onprogress = handleProgress('upload');
          }

          if ('onprogress' in xhr) {
            xhr.onprogress = handleProgress('download');
          }

          function handleProgress(stage) {
            return function (event) {
              var percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;
              context.channels.progress.publish({
                stage: stage,
                percent: percent,
                total: event.total,
                loaded: event.loaded,
                lengthComputable: event.lengthComputable
              });
            };
          }
        }
      };
    };

    var progress = browserProgress;

    var makeError_1 = createCommonjsModule(function (module, exports) {

    // ===================================================================

    var construct = typeof Reflect !== 'undefined' ? Reflect.construct : undefined;
    var defineProperty = Object.defineProperty;

    // -------------------------------------------------------------------

    var captureStackTrace = Error.captureStackTrace;
    if (captureStackTrace === undefined) {
      captureStackTrace = function captureStackTrace (error) {
        var container = new Error();

        defineProperty(error, 'stack', {
          configurable: true,
          get: function getStack () {
            var stack = container.stack;

            // Replace property with value for faster future accesses.
            defineProperty(this, 'stack', {
              configurable: true,
              value: stack,
              writable: true
            });

            return stack
          },
          set: function setStack (stack) {
            defineProperty(error, 'stack', {
              configurable: true,
              value: stack,
              writable: true
            });
          }
        });
      };
    }

    // -------------------------------------------------------------------

    function BaseError (message) {
      if (message !== undefined) {
        defineProperty(this, 'message', {
          configurable: true,
          value: message,
          writable: true
        });
      }

      var cname = this.constructor.name;
      if (
        cname !== undefined &&
        cname !== this.name
      ) {
        defineProperty(this, 'name', {
          configurable: true,
          value: cname,
          writable: true
        });
      }

      captureStackTrace(this, this.constructor);
    }

    BaseError.prototype = Object.create(Error.prototype, {
      // See: https://github.com/JsCommunity/make-error/issues/4
      constructor: {
        configurable: true,
        value: BaseError,
        writable: true
      }
    });

    // -------------------------------------------------------------------

    // Sets the name of a function if possible (depends of the JS engine).
    var setFunctionName = (function () {
      function setFunctionName (fn, name) {
        return defineProperty(fn, 'name', {
          configurable: true,
          value: name
        })
      }
      try {
        var f = function () {};
        setFunctionName(f, 'foo');
        if (f.name === 'foo') {
          return setFunctionName
        }
      } catch (_) {}
    })();

    // -------------------------------------------------------------------

    function makeError (constructor, super_) {
      if (super_ == null || super_ === Error) {
        super_ = BaseError;
      } else if (typeof super_ !== 'function') {
        throw new TypeError('super_ should be a function')
      }

      var name;
      if (typeof constructor === 'string') {
        name = constructor;
        constructor = construct !== undefined
          ? function () { return construct(super_, arguments, this.constructor) }
          : function () { super_.apply(this, arguments); };

        // If the name can be set, do it once and for all.
        if (setFunctionName !== undefined) {
          setFunctionName(constructor, name);
          name = undefined;
        }
      } else if (typeof constructor !== 'function') {
        throw new TypeError('constructor should be either a string or a function')
      }

      // Also register the super constructor also as `constructor.super_` just
      // like Node's `util.inherits()`.
      constructor.super_ = constructor['super'] = super_;

      var properties = {
        constructor: {
          configurable: true,
          value: constructor,
          writable: true
        }
      };

      // If the name could not be set on the constructor, set it on the
      // prototype.
      if (name !== undefined) {
        properties.name = {
          configurable: true,
          value: name,
          writable: true
        };
      }
      constructor.prototype = Object.create(super_.prototype, properties);

      return constructor
    }
    exports = module.exports = makeError;
    exports.BaseError = BaseError;
    });

    function ClientError$1(res) {
      var props = extractErrorProps(res);
      ClientError$1.super.call(this, props.message);
      objectAssign(this, props);
    }

    function ServerError$1(res) {
      var props = extractErrorProps(res);
      ServerError$1.super.call(this, props.message);
      objectAssign(this, props);
    }

    function extractErrorProps(res) {
      var body = res.body;
      var props = {
        response: res,
        statusCode: res.statusCode,
        responseBody: stringifyBody(body, res)
      }; // API/Boom style errors ({statusCode, error, message})

      if (body.error && body.message) {
        props.message = "".concat(body.error, " - ").concat(body.message);
        return props;
      } // Query/database errors ({error: {description, other, arb, props}})


      if (body.error && body.error.description) {
        props.message = body.error.description;
        props.details = body.error;
        return props;
      } // Other, more arbitrary errors


      props.message = body.error || body.message || httpErrorMessage(res);
      return props;
    }

    function httpErrorMessage(res) {
      var statusMessage = res.statusMessage ? " ".concat(res.statusMessage) : '';
      return "".concat(res.method, "-request to ").concat(res.url, " resulted in HTTP ").concat(res.statusCode).concat(statusMessage);
    }

    function stringifyBody(body, res) {
      var contentType = (res.headers['content-type'] || '').toLowerCase();
      var isJson = contentType.indexOf('application/json') !== -1;
      return isJson ? JSON.stringify(body, null, 2) : body;
    }

    makeError_1(ClientError$1);
    makeError_1(ServerError$1);
    var ClientError_1 = ClientError$1;
    var ServerError_1 = ServerError$1;

    var errors = {
    	ClientError: ClientError_1,
    	ServerError: ServerError_1
    };

    var browserMiddleware = [];

    /* eslint-disable no-empty-function, no-process-env */














    var ClientError = errors.ClientError,
        ServerError = errors.ServerError;

    var httpError = {
      onResponse: function onResponse(res) {
        if (res.statusCode >= 500) {
          throw new ServerError(res);
        } else if (res.statusCode >= 400) {
          throw new ClientError(res);
        }

        return res;
      }
    }; // Environment-specific middleware.



    var middleware = browserMiddleware.concat([jsonRequest(), jsonResponse(), progress(), httpError, observable({
      implementation: minimal
    })]);
    var request = getIt(middleware);

    function httpRequest(options) {
      var requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request;
      return requester(objectAssign({
        maxRedirects: 0
      }, options));
    }

    httpRequest.defaultRequester = request;
    httpRequest.ClientError = ClientError;
    httpRequest.ServerError = ServerError;
    var request_1 = httpRequest;

    var projectHeader = 'X-Sanity-Project-ID';

    var requestOptions = function (config) {
      var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var headers = {};
      var token = overrides.token || config.token;

      if (token) {
        headers.Authorization = "Bearer ".concat(token);
      }

      if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
        headers[projectHeader] = config.projectId;
      }

      var withCredentials = Boolean(typeof overrides.withCredentials === 'undefined' ? config.token || config.withCredentials : overrides.withCredentials);
      var timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout;
      return objectAssign({}, overrides, {
        headers: objectAssign({}, headers, overrides.headers || {}),
        timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,
        json: true,
        withCredentials: withCredentials
      });
    };

    var defaultCdnHost = 'apicdn.sanity.io';
    var defaultConfig$1 = {
      apiHost: 'https://api.sanity.io',
      useProjectHostname: true,
      gradientMode: false,
      isPromiseAPI: true
    };
    var LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0'];

    var isLocal = function isLocal(host) {
      return LOCALHOSTS.indexOf(host) !== -1;
    }; // eslint-disable-next-line no-console


    var createWarningPrinter = function createWarningPrinter(message) {
      return once(function () {
        return console.warn(message.join(' '));
      });
    };

    var printCdnWarning = createWarningPrinter(['You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and', "cheaper. Think about it! For more info, see ".concat(generateHelpUrl$1('js-client-cdn-configuration'), "."), 'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating', 'the client.']);
    var printBrowserTokenWarning = createWarningPrinter(['You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.', "See ".concat(generateHelpUrl$1('js-client-browser-token'), " for more information and how to hide this warning.")]);
    var printCdnTokenWarning = createWarningPrinter(['You have set `useCdn` to `true` while also specifying a token. This is usually not what you', 'want. The CDN cannot be used with an authorization token, since private data cannot be cached.', "See ".concat(generateHelpUrl$1('js-client-usecdn-token'), " for more information.")]);
    var defaultConfig_1 = defaultConfig$1;

    var initConfig$1 = function (config, prevConfig) {
      var newConfig = objectAssign({}, defaultConfig$1, prevConfig, config);
      var gradientMode = newConfig.gradientMode;
      var projectBased = !gradientMode && newConfig.useProjectHostname;

      if (typeof Promise === 'undefined') {
        var helpUrl = generateHelpUrl$1('js-client-promise-polyfill');
        throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(helpUrl));
      }

      if (gradientMode && !newConfig.namespace) {
        throw new Error('Configuration must contain `namespace` when running in gradient mode');
      }

      if (projectBased && !newConfig.projectId) {
        throw new Error('Configuration must contain `projectId`');
      }

      var isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname;
      var isLocalhost = isBrowser && isLocal(window.location.hostname);

      if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
        printBrowserTokenWarning();
      } else if ((!isBrowser || isLocalhost) && newConfig.useCdn && newConfig.token) {
        printCdnTokenWarning();
      } else if (typeof newConfig.useCdn === 'undefined') {
        printCdnWarning();
      }

      if (projectBased) {
        validators.projectId(newConfig.projectId);
      }

      if (!gradientMode && newConfig.dataset) {
        validators.dataset(newConfig.dataset, newConfig.gradientMode);
      }

      newConfig.isDefaultApi = newConfig.apiHost === defaultConfig$1.apiHost;
      newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.token && !newConfig.withCredentials;

      if (newConfig.gradientMode) {
        newConfig.url = newConfig.apiHost;
        newConfig.cdnUrl = newConfig.apiHost;
      } else {
        var hostParts = newConfig.apiHost.split('://', 2);
        var protocol = hostParts[0];
        var host = hostParts[1];
        var cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;

        if (newConfig.useProjectHostname) {
          newConfig.url = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(host, "/v1");
          newConfig.cdnUrl = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(cdnHost, "/v1");
        } else {
          newConfig.url = "".concat(newConfig.apiHost, "/v1");
          newConfig.cdnUrl = newConfig.url;
        }
      }

      return newConfig;
    };

    var config = {
    	defaultConfig: defaultConfig_1,
    	initConfig: initConfig$1
    };

    var filter$1 = filter$5.filter;

    var map = map$4.map;





















    var defaultConfig = config.defaultConfig,
        initConfig = config.initConfig;

    var toPromise = function toPromise(observable) {
      return observable.toPromise();
    };

    function SanityClient() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig;

      if (!(this instanceof SanityClient)) {
        return new SanityClient(config);
      }

      this.config(config);
      this.assets = new assetsClient(this);
      this.datasets = new datasetsClient(this);
      this.projects = new projectsClient(this);
      this.users = new usersClient(this);
      this.auth = new authClient(this);

      if (this.clientConfig.isPromiseAPI) {
        var observableConfig = objectAssign({}, this.clientConfig, {
          isPromiseAPI: false
        });
        this.observable = new SanityClient(observableConfig);
      }
    }

    objectAssign(SanityClient.prototype, dataMethods);
    objectAssign(SanityClient.prototype, {
      clone: function clone() {
        return new SanityClient(this.config());
      },
      config: function config(newConfig) {
        if (typeof newConfig === 'undefined') {
          return objectAssign({}, this.clientConfig);
        }

        if (this.observable) {
          var observableConfig = objectAssign({}, newConfig, {
            isPromiseAPI: false
          });
          this.observable.config(observableConfig);
        }

        this.clientConfig = initConfig(newConfig, this.clientConfig || {});
        return this;
      },
      getUrl: function getUrl(uri) {
        var canUseCdn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var base = canUseCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
        return "".concat(base, "/").concat(uri.replace(/^\//, ''));
      },
      isPromiseAPI: function isPromiseAPI() {
        return this.clientConfig.isPromiseAPI;
      },
      _requestObservable: function _requestObservable(options) {
        var uri = options.url || options.uri;
        var canUseCdn = this.clientConfig.useCdn && ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0;
        var reqOptions = requestOptions(this.clientConfig, objectAssign({}, options, {
          url: this.getUrl(uri, canUseCdn)
        }));
        return request_1(reqOptions, this.clientConfig.requester);
      },
      request: function request(options) {
        var observable = this._requestObservable(options).pipe(filter$1(function (event) {
          return event.type === 'response';
        }), map(function (event) {
          return event.body;
        }));

        return this.isPromiseAPI() ? toPromise(observable) : observable;
      }
    });
    SanityClient.Patch = patch;
    SanityClient.Transaction = transaction;
    SanityClient.ClientError = request_1.ClientError;
    SanityClient.ServerError = request_1.ServerError;
    SanityClient.requester = request_1.defaultRequester;
    var sanityClient = SanityClient;

    /*!
     * Cross-Browser Split 1.1.1
     * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
     * Available under the MIT License
     * ECMAScript compliant, uniform cross-browser split method
     */

    /**
     * Splits a string into an array of strings using a regex or string separator. Matches of the
     * separator are not included in the result array. However, if `separator` is a regex that contains
     * capturing groups, backreferences are spliced into the result each time `separator` is matched.
     * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
     * cross-browser.
     * @param {String} str String to split.
     * @param {RegExp|String} separator Regex or string to use for separating the string.
     * @param {Number} [limit] Maximum number of items to include in the result array.
     * @returns {Array} Array of substrings.
     * @example
     *
     * // Basic use
     * split('a b c d', ' ');
     * // -> ['a', 'b', 'c', 'd']
     *
     * // With limit
     * split('a b c d', ' ', 2);
     * // -> ['a', 'b']
     *
     * // Backreferences in result array
     * split('..word1 word2..', /([a-z]+)(\d+)/i);
     * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
     */
    var browserSplit = (function split(undef) {

      var nativeSplit = String.prototype.split,
        compliantExecNpcg = /()??/.exec("")[1] === undef,
        // NPCG: nonparticipating capturing group
        self;

      self = function(str, separator, limit) {
        // If `separator` is not a regex, use `nativeSplit`
        if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
          return nativeSplit.call(str, separator, limit);
        }
        var output = [],
          flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
          (separator.sticky ? "y" : ""),
          // Firefox 3+
          lastLastIndex = 0,
          // Make `global` and avoid `lastIndex` issues by working with a copy
          separator = new RegExp(separator.source, flags + "g"),
          separator2, match, lastIndex, lastLength;
        str += ""; // Type-convert
        if (!compliantExecNpcg) {
          // Doesn't need flags gy, but they don't hurt
          separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
        }
        /* Values for `limit`, per the spec:
         * If undefined: 4294967295 // Math.pow(2, 32) - 1
         * If 0, Infinity, or NaN: 0
         * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
         * If negative number: 4294967296 - Math.floor(Math.abs(limit))
         * If other: Type-convert, then use the above rules
         */
        limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
        limit >>> 0; // ToUint32(limit)
        while (match = separator.exec(str)) {
          // `separator.lastIndex` is not reliable cross-browser
          lastIndex = match.index + match[0].length;
          if (lastIndex > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1) {
              match[0].replace(separator2, function() {
                for (var i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undef) {
                    match[i] = undef;
                  }
                }
              });
            }
            if (match.length > 1 && match.index < str.length) {
              Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= limit) {
              break;
            }
          }
          if (separator.lastIndex === match.index) {
            separator.lastIndex++; // Avoid an infinite loop
          }
        }
        if (lastLastIndex === str.length) {
          if (lastLength || !separator.test("")) {
            output.push("");
          }
        } else {
          output.push(str.slice(lastLastIndex));
        }
        return output.length > limit ? output.slice(0, limit) : output;
      };

      return self;
    })();

    var indexOf = [].indexOf;

    var indexof = function(arr, obj){
      if (indexOf) return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj) return i;
      }
      return -1;
    };

    // contains, add, remove, toggle


    var classList = ClassList;

    function ClassList(elem) {
        var cl = elem.classList;

        if (cl) {
            return cl
        }

        var classList = {
            add: add
            , remove: remove
            , contains: contains
            , toggle: toggle
            , toString: $toString
            , length: 0
            , item: item
        };

        return classList

        function add(token) {
            var list = getTokens();
            if (indexof(list, token) > -1) {
                return
            }
            list.push(token);
            setTokens(list);
        }

        function remove(token) {
            var list = getTokens()
                , index = indexof(list, token);

            if (index === -1) {
                return
            }

            list.splice(index, 1);
            setTokens(list);
        }

        function contains(token) {
            return indexof(getTokens(), token) > -1
        }

        function toggle(token) {
            if (contains(token)) {
                remove(token);
                return false
            } else {
                add(token);
                return true
            }
        }

        function $toString() {
            return elem.className
        }

        function item(index) {
            var tokens = getTokens();
            return tokens[index] || null
        }

        function getTokens() {
            var className = elem.className;

            return filter(className.split(" "), isTruthy)
        }

        function setTokens(list) {
            var length = list.length;

            elem.className = list.join(" ");
            classList.length = length;

            for (var i = 0; i < list.length; i++) {
                classList[i] = list[i];
            }

            delete list[length];
        }
    }

    function filter (arr, fn) {
        var ret = [];
        for (var i = 0; i < arr.length; i++) {
            if (fn(arr[i])) ret.push(arr[i]);
        }
        return ret
    }

    function isTruthy(value) {
        return !!value
    }

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    var hyperscript = createCommonjsModule(function (module) {
    var w = typeof window === 'undefined' ? require$$0 : window;
    var document = w.document;
    var Text = w.Text;

    function context () {

      var cleanupFuncs = [];

      function h() {
        var args = [].slice.call(arguments), e = null;
        function item (l) {
          var r;
          function parseClass (string) {
            // Our minimal parser doesn’t understand escaping CSS special
            // characters like `#`. Don’t use them. More reading:
            // https://mathiasbynens.be/notes/css-escapes .

            var m = browserSplit(string, /([\.#]?[^\s#.]+)/);
            if(/^\.|#/.test(m[1]))
              e = document.createElement('div');
            forEach(m, function (v) {
              var s = v.substring(1,v.length);
              if(!v) return
              if(!e)
                e = document.createElement(v);
              else if (v[0] === '.')
                classList(e).add(s);
              else if (v[0] === '#')
                e.setAttribute('id', s);
            });
          }

          if(l == null)
            ;
          else if('string' === typeof l) {
            if(!e)
              parseClass(l);
            else
              e.appendChild(r = document.createTextNode(l));
          }
          else if('number' === typeof l
            || 'boolean' === typeof l
            || l instanceof Date
            || l instanceof RegExp ) {
              e.appendChild(r = document.createTextNode(l.toString()));
          }
          //there might be a better way to handle this...
          else if (isArray(l))
            forEach(l, item);
          else if(isNode(l))
            e.appendChild(r = l);
          else if(l instanceof Text)
            e.appendChild(r = l);
          else if ('object' === typeof l) {
            for (var k in l) {
              if('function' === typeof l[k]) {
                if(/^on\w+/.test(k)) {
                  (function (k, l) { // capture k, l in the closure
                    if (e.addEventListener){
                      e.addEventListener(k.substring(2), l[k], false);
                      cleanupFuncs.push(function(){
                        e.removeEventListener(k.substring(2), l[k], false);
                      });
                    }else {
                      e.attachEvent(k, l[k]);
                      cleanupFuncs.push(function(){
                        e.detachEvent(k, l[k]);
                      });
                    }
                  })(k, l);
                } else {
                  // observable
                  e[k] = l[k]();
                  cleanupFuncs.push(l[k](function (v) {
                    e[k] = v;
                  }));
                }
              }
              else if(k === 'style') {
                if('string' === typeof l[k]) {
                  e.style.cssText = l[k];
                }else {
                  for (var s in l[k]) (function(s, v) {
                    if('function' === typeof v) {
                      // observable
                      e.style.setProperty(s, v());
                      cleanupFuncs.push(v(function (val) {
                        e.style.setProperty(s, val);
                      }));
                    } else
                      var match = l[k][s].match(/(.*)\W+!important\W*$/);
                      if (match) {
                        e.style.setProperty(s, match[1], 'important');
                      } else {
                        e.style.setProperty(s, l[k][s]);
                      }
                  })(s, l[k][s]);
                }
              } else if(k === 'attrs') {
                for (var v in l[k]) {
                  e.setAttribute(v, l[k][v]);
                }
              }
              else if (k.substr(0, 5) === "data-") {
                e.setAttribute(k, l[k]);
              } else {
                e[k] = l[k];
              }
            }
          } else if ('function' === typeof l) {
            //assume it's an observable!
            var v = l();
            e.appendChild(r = isNode(v) ? v : document.createTextNode(v));

            cleanupFuncs.push(l(function (v) {
              if(isNode(v) && r.parentElement)
                r.parentElement.replaceChild(v, r), r = v;
              else
                r.textContent = v;
            }));
          }

          return r
        }
        while(args.length)
          item(args.shift());

        return e
      }

      h.cleanup = function () {
        for (var i = 0; i < cleanupFuncs.length; i++){
          cleanupFuncs[i]();
        }
        cleanupFuncs.length = 0;
      };

      return h
    }

    var h = module.exports = context();
    h.context = context;

    function isNode (el) {
      return el && el.nodeName && el.nodeType
    }

    function forEach (arr, fn) {
      if (arr.forEach) return arr.forEach(fn)
      for (var i = 0; i < arr.length; i++) fn(arr[i], i);
    }

    function isArray (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]'
    }
    });

    var baseUrl = 'https://docs.sanity.io/help/';

    var generateHelpUrl = function generateHelpUrl(slug) {
      return baseUrl + slug
    };

    var imageUrl_umd$1 = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    }(commonjsGlobal, (function () {
      var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
      function parseAssetId(ref) {
        var ref$1 = ref.split('-');
        var id = ref$1[1];
        var dimensionString = ref$1[2];
        var format = ref$1[3];

        if (!id || !dimensionString || !format) {
          throw new Error(("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\"."));
        }

        var ref$2 = dimensionString.split('x');
        var imgWidthStr = ref$2[0];
        var imgHeightStr = ref$2[1];
        var width = +imgWidthStr;
        var height = +imgHeightStr;
        var isValidAssetId = isFinite(width) && isFinite(height);

        if (!isValidAssetId) {
          throw new Error(("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\"."));
        }

        return {
          id: id,
          width: width,
          height: height,
          format: format
        };
      }

      var isRef = function (src) {
        var source = src;
        return source ? typeof source._ref === 'string' : false;
      };

      var isAsset = function (src) {
        var source = src;
        return source ? typeof source._id === 'string' : false;
      };

      var isAssetStub = function (src) {
        var source = src;
        return source && source.asset ? typeof source.asset.url === 'string' : false;
      }; // Convert an asset-id, asset or image to an image record suitable for processing
      // eslint-disable-next-line complexity


      function parseSource(source) {
        if (!source) {
          return null;
        }

        var image;

        if (typeof source === 'string' && isUrl(source)) {
          // Someone passed an existing image url?
          image = {
            asset: {
              _ref: urlToId(source)
            }
          };
        } else if (typeof source === 'string') {
          // Just an asset id
          image = {
            asset: {
              _ref: source
            }
          };
        } else if (isRef(source)) {
          // We just got passed an asset directly
          image = {
            asset: source
          };
        } else if (isAsset(source)) {
          // If we were passed an image asset document
          image = {
            asset: {
              _ref: source._id || ''
            }
          };
        } else if (isAssetStub(source)) {
          // If we were passed a partial asset (`url`, but no `_id`)
          image = {
            asset: {
              _ref: urlToId(source.asset.url)
            }
          };
        } else if (typeof source.asset === 'object') {
          // Probably an actual image with materialized asset
          image = source;
        } else {
          // We got something that does not look like an image, or it is an image
          // that currently isn't sporting an asset.
          return null;
        }

        var img = source;

        if (img.crop) {
          image.crop = img.crop;
        }

        if (img.hotspot) {
          image.hotspot = img.hotspot;
        }

        return applyDefaults(image);
      }

      function isUrl(url) {
        return /^https?:\/\//.test(("" + url));
      }

      function urlToId(url) {
        var parts = url.split('/').slice(-1);
        return ("image-" + (parts[0])).replace(/\.([a-z]+)$/, '-$1');
      } // Mock crop and hotspot if image lacks it


      function applyDefaults(image) {
        if (image.crop && image.hotspot) {
          return image;
        } // We need to pad in default values for crop or hotspot


        var result = Object.assign({}, image);

        if (!result.crop) {
          result.crop = {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0
          };
        }

        if (!result.hotspot) {
          result.hotspot = {
            x: 0.5,
            y: 0.5,
            height: 1.0,
            width: 1.0
          };
        }

        return result;
      }

      var SPEC_NAME_TO_URL_NAME_MAPPINGS = [['width', 'w'], ['height', 'h'], ['format', 'fm'], ['download', 'dl'], ['blur', 'blur'], ['sharpen', 'sharp'], ['invert', 'invert'], ['orientation', 'or'], ['minHeight', 'min-h'], ['maxHeight', 'max-h'], ['minWidth', 'min-w'], ['maxWidth', 'max-w'], ['quality', 'q'], ['fit', 'fit'], ['crop', 'crop'], ['auto', 'auto'], ['dpr', 'dpr']];
      function urlForImage(options) {
        var spec = Object.assign({}, (options || {}));
        var source = spec.source;
        delete spec.source;
        var image = parseSource(source);

        if (!image) {
          return null;
        }

        var id = image.asset._ref || image.asset._id || '';
        var asset = parseAssetId(id); // Compute crop rect in terms of pixel coordinates in the raw source image

        var cropLeft = Math.round(image.crop.left * asset.width);
        var cropTop = Math.round(image.crop.top * asset.height);
        var crop = {
          left: cropLeft,
          top: cropTop,
          width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
          height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
        }; // Compute hot spot rect in terms of pixel coordinates

        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
        var hotSpotCenterX = image.hotspot.x * asset.width;
        var hotSpotCenterY = image.hotspot.y * asset.height;
        var hotspot = {
          left: hotSpotCenterX - hotSpotHorizontalRadius,
          top: hotSpotCenterY - hotSpotVerticalRadius,
          right: hotSpotCenterX + hotSpotHorizontalRadius,
          bottom: hotSpotCenterY + hotSpotVerticalRadius
        }; // If irrelevant, or if we are requested to: don't perform crop/fit based on
        // the crop/hotspot.

        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
          spec = Object.assign({}, spec,
            fit({
              crop: crop,
              hotspot: hotspot
            }, spec));
        }

        return specToImageUrl(Object.assign({}, spec,
          {asset: asset}));
      } // eslint-disable-next-line complexity

      function specToImageUrl(spec) {
        var cdnUrl = spec.baseUrl || 'https://cdn.sanity.io';
        var filename = (spec.asset.id) + "-" + (spec.asset.width) + "x" + (spec.asset.height) + "." + (spec.asset.format);
        var baseUrl = cdnUrl + "/images/" + (spec.projectId) + "/" + (spec.dataset) + "/" + filename;
        var params = [];

        if (spec.rect) {
          // Only bother url with a crop if it actually crops anything
          var ref = spec.rect;
          var left = ref.left;
          var top = ref.top;
          var width = ref.width;
          var height = ref.height;
          var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;

          if (isEffectiveCrop) {
            params.push(("rect=" + left + "," + top + "," + width + "," + height));
          }
        }

        if (spec.bg) {
          params.push(("bg=" + (spec.bg)));
        }

        if (spec.focalPoint) {
          params.push(("fp-x=" + (spec.focalPoint.x)));
          params.push(("fp-x=" + (spec.focalPoint.y)));
        }

        var flip = [spec.flipHorizontal && 'h', spec.flipVertical && 'v'].filter(Boolean).join('');

        if (flip) {
          params.push(("flip=" + flip));
        } // Map from spec name to url param name, and allow using the actual param name as an alternative


        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function (mapping) {
          var specName = mapping[0];
          var param = mapping[1];

          if (typeof spec[specName] !== 'undefined') {
            params.push((param + "=" + (encodeURIComponent(spec[specName]))));
          } else if (typeof spec[param] !== 'undefined') {
            params.push((param + "=" + (encodeURIComponent(spec[param]))));
          }
        });

        if (params.length === 0) {
          return baseUrl;
        }

        return (baseUrl + "?" + (params.join('&')));
      }

      function fit(source, spec) {
        var cropRect;
        var imgWidth = spec.width;
        var imgHeight = spec.height; // If we are not constraining the aspect ratio, we'll just use the whole crop

        if (!(imgWidth && imgHeight)) {
          return {
            width: imgWidth,
            height: imgHeight,
            rect: source.crop
          };
        }

        var crop = source.crop;
        var hotspot = source.hotspot; // If we are here, that means aspect ratio is locked and fitting will be a bit harder

        var desiredAspectRatio = imgWidth / imgHeight;
        var cropAspectRatio = crop.width / crop.height;

        if (cropAspectRatio > desiredAspectRatio) {
          // The crop is wider than the desired aspect ratio. That means we are cutting from the sides
          var height = crop.height;
          var width = height * desiredAspectRatio;
          var top = crop.top; // Center output horizontally over hotspot

          var hotspotXCenter = (hotspot.right - hotspot.left) / 2 + hotspot.left;
          var left = hotspotXCenter - width / 2; // Keep output within crop

          if (left < crop.left) {
            left = crop.left;
          } else if (left + width > crop.left + crop.width) {
            left = crop.left + crop.width - width;
          }

          cropRect = {
            left: Math.round(left),
            top: Math.round(top),
            width: Math.round(width),
            height: Math.round(height)
          };
        } else {
          // The crop is taller than the desired ratio, we are cutting from top and bottom
          var width$1 = crop.width;
          var height$1 = width$1 / desiredAspectRatio;
          var left$1 = crop.left; // Center output vertically over hotspot

          var hotspotYCenter = (hotspot.bottom - hotspot.top) / 2 + hotspot.top;
          var top$1 = hotspotYCenter - height$1 / 2; // Keep output rect within crop

          if (top$1 < crop.top) {
            top$1 = crop.top;
          } else if (top$1 + height$1 > crop.top + crop.height) {
            top$1 = crop.top + crop.height - height$1;
          }

          cropRect = {
            left: Math.max(0, Math.floor(left$1)),
            top: Math.max(0, Math.floor(top$1)),
            width: Math.round(width$1),
            height: Math.round(height$1)
          };
        }

        return {
          width: imgWidth,
          height: imgHeight,
          rect: cropRect
        };
      } // For backwards-compatibility

      var validFits = ['clip', 'crop', 'fill', 'fillmax', 'max', 'scale', 'min'];
      var validCrops = ['top', 'bottom', 'left', 'right', 'center', 'focalpoint', 'entropy'];
      var validAutoModes = ['format'];

      function isSanityClient(client) {
        return client ? typeof client.clientConfig === 'object' : false;
      }

      function rewriteSpecName(key) {
        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;

        for (var i = 0, list = specs; i < list.length; i += 1) {
          var entry = list[i];

          var specName = entry[0];
          var param = entry[1];

          if (key === specName || key === param) {
            return specName;
          }
        }

        return key;
      }

      function urlBuilder(options) {
        // Did we get a SanityClient?
        var client = options;

        if (isSanityClient(client)) {
          // Inherit config from client
          var ref = client.clientConfig;
          var apiHost = ref.apiHost;
          var projectId = ref.projectId;
          var dataset = ref.dataset;
          return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
          });
        } // Or just accept the options as given


        return new ImageUrlBuilder(null, options);
      }

      var ImageUrlBuilder = function ImageUrlBuilder(parent, options) {
        this.options = parent ? Object.assign({}, (parent.options || {}),
          (options || {})) // Merge parent options
        : Object.assign({}, (options || {})); // Copy options
      };

      ImageUrlBuilder.prototype.withOptions = function withOptions (options) {
        var baseUrl = options.baseUrl || '';
        var newOptions = {
          baseUrl: baseUrl
        };

        for (var key in options) {
          if (options.hasOwnProperty(key)) {
            var specKey = rewriteSpecName(key);
            newOptions[specKey] = options[key];
          }
        }

        return new ImageUrlBuilder(this, Object.assign({}, {baseUrl: baseUrl},
          newOptions));
      }; // The image to be represented. Accepts a Sanity 'image'-document, 'asset'-document or
      // _id of asset. To get the benefit of automatic hot-spot/crop integration with the content
      // studio, the 'image'-document must be provided.


      ImageUrlBuilder.prototype.image = function image (source) {
        return this.withOptions({
          source: source
        });
      }; // Specify the dataset


      ImageUrlBuilder.prototype.dataset = function dataset (dataset$1) {
        return this.withOptions({
          dataset: dataset$1
        });
      }; // Specify the projectId


      ImageUrlBuilder.prototype.projectId = function projectId (projectId$1) {
        return this.withOptions({
          projectId: projectId$1
        });
      }; // Specify background color


      ImageUrlBuilder.prototype.bg = function bg (bg$1) {
        return this.withOptions({
          bg: bg$1
        });
      }; // Set DPR scaling factor


      ImageUrlBuilder.prototype.dpr = function dpr (dpr$1) {
        return this.withOptions({
          dpr: dpr$1
        });
      }; // Specify the width of the image in pixels


      ImageUrlBuilder.prototype.width = function width (width$1) {
        return this.withOptions({
          width: width$1
        });
      }; // Specify the height of the image in pixels


      ImageUrlBuilder.prototype.height = function height (height$1) {
        return this.withOptions({
          height: height$1
        });
      }; // Specify focal point in fraction of image dimensions. Each component 0.0-1.0


      ImageUrlBuilder.prototype.focalPoint = function focalPoint (x, y) {
        return this.withOptions({
          focalPoint: {
            x: x,
            y: y
          }
        });
      };

      ImageUrlBuilder.prototype.maxWidth = function maxWidth (maxWidth$1) {
        return this.withOptions({
          maxWidth: maxWidth$1
        });
      };

      ImageUrlBuilder.prototype.minWidth = function minWidth (minWidth$1) {
        return this.withOptions({
          minWidth: minWidth$1
        });
      };

      ImageUrlBuilder.prototype.maxHeight = function maxHeight (maxHeight$1) {
        return this.withOptions({
          maxHeight: maxHeight$1
        });
      };

      ImageUrlBuilder.prototype.minHeight = function minHeight (minHeight$1) {
        return this.withOptions({
          minHeight: minHeight$1
        });
      }; // Specify width and height in pixels


      ImageUrlBuilder.prototype.size = function size (width, height) {
        return this.withOptions({
          width: width,
          height: height
        });
      }; // Specify blur between 0 and 100


      ImageUrlBuilder.prototype.blur = function blur (blur$1) {
        return this.withOptions({
          blur: blur$1
        });
      };

      ImageUrlBuilder.prototype.sharpen = function sharpen (sharpen$1) {
        return this.withOptions({
          sharpen: sharpen$1
        });
      }; // Specify the desired rectangle of the image


      ImageUrlBuilder.prototype.rect = function rect (left, top, width, height) {
        return this.withOptions({
          rect: {
            left: left,
            top: top,
            width: width,
            height: height
          }
        });
      }; // Specify the image format of the image. 'jpg', 'pjpg', 'png', 'webp'


      ImageUrlBuilder.prototype.format = function format (format$1) {
        return this.withOptions({
          format: format$1
        });
      };

      ImageUrlBuilder.prototype.invert = function invert (invert$1) {
        return this.withOptions({
          invert: invert$1
        });
      }; // Rotation in degrees 0, 90, 180, 270


      ImageUrlBuilder.prototype.orientation = function orientation (orientation$1) {
        return this.withOptions({
          orientation: orientation$1
        });
      }; // Compression quality 0-100


      ImageUrlBuilder.prototype.quality = function quality (quality$1) {
        return this.withOptions({
          quality: quality$1
        });
      }; // Make it a download link. Parameter is default filename.


      ImageUrlBuilder.prototype.forceDownload = function forceDownload (download) {
        return this.withOptions({
          download: download
        });
      }; // Flip image horizontally


      ImageUrlBuilder.prototype.flipHorizontal = function flipHorizontal () {
        return this.withOptions({
          flipHorizontal: true
        });
      }; // Flip image verically


      ImageUrlBuilder.prototype.flipVertical = function flipVertical () {
        return this.withOptions({
          flipVertical: true
        });
      }; // Ignore crop/hotspot from image record, even when present


      ImageUrlBuilder.prototype.ignoreImageParams = function ignoreImageParams () {
        return this.withOptions({
          ignoreImageParams: true
        });
      };

      ImageUrlBuilder.prototype.fit = function fit (value) {
        if (validFits.indexOf(value) === -1) {
          throw new Error(("Invalid fit mode \"" + value + "\""));
        }

        return this.withOptions({
          fit: value
        });
      };

      ImageUrlBuilder.prototype.crop = function crop (value) {
        if (validCrops.indexOf(value) === -1) {
          throw new Error(("Invalid crop mode \"" + value + "\""));
        }

        return this.withOptions({
          crop: value
        });
      };

      ImageUrlBuilder.prototype.auto = function auto (value) {
        if (validAutoModes.indexOf(value) === -1) {
          throw new Error(("Invalid auto mode \"" + value + "\""));
        }

        return this.withOptions({
          auto: value
        });
      }; // Gets the url based on the submitted parameters


      ImageUrlBuilder.prototype.url = function url () {
        return urlForImage(this.options);
      }; // Synonym for url()


      ImageUrlBuilder.prototype.toString = function toString () {
        return this.url();
      };

      return urlBuilder;

    })));
    //# sourceMappingURL=image-url.umd.js.map
    });

    var enc = encodeURIComponent;
    var materializeError = "You must either:\n  - Pass `projectId` and `dataset` to the block renderer\n  - Materialize images to include the `url` field.\n\nFor more information, see ".concat(generateHelpUrl('block-content-image-materializing'));

    var getQueryString = function getQueryString(options) {
      var query = options.imageOptions;
      var keys = Object.keys(query);

      if (!keys.length) {
        return '';
      }

      var params = keys.map(function (key) {
        return "".concat(enc(key), "=").concat(enc(query[key]));
      });
      return "?".concat(params.join('&'));
    };

    var buildUrl = function buildUrl(props) {
      var node = props.node,
          options = props.options;
      var projectId = options.projectId,
          dataset = options.dataset;
      var asset = node.asset;

      if (!asset) {
        throw new Error('Image does not have required `asset` property');
      }

      if (asset.url) {
        return asset.url + getQueryString(options);
      }

      if (!projectId || !dataset) {
        throw new Error(materializeError);
      }

      var ref = asset._ref;

      if (!ref) {
        throw new Error('Invalid image reference in block, no `_ref` found on `asset`');
      }

      return imageUrl_umd$1(objectAssign({
        projectId: projectId,
        dataset: dataset
      }, options.imageOptions || {})).image(node).toString();
    };

    var getImageUrl = buildUrl;

    var defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through'];

    var buildMarksTree = function buildMarksTree(block) {
      var children = block.children,
          markDefs = block.markDefs;

      if (!children || !children.length) {
        return [];
      }

      var sortedMarks = children.map(sortMarksByOccurences);
      var rootNode = {
        _type: 'span',
        children: []
      };
      var nodeStack = [rootNode];
      children.forEach(function (span, i) {
        var marksNeeded = sortedMarks[i];

        if (!marksNeeded) {
          var lastNode = nodeStack[nodeStack.length - 1];
          lastNode.children.push(span);
          return;
        }

        var pos = 1; // Start at position one. Root is always plain and should never be removed. (?)

        if (nodeStack.length > 1) {
          for (pos; pos < nodeStack.length; pos++) {
            var mark = nodeStack[pos].markKey;
            var index = marksNeeded.indexOf(mark); // eslint-disable-next-line max-depth

            if (index === -1) {
              break;
            }

            marksNeeded.splice(index, 1);
          }
        } // Keep from beginning to first miss


        nodeStack = nodeStack.slice(0, pos); // Add needed nodes

        var currentNode = findLastParentNode(nodeStack);
        marksNeeded.forEach(function (mark) {
          var node = {
            _type: 'span',
            _key: span._key,
            children: [],
            mark: markDefs.find(function (def) {
              return def._key === mark;
            }) || mark,
            markKey: mark
          };
          currentNode.children.push(node);
          nodeStack.push(node);
          currentNode = node;
        }); // Split at newlines to make individual line chunks, but keep newline
        // characters as individual elements in the array. We use these characters
        // in the span serializer to trigger hard-break rendering

        if (isTextSpan(span)) {
          var lines = span.text.split('\n');

          for (var line = lines.length; line-- > 1;) {
            lines.splice(line, 0, '\n');
          }

          currentNode.children = currentNode.children.concat(lines);
        } else {
          currentNode.children = currentNode.children.concat(span);
        }
      });
      return rootNode.children;
    }; // We want to sort all the marks of all the spans in the following order:
    // 1. Marks that are shared amongst the most adjacent siblings
    // 2. Non-default marks (links, custom metadata)
    // 3. Built-in, plain marks (bold, emphasis, code etc)


    function sortMarksByOccurences(span, i, spans) {
      if (!span.marks || span.marks.length === 0) {
        return span.marks || [];
      }

      var markOccurences = span.marks.reduce(function (occurences, mark) {
        occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1;

        for (var siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {
          var sibling = spans[siblingIndex];

          if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {
            occurences[mark]++;
          } else {
            break;
          }
        }

        return occurences;
      }, {});
      var sortByOccurence = sortMarks.bind(null, markOccurences); // Slicing because sort() mutates the input

      return span.marks.slice().sort(sortByOccurence);
    }

    function sortMarks(occurences, markA, markB) {
      var aOccurences = occurences[markA] || 0;
      var bOccurences = occurences[markB] || 0;

      if (aOccurences !== bOccurences) {
        return bOccurences - aOccurences;
      }

      var aDefaultPos = defaultMarks.indexOf(markA);
      var bDefaultPos = defaultMarks.indexOf(markB); // Sort default marks last

      if (aDefaultPos !== bDefaultPos) {
        return aDefaultPos - bDefaultPos;
      } // Sort other marks simply by key


      if (markA < markB) {
        return -1;
      } else if (markA > markB) {
        return 1;
      }

      return 0;
    }

    function isTextSpan(node) {
      return node._type === 'span' && typeof node.text === 'string' && (Array.isArray(node.marks) || typeof node.marks === 'undefined');
    }

    function findLastParentNode(nodes) {
      for (var i = nodes.length - 1; i >= 0; i--) {
        var node = nodes[i];

        if (node._type === 'span' && node.children) {
          return node;
        }
      }

      return undefined;
    }

    var buildMarksTree_1 = buildMarksTree;

    /* eslint-disable max-depth, complexity */


    function nestLists(blocks) {
      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'html';
      var tree = [];
      var currentList;

      for (var i = 0; i < blocks.length; i++) {
        var block = blocks[i];

        if (!isListBlock(block)) {
          tree.push(block);
          currentList = null;
          continue;
        } // Start of a new list?


        if (!currentList) {
          currentList = listFromBlock(block);
          tree.push(currentList);
          continue;
        } // New list item within same list?


        if (blockMatchesList(block, currentList)) {
          currentList.children.push(block);
          continue;
        } // Different list props, are we going deeper?


        if (block.level > currentList.level) {
          var newList = listFromBlock(block);

          if (mode === 'html') {
            // Because HTML is kinda weird, nested lists needs to be nested within list items
            // So while you would think that we could populate the parent list with a new sub-list,
            // We actually have to target the last list element (child) of the parent.
            // However, at this point we need to be very careful - simply pushing to the list of children
            // will mutate the input, and we don't want to blindly clone the entire tree.
            // Clone the last child while adding our new list as the last child of it
            var lastListItem = lastChild(currentList);
            var newLastChild = objectAssign({}, lastListItem, {
              children: lastListItem.children.concat(newList)
            }); // Swap the last child

            currentList.children[currentList.children.length - 1] = newLastChild;
          } else {
            currentList.children.push(newList);
          } // Set the newly created, deeper list as the current


          currentList = newList;
          continue;
        } // Different list props, are we going back up the tree?


        if (block.level < currentList.level) {
          // Current list has ended, and we need to hook up with a parent of the same level and type
          var match = findListMatching(tree[tree.length - 1], block);

          if (match) {
            currentList = match;
            currentList.children.push(block);
            continue;
          } // Similar parent can't be found, assume new list


          currentList = listFromBlock(block);
          tree.push(currentList);
          continue;
        } // Different list props, different list style?


        if (block.listItem !== currentList.listItem) {
          var _match = findListMatching(tree[tree.length - 1], {
            level: block.level
          });

          if (_match && _match.listItem === block.listItem) {
            currentList = _match;
            currentList.children.push(block);
            continue;
          } else {
            currentList = listFromBlock(block);
            tree.push(currentList);
            continue;
          }
        } // eslint-disable-next-line no-console


        console.warn('Unknown state encountered for block', block);
        tree.push(block);
      }

      return tree;
    }

    function isListBlock(block) {
      return Boolean(block.listItem);
    }

    function blockMatchesList(block, list) {
      return block.level === list.level && block.listItem === list.listItem;
    }

    function listFromBlock(block) {
      return {
        _type: 'list',
        _key: "".concat(block._key, "-parent"),
        level: block.level,
        listItem: block.listItem,
        children: [block]
      };
    }

    function lastChild(block) {
      return block.children && block.children[block.children.length - 1];
    }

    function findListMatching(rootNode, matching) {
      var filterOnType = typeof matching.listItem === 'string';

      if (rootNode._type === 'list' && rootNode.level === matching.level && filterOnType && rootNode.listItem === matching.listItem) {
        return rootNode;
      }

      var node = lastChild(rootNode);

      if (!node) {
        return false;
      }

      return findListMatching(node, matching);
    }

    var nestLists_1 = nestLists;

    var generateKeys = function (blocks) {
      return blocks.map(function (block) {
        if (block._key) {
          return block;
        }

        return objectAssign({
          _key: getStaticKey(block)
        }, block);
      });
    };

    function getStaticKey(item) {
      return checksum(JSON.stringify(item)).toString(36).replace(/[^A-Za-z0-9]/g, '');
    }
    /* eslint-disable no-bitwise */


    function checksum(str) {
      var hash = 0;
      var strlen = str.length;

      if (strlen === 0) {
        return hash;
      }

      for (var i = 0; i < strlen; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash &= hash; // Convert to 32bit integer
      }

      return hash;
    }

    function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



    var isDefined$1 = function isDefined(val) {
      return typeof val !== 'undefined';
    }; // Recursively merge/replace default serializers with user-specified serializers


    var mergeSerializers = function mergeSerializers(defaultSerializers, userSerializers) {
      return Object.keys(defaultSerializers).reduce(function (acc, key) {
        var type = _typeof(defaultSerializers[key]);

        if (type === 'function') {
          acc[key] = isDefined$1(userSerializers[key]) ? userSerializers[key] : defaultSerializers[key];
        } else if (type === 'object') {
          acc[key] = objectAssign({}, defaultSerializers[key], userSerializers[key]);
        } else {
          acc[key] = typeof userSerializers[key] === 'undefined' ? defaultSerializers[key] : userSerializers[key];
        }

        return acc;
      }, {});
    };

    // Properties to extract from props and pass to serializers as options


    var optionProps = ['projectId', 'dataset', 'imageOptions'];

    var isDefined = function isDefined(val) {
      return typeof val !== 'undefined';
    };

    var defaults = {
      imageOptions: {}
    };

    function blocksToNodes(h, properties, defaultSerializers, serializeSpan) {
      var props = objectAssign({}, defaults, properties);
      var rawBlocks = Array.isArray(props.blocks) ? props.blocks : [props.blocks];
      var keyedBlocks = generateKeys(rawBlocks);
      var blocks = nestLists_1(keyedBlocks, props.listNestMode);
      var serializers = mergeSerializers(defaultSerializers, props.serializers || {});
      var options = optionProps.reduce(function (opts, key) {
        var value = props[key];

        if (isDefined(value)) {
          opts[key] = value;
        }

        return opts;
      }, {});

      function serializeNode(node, index, siblings, isInline) {
        if (isList(node)) {
          return serializeList(node);
        }

        if (isListItem(node)) {
          return serializeListItem(node, findListItemIndex(node, siblings));
        }

        if (isSpan(node)) {
          return serializeSpan(node, serializers, index, {
            serializeNode: serializeNode
          });
        }

        return serializeBlock(node, index, isInline);
      }

      function findListItemIndex(node, siblings) {
        var index = 0;

        for (var i = 0; i < siblings.length; i++) {
          if (siblings[i] === node) {
            return index;
          }

          if (!isListItem(siblings[i])) {
            continue;
          }

          index++;
        }

        return index;
      }

      function serializeBlock(block, index, isInline) {
        var tree = buildMarksTree_1(block);
        var children = tree.map(function (node, i, siblings) {
          return serializeNode(node, i, siblings, true);
        });
        var blockProps = {
          key: block._key || "block-".concat(index),
          node: block,
          isInline: isInline,
          serializers: serializers,
          options: options
        };
        return h(serializers.block, blockProps, children);
      }

      function serializeListItem(block, index) {
        var key = block._key;
        var tree = buildMarksTree_1(block);
        var children = tree.map(serializeNode);
        return h(serializers.listItem, {
          node: block,
          serializers: serializers,
          index: index,
          key: key,
          options: options
        }, children);
      }

      function serializeList(list) {
        var type = list.listItem;
        var level = list.level;
        var key = list._key;
        var children = list.children.map(serializeNode);
        return h(serializers.list, {
          key: key,
          level: level,
          type: type,
          options: options
        }, children);
      } // Default to false, so `undefined` will evaluate to the default here


      var renderContainerOnSingleChild = Boolean(props.renderContainerOnSingleChild);
      var nodes = blocks.map(serializeNode);

      if (renderContainerOnSingleChild || nodes.length > 1) {
        var containerProps = props.className ? {
          className: props.className
        } : {};
        return h(serializers.container, containerProps, nodes);
      }

      if (nodes[0]) {
        return nodes[0];
      }

      return typeof serializers.empty === 'function' ? h(serializers.empty) : serializers.empty;
    }

    function isList(block) {
      return block._type === 'list' && block.listItem;
    }

    function isListItem(block) {
      return block._type === 'block' && block.listItem;
    }

    function isSpan(block) {
      return typeof block === 'string' || block.marks || block._type === 'span';
    }

    var blocksToNodes_1 = blocksToNodes;

    var serializers$1 = function (h, serializerOpts) {
      var serializeOptions = serializerOpts || {
        useDashedStyles: false // Low-level block serializer

      };

      function BlockSerializer(props) {
        var node = props.node,
            serializers = props.serializers,
            options = props.options,
            isInline = props.isInline,
            children = props.children;
        var blockType = node._type;
        var serializer = serializers.types[blockType];

        if (!serializer) {
          throw new Error("Unknown block type \"".concat(blockType, "\", please specify a serializer for it in the `serializers.types` prop"));
        }

        return h(serializer, {
          node: node,
          options: options,
          isInline: isInline
        }, children);
      } // Low-level span serializer


      function SpanSerializer(props) {
        var _props$node = props.node,
            mark = _props$node.mark,
            children = _props$node.children;
        var isPlain = typeof mark === 'string';
        var markType = isPlain ? mark : mark._type;
        var serializer = props.serializers.marks[markType];

        if (!serializer) {
          // @todo Revert back to throwing errors?
          // eslint-disable-next-line no-console
          console.warn("Unknown mark type \"".concat(markType, "\", please specify a serializer for it in the `serializers.marks` prop"));
          return h(props.serializers.markFallback, null, children);
        }

        return h(serializer, props.node, children);
      } // Low-level list serializer


      function ListSerializer(props) {
        var tag = props.type === 'bullet' ? 'ul' : 'ol';
        return h(tag, null, props.children);
      } // Low-level list item serializer


      function ListItemSerializer(props) {
        var children = !props.node.style || props.node.style === 'normal' ? // Don't wrap plain text in paragraphs inside of a list item
        props.children : // But wrap any other style in whatever the block serializer says to use
        h(props.serializers.types.block, props, props.children);
        return h('li', null, children);
      } // Renderer of an actual block of type `block`. Confusing, we know.


      function BlockTypeSerializer(props) {
        var style = props.node.style || 'normal';

        if (/^h\d/.test(style)) {
          return h(style, null, props.children);
        }

        return style === 'blockquote' ? h('blockquote', null, props.children) : h('p', null, props.children);
      } // Serializers for things that can be directly attributed to a tag without any props
      // We use partial application to do this, passing the tag name as the first argument


      function RawMarkSerializer(tag, props) {
        return h(tag, null, props.children);
      }

      function UnderlineSerializer(props) {
        var style = serializeOptions.useDashedStyles ? {
          'text-decoration': 'underline'
        } : {
          textDecoration: 'underline'
        };
        return h('span', {
          style: style
        }, props.children);
      }

      function StrikeThroughSerializer(props) {
        return h('del', null, props.children);
      }

      function LinkSerializer(props) {
        return h('a', {
          href: props.mark.href
        }, props.children);
      }

      function ImageSerializer(props) {
        if (!props.node.asset) {
          return null;
        }

        var img = h('img', {
          src: getImageUrl(props)
        });
        return props.isInline ? img : h('figure', null, img);
      } // Serializer that recursively calls itself, producing a hyperscript tree of spans


      function serializeSpan(span, serializers, index, options) {
        if (span === '\n' && serializers.hardBreak) {
          return h(serializers.hardBreak, {
            key: "hb-".concat(index)
          });
        }

        if (typeof span === 'string') {
          return serializers.text ? h(serializers.text, {
            key: "text-".concat(index)
          }, span) : span;
        }

        var children;

        if (span.children) {
          children = {
            children: span.children.map(function (child, i) {
              return options.serializeNode(child, i, span.children, true);
            })
          };
        }

        var serializedNode = objectAssign({}, span, children);
        return h(serializers.span, {
          key: span._key || "span-".concat(index),
          node: serializedNode,
          serializers: serializers
        });
      }

      var HardBreakSerializer = function HardBreakSerializer() {
        return h('br');
      };

      var defaultMarkSerializers = {
        strong: RawMarkSerializer.bind(null, 'strong'),
        em: RawMarkSerializer.bind(null, 'em'),
        code: RawMarkSerializer.bind(null, 'code'),
        underline: UnderlineSerializer,
        'strike-through': StrikeThroughSerializer,
        link: LinkSerializer
      };
      var defaultSerializers = {
        // Common overrides
        types: {
          block: BlockTypeSerializer,
          image: ImageSerializer
        },
        marks: defaultMarkSerializers,
        // Less common overrides
        list: ListSerializer,
        listItem: ListItemSerializer,
        block: BlockSerializer,
        span: SpanSerializer,
        hardBreak: HardBreakSerializer,
        // Container element
        container: 'div',
        // When we can't resolve the mark properly, use this renderer as the container
        markFallback: 'span',
        // Allow overriding text renderer, but leave undefined to just use plain strings by default
        text: undefined,
        // Empty nodes (React uses null, hyperscript with empty strings)
        empty: ''
      };
      return {
        defaultSerializers: defaultSerializers,
        serializeSpan: serializeSpan
      };
    };

    var renderNode = function renderNode(serializer, properties, children) {
      var props = properties || {};

      if (typeof serializer === 'function') {
        return serializer(objectAssign({}, props, {
          children: children
        }));
      }

      var tag = serializer;
      var childNodes = props.children || children;
      return hyperscript(tag, props, childNodes);
    };

    var _getSerializers = serializers$1(renderNode, {
      useDashedStyles: true
    }),
        defaultSerializers = _getSerializers.defaultSerializers,
        serializeSpan = _getSerializers.serializeSpan;

    var blockContentToHyperscript = function blockContentToHyperscript(options) {
      return blocksToNodes_1(renderNode, options, defaultSerializers, serializeSpan);
    }; // Expose default serializers to the user


    blockContentToHyperscript.defaultSerializers = defaultSerializers; // Expose logic for building image URLs from an image reference/node

    blockContentToHyperscript.getImageUrl = getImageUrl; // Expose node renderer

    blockContentToHyperscript.renderNode = renderNode;
    var lib = blockContentToHyperscript;

    var h$1 = lib.renderNode;
    var blocksToHtml = function blocksToHtml(options) {
      var rootNode = lib(options);
      return rootNode.outerHTML || rootNode;
    };

    blocksToHtml.defaultSerializers = lib.defaultSerializers;
    blocksToHtml.getImageUrl = lib.getImageUrl;
    blocksToHtml.renderNode = h$1;
    blocksToHtml.h = h$1;

    var blocksToHtml_1 = blocksToHtml;

    var imageUrl_umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    }(commonjsGlobal, (function () {
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _createForOfIteratorHelperLoose(o) {
        var i = 0;

        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          };
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        i = o[Symbol.iterator]();
        return i.next.bind(i);
      }

      var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
      function parseAssetId(ref) {
        var _ref$split = ref.split('-'),
            id = _ref$split[1],
            dimensionString = _ref$split[2],
            format = _ref$split[3];

        if (!id || !dimensionString || !format) {
          throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }

        var _dimensionString$spli = dimensionString.split('x'),
            imgWidthStr = _dimensionString$spli[0],
            imgHeightStr = _dimensionString$spli[1];

        var width = +imgWidthStr;
        var height = +imgHeightStr;
        var isValidAssetId = isFinite(width) && isFinite(height);

        if (!isValidAssetId) {
          throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }

        return {
          id: id,
          width: width,
          height: height,
          format: format
        };
      }

      var isRef = function isRef(src) {
        var source = src;
        return source ? typeof source._ref === 'string' : false;
      };

      var isAsset = function isAsset(src) {
        var source = src;
        return source ? typeof source._id === 'string' : false;
      };

      var isAssetStub = function isAssetStub(src) {
        var source = src;
        return source && source.asset ? typeof source.asset.url === 'string' : false;
      };

      function parseSource(source) {
        if (!source) {
          return null;
        }

        var image;

        if (typeof source === 'string' && isUrl(source)) {
          image = {
            asset: {
              _ref: urlToId(source)
            }
          };
        } else if (typeof source === 'string') {
          image = {
            asset: {
              _ref: source
            }
          };
        } else if (isRef(source)) {
          image = {
            asset: source
          };
        } else if (isAsset(source)) {
          image = {
            asset: {
              _ref: source._id || ''
            }
          };
        } else if (isAssetStub(source)) {
          image = {
            asset: {
              _ref: urlToId(source.asset.url)
            }
          };
        } else if (typeof source.asset === 'object') {
          image = source;
        } else {
          return null;
        }

        var img = source;

        if (img.crop) {
          image.crop = img.crop;
        }

        if (img.hotspot) {
          image.hotspot = img.hotspot;
        }

        return applyDefaults(image);
      }

      function isUrl(url) {
        return /^https?:\/\//.test("" + url);
      }

      function urlToId(url) {
        var parts = url.split('/').slice(-1);
        return ("image-" + parts[0]).replace(/\.([a-z]+)$/, '-$1');
      }

      function applyDefaults(image) {
        if (image.crop && image.hotspot) {
          return image;
        }

        var result = _extends({}, image);

        if (!result.crop) {
          result.crop = {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0
          };
        }

        if (!result.hotspot) {
          result.hotspot = {
            x: 0.5,
            y: 0.5,
            height: 1.0,
            width: 1.0
          };
        }

        return result;
      }

      var SPEC_NAME_TO_URL_NAME_MAPPINGS = [['width', 'w'], ['height', 'h'], ['format', 'fm'], ['download', 'dl'], ['blur', 'blur'], ['sharpen', 'sharp'], ['invert', 'invert'], ['orientation', 'or'], ['minHeight', 'min-h'], ['maxHeight', 'max-h'], ['minWidth', 'min-w'], ['maxWidth', 'max-w'], ['quality', 'q'], ['fit', 'fit'], ['crop', 'crop'], ['saturation', 'sat'], ['auto', 'auto'], ['dpr', 'dpr'], ['pad', 'pad']];
      function urlForImage(options) {
        var spec = _extends({}, options || {});

        var source = spec.source;
        delete spec.source;
        var image = parseSource(source);

        if (!image) {
          return null;
        }

        var id = image.asset._ref || image.asset._id || '';
        var asset = parseAssetId(id);
        var cropLeft = Math.round(image.crop.left * asset.width);
        var cropTop = Math.round(image.crop.top * asset.height);
        var crop = {
          left: cropLeft,
          top: cropTop,
          width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
          height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
        };
        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
        var hotSpotCenterX = image.hotspot.x * asset.width;
        var hotSpotCenterY = image.hotspot.y * asset.height;
        var hotspot = {
          left: hotSpotCenterX - hotSpotHorizontalRadius,
          top: hotSpotCenterY - hotSpotVerticalRadius,
          right: hotSpotCenterX + hotSpotHorizontalRadius,
          bottom: hotSpotCenterY + hotSpotVerticalRadius
        };

        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
          spec = _extends(_extends({}, spec), fit({
            crop: crop,
            hotspot: hotspot
          }, spec));
        }

        return specToImageUrl(_extends(_extends({}, spec), {}, {
          asset: asset
        }));
      }

      function specToImageUrl(spec) {
        var cdnUrl = spec.baseUrl || 'https://cdn.sanity.io';
        var filename = spec.asset.id + "-" + spec.asset.width + "x" + spec.asset.height + "." + spec.asset.format;
        var baseUrl = cdnUrl + "/images/" + spec.projectId + "/" + spec.dataset + "/" + filename;
        var params = [];

        if (spec.rect) {
          var _spec$rect = spec.rect,
              left = _spec$rect.left,
              top = _spec$rect.top,
              width = _spec$rect.width,
              height = _spec$rect.height;
          var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;

          if (isEffectiveCrop) {
            params.push("rect=" + left + "," + top + "," + width + "," + height);
          }
        }

        if (spec.bg) {
          params.push("bg=" + spec.bg);
        }

        if (spec.focalPoint) {
          params.push("fp-x=" + spec.focalPoint.x);
          params.push("fp-y=" + spec.focalPoint.y);
        }

        var flip = [spec.flipHorizontal && 'h', spec.flipVertical && 'v'].filter(Boolean).join('');

        if (flip) {
          params.push("flip=" + flip);
        }

        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function (mapping) {
          var specName = mapping[0],
              param = mapping[1];

          if (typeof spec[specName] !== 'undefined') {
            params.push(param + "=" + encodeURIComponent(spec[specName]));
          } else if (typeof spec[param] !== 'undefined') {
            params.push(param + "=" + encodeURIComponent(spec[param]));
          }
        });

        if (params.length === 0) {
          return baseUrl;
        }

        return baseUrl + "?" + params.join('&');
      }

      function fit(source, spec) {
        var cropRect;
        var imgWidth = spec.width;
        var imgHeight = spec.height;

        if (!(imgWidth && imgHeight)) {
          return {
            width: imgWidth,
            height: imgHeight,
            rect: source.crop
          };
        }

        var crop = source.crop;
        var hotspot = source.hotspot;
        var desiredAspectRatio = imgWidth / imgHeight;
        var cropAspectRatio = crop.width / crop.height;

        if (cropAspectRatio > desiredAspectRatio) {
          var height = crop.height;
          var width = height * desiredAspectRatio;
          var top = crop.top;
          var hotspotXCenter = (hotspot.right - hotspot.left) / 2 + hotspot.left;
          var left = hotspotXCenter - width / 2;

          if (left < crop.left) {
            left = crop.left;
          } else if (left + width > crop.left + crop.width) {
            left = crop.left + crop.width - width;
          }

          cropRect = {
            left: Math.round(left),
            top: Math.round(top),
            width: Math.round(width),
            height: Math.round(height)
          };
        } else {
          var _width = crop.width;

          var _height = _width / desiredAspectRatio;

          var _left = crop.left;
          var hotspotYCenter = (hotspot.bottom - hotspot.top) / 2 + hotspot.top;

          var _top = hotspotYCenter - _height / 2;

          if (_top < crop.top) {
            _top = crop.top;
          } else if (_top + _height > crop.top + crop.height) {
            _top = crop.top + crop.height - _height;
          }

          cropRect = {
            left: Math.max(0, Math.floor(_left)),
            top: Math.max(0, Math.floor(_top)),
            width: Math.round(_width),
            height: Math.round(_height)
          };
        }

        return {
          width: imgWidth,
          height: imgHeight,
          rect: cropRect
        };
      }

      var validFits = ['clip', 'crop', 'fill', 'fillmax', 'max', 'scale', 'min'];
      var validCrops = ['top', 'bottom', 'left', 'right', 'center', 'focalpoint', 'entropy'];
      var validAutoModes = ['format'];

      function isSanityClientLike(client) {
        return client ? typeof client.clientConfig === 'object' : false;
      }

      function rewriteSpecName(key) {
        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;

        for (var _iterator = _createForOfIteratorHelperLoose(specs), _step; !(_step = _iterator()).done;) {
          var entry = _step.value;
          var specName = entry[0],
              param = entry[1];

          if (key === specName || key === param) {
            return specName;
          }
        }

        return key;
      }

      function urlBuilder(options) {
        var client = options;

        if (isSanityClientLike(client)) {
          var _client$clientConfig = client.clientConfig,
              apiUrl = _client$clientConfig.apiHost,
              projectId = _client$clientConfig.projectId,
              dataset = _client$clientConfig.dataset;
          var apiHost = apiUrl || 'https://api.sanity.io';
          return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
          });
        }

        return new ImageUrlBuilder(null, options);
      }
      var ImageUrlBuilder = /*#__PURE__*/function () {
        function ImageUrlBuilder(parent, options) {
          this.options = parent ? _extends(_extends({}, parent.options || {}), options || {}) : _extends({}, options || {});
        }

        var _proto = ImageUrlBuilder.prototype;

        _proto.withOptions = function withOptions(options) {
          var baseUrl = options.baseUrl || this.options.baseUrl;
          var newOptions = {
            baseUrl: baseUrl
          };

          for (var key in options) {
            if (options.hasOwnProperty(key)) {
              var specKey = rewriteSpecName(key);
              newOptions[specKey] = options[key];
            }
          }

          return new ImageUrlBuilder(this, _extends({
            baseUrl: baseUrl
          }, newOptions));
        };

        _proto.image = function image(source) {
          return this.withOptions({
            source: source
          });
        };

        _proto.dataset = function dataset(_dataset) {
          return this.withOptions({
            dataset: _dataset
          });
        };

        _proto.projectId = function projectId(_projectId) {
          return this.withOptions({
            projectId: _projectId
          });
        };

        _proto.bg = function bg(_bg) {
          return this.withOptions({
            bg: _bg
          });
        };

        _proto.dpr = function dpr(_dpr) {
          return this.withOptions({
            dpr: _dpr
          });
        };

        _proto.width = function width(_width) {
          return this.withOptions({
            width: _width
          });
        };

        _proto.height = function height(_height) {
          return this.withOptions({
            height: _height
          });
        };

        _proto.focalPoint = function focalPoint(x, y) {
          return this.withOptions({
            focalPoint: {
              x: x,
              y: y
            }
          });
        };

        _proto.maxWidth = function maxWidth(_maxWidth) {
          return this.withOptions({
            maxWidth: _maxWidth
          });
        };

        _proto.minWidth = function minWidth(_minWidth) {
          return this.withOptions({
            minWidth: _minWidth
          });
        };

        _proto.maxHeight = function maxHeight(_maxHeight) {
          return this.withOptions({
            maxHeight: _maxHeight
          });
        };

        _proto.minHeight = function minHeight(_minHeight) {
          return this.withOptions({
            minHeight: _minHeight
          });
        };

        _proto.size = function size(width, height) {
          return this.withOptions({
            width: width,
            height: height
          });
        };

        _proto.blur = function blur(_blur) {
          return this.withOptions({
            blur: _blur
          });
        };

        _proto.sharpen = function sharpen(_sharpen) {
          return this.withOptions({
            sharpen: _sharpen
          });
        };

        _proto.rect = function rect(left, top, width, height) {
          return this.withOptions({
            rect: {
              left: left,
              top: top,
              width: width,
              height: height
            }
          });
        };

        _proto.format = function format(_format) {
          return this.withOptions({
            format: _format
          });
        };

        _proto.invert = function invert(_invert) {
          return this.withOptions({
            invert: _invert
          });
        };

        _proto.orientation = function orientation(_orientation) {
          return this.withOptions({
            orientation: _orientation
          });
        };

        _proto.quality = function quality(_quality) {
          return this.withOptions({
            quality: _quality
          });
        };

        _proto.forceDownload = function forceDownload(download) {
          return this.withOptions({
            download: download
          });
        };

        _proto.flipHorizontal = function flipHorizontal() {
          return this.withOptions({
            flipHorizontal: true
          });
        };

        _proto.flipVertical = function flipVertical() {
          return this.withOptions({
            flipVertical: true
          });
        };

        _proto.ignoreImageParams = function ignoreImageParams() {
          return this.withOptions({
            ignoreImageParams: true
          });
        };

        _proto.fit = function fit(value) {
          if (validFits.indexOf(value) === -1) {
            throw new Error("Invalid fit mode \"" + value + "\"");
          }

          return this.withOptions({
            fit: value
          });
        };

        _proto.crop = function crop(value) {
          if (validCrops.indexOf(value) === -1) {
            throw new Error("Invalid crop mode \"" + value + "\"");
          }

          return this.withOptions({
            crop: value
          });
        };

        _proto.saturation = function saturation(_saturation) {
          return this.withOptions({
            saturation: _saturation
          });
        };

        _proto.auto = function auto(value) {
          if (validAutoModes.indexOf(value) === -1) {
            throw new Error("Invalid auto mode \"" + value + "\"");
          }

          return this.withOptions({
            auto: value
          });
        };

        _proto.pad = function pad(_pad) {
          return this.withOptions({
            pad: _pad
          });
        };

        _proto.url = function url() {
          return urlForImage(this.options);
        };

        _proto.toString = function toString() {
          return this.url();
        };

        return ImageUrlBuilder;
      }();

      return urlBuilder;

    })));
    //# sourceMappingURL=image-url.umd.js.map
    });

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
    }

    var isSymbol_1 = isSymbol;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray_1(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol_1(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    var _isKey = isKey;

    /* Built-in method references that are verified to be native. */
    var nativeCreate = _getNative(Object, 'create');

    var _nativeCreate = nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
    }

    var _hashHas = hashHas;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;

    var _Hash = Hash;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;

    var _ListCache = ListCache;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash,
        'map': new (_Map || _ListCache),
        'string': new _Hash
      };
    }

    var _mapCacheClear = mapCacheClear;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;

    var _MapCache = MapCache;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || _MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = _MapCache;

    var memoize_1 = memoize;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize_1(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = _memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    var _stringToPath = stringToPath;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap;

    /** Used as references for various `Number` constants. */
    var INFINITY$2 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray_1(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return _arrayMap(value, baseToString) + '';
      }
      if (isSymbol_1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
    }

    var _baseToString = baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : _baseToString(value);
    }

    var toString_1 = toString;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray_1(value)) {
        return value;
      }
      return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
    }

    var _castPath = castPath;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol_1(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _toKey = toKey;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = _castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[_toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    var _baseGet = baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : _baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get;

    const client = sanityClient({
        projectId: 'gj963qwj',
        dataset: 'production',
        token: '', // or leave blank to be anonymous user
        useCdn: true // `false` if you want to ensure fresh data
    });

    const h = blocksToHtml_1.h;

    const renderBlockText = text =>
        blocksToHtml_1({
            blocks: text,
            serializers: serializers
        });

    const toPlainText = (blocks = []) => {
        return (
            blocks
                .map(block => {
                    if (block._type !== 'block' || !block.children) {
                        return ''
                    }
                    return block.children.map(child => child.text).join('')
                })
                .join('\n\n')
        )
    };

    const builder = imageUrl_umd(client);

    const urlFor = source => builder.image(source);

    const serializers = {
        marks: {
            link: props =>
                h(
                    'a',
                    { target: '_blank', rel: 'noreferrer', href: props.mark.href },
                    props.children
                )
        },
        types: {
            block: props => {
                const style = props.node.style || 'normal';
                // console.dir(props)
                return style === 'blockquote'
                    ? h('blockquote', {}, props.children)
                    : h('p', { className: style }, props.children)

            }
        }
    };

    const sanitizeArticle = res => {
        return {
            id: get_1(res, '_id', ''),
            adTag: get_1(res, 'adTag', false),
            editorialState: get_1(res, 'editorialState', ''),
            title: get_1(res, 'title', ''),
            mainImage: get_1(res, 'mainImage', false),
            slug: get_1(res, 'slug.current', ''),
            publicationDate: get_1(res, 'publicationDate', ''),
            taxonomy: {
                category: get_1(res, 'taxonomy.category', ''),
                subCategory: get_1(res, 'taxonomy.subCategory', ''),
                tags: get_1(res, 'taxonomy.tags', []),
            },
            related: get_1(res, 'related', false),
            content: get_1(res, 'content', []),
            preview: get_1(res, 'preview[0]', []),
            previewColors: get_1(res, 'previewColors', []),
            previewVideoUrl: get_1(res, 'previewVideoUrl', ''),
            relatedSlideshow: get_1(res, 'relatedSlideshow', {})
        }
    };

    const loadArticle = async (query, params) => {
        try {
            const res = await client.fetch(query, params);
            if (res === null) {
                return Promise.reject(new Error(404));
            }

            let postConstruction = sanitizeArticle(res);

            const linksQuery =
                '*[placeAsSidebar._ref == $id && editorialState == "live"][0]';
            postConstruction.banner = await client.fetch(linksQuery, {
                id: postConstruction.id
            });

            return postConstruction
        } catch (err) {
            Sentry.captureException(err);
            return Promise.reject(new Error(404));
        }
    };

    const loadSatelliteSite = async (query, params) => {
        try {
            const res = await client.fetch(query, params);
            if (res === null) {
                return Promise.reject(new Error(404));
            }
            return res
        } catch (err) {
            Sentry.captureException(err);
            return Promise.reject(new Error(404));
        }
    };

    const loadFeed = async (query, params) => {
        try {
            const res = await client.fetch(query, params);
            if (res === null) {
                return Promise.reject(new Error(404));
            }
            return res
        } catch (err) {
            Sentry.captureException(err);
            return Promise.reject(new Error(404));
        }
    };

    const loadPages = async query => {
        try {
            const res = await client.fetch(query, {});
            if (res === null) {
                return Promise.reject(new Error(404));
            }

            return res
        } catch (err) {
            Sentry.captureException(err);
            return Promise.reject(new Error(404));
        }
    };

    // WRITABLE
    const navigationColor = writable('white');
    const menuActiveGlobal = writable(false);
    const pages = writable([]);
    const menuBanners = writable([]);
    const feedBanners = writable([]);
    const overlayBanners = writable([]);
    const activeCategory = writable('');
    const activeQuery = writable('');
    const scrollListActive = writable(false);
    const satelliteSiteActive = writable(false);

    /* src/Components/Navigation.svelte generated by Svelte v3.35.0 */

    const file$o = "src/Components/Navigation.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (226:6) {#if menuActive}
    function create_if_block_3$7(ctx) {
    	let t;
    	let menuitem;
    	let searchbox;
    	let current;
    	let each_value = /*menuItems*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	searchbox = new SearchBox({
    			props: { menuActive: /*menuActive*/ ctx[0] },
    			$$inline: true
    		});

    	searchbox.$on("closeMenu", /*closeMenu_handler*/ ctx[6]);
    	searchbox.$on("searchActive", /*searchActive_handler*/ ctx[7]);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			menuitem = element("menuitem");
    			create_component(searchbox.$$.fragment);
    			attr_dev(menuitem, "class", "navigation__menu-item svelte-zp2cec");
    			add_location(menuitem, file$o, 239, 8, 6287);
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, menuitem, anchor);
    			mount_component(searchbox, menuitem, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*menuItems*/ 8) {
    				each_value = /*menuItems*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const searchbox_changes = {};
    			if (dirty & /*menuActive*/ 1) searchbox_changes.menuActive = /*menuActive*/ ctx[0];
    			searchbox.$set(searchbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(menuitem);
    			destroy_component(searchbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(226:6) {#if menuActive}",
    		ctx
    	});

    	return block;
    }

    // (227:8) {#each menuItems as item, menuIndex}
    function create_each_block$9(ctx) {
    	let menuitem;
    	let a;
    	let div0;
    	let raw0_value = /*item*/ ctx[10].title + "";
    	let t;
    	let div1;
    	let raw1_value = /*item*/ ctx[10].title + "";

    	const block = {
    		c: function create() {
    			menuitem = element("menuitem");
    			a = element("a");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "navigation__link--normal svelte-zp2cec");
    			add_location(div0, file$o, 229, 14, 6020);
    			attr_dev(div1, "class", "navigation__link--hover svelte-zp2cec");
    			add_location(div1, file$o, 232, 14, 6129);
    			attr_dev(a, "href", /*item*/ ctx[10].target);
    			attr_dev(a, "class", "navigation__link svelte-zp2cec");
    			add_location(a, file$o, 228, 12, 5958);
    			attr_dev(menuitem, "class", "navigation__menu-item svelte-zp2cec");
    			add_location(menuitem, file$o, 227, 10, 5905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, menuitem, anchor);
    			append_dev(menuitem, a);
    			append_dev(a, div0);
    			div0.innerHTML = raw0_value;
    			append_dev(a, t);
    			append_dev(a, div1);
    			div1.innerHTML = raw1_value;
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(menuitem);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(227:8) {#each menuItems as item, menuIndex}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  NAVIGATION BAR   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { Router, links }
    function create_catch_block$6(ctx) {
    	const block = { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$6.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  NAVIGATION BAR   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { Router, links }",
    		ctx
    	});

    	return block;
    }

    // (252:44)          {#if !isEmpty(menuBanners)}
    function create_then_block$6(ctx) {
    	let show_if = !isEmpty_1(/*menuBanners*/ ctx[9]);
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$menuBanners*/ 4) show_if = !isEmpty_1(/*menuBanners*/ ctx[9]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$6.name,
    		type: "then",
    		source: "(252:44)          {#if !isEmpty(menuBanners)}",
    		ctx
    	});

    	return block;
    }

    // (253:8) {#if !isEmpty(menuBanners)}
    function create_if_block$h(ctx) {
    	let a;
    	let t;
    	let a_href_value;
    	let if_block0 = /*menuBanners*/ ctx[9][0].video && /*menuBanners*/ ctx[9][0].video.asset && /*menuBanners*/ ctx[9][0].video.asset._ref && create_if_block_2$8(ctx);
    	let if_block1 = /*menuBanners*/ ctx[9][0].image && create_if_block_1$d(ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(a, "href", a_href_value = /*menuBanners*/ ctx[9][0].link);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "banner svelte-zp2cec");
    			toggle_class(a, "hidden", /*searchActive*/ ctx[1]);
    			add_location(a, file$o, 253, 10, 6669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t);
    			if (if_block1) if_block1.m(a, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*menuBanners*/ ctx[9][0].video && /*menuBanners*/ ctx[9][0].video.asset && /*menuBanners*/ ctx[9][0].video.asset._ref) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$8(ctx);
    					if_block0.c();
    					if_block0.m(a, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*menuBanners*/ ctx[9][0].image) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$d(ctx);
    					if_block1.c();
    					if_block1.m(a, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$menuBanners*/ 4 && a_href_value !== (a_href_value = /*menuBanners*/ ctx[9][0].link)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*searchActive*/ 2) {
    				toggle_class(a, "hidden", /*searchActive*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(253:8) {#if !isEmpty(menuBanners)}",
    		ctx
    	});

    	return block;
    }

    // (261:12) {#if menuBanners[0].video && menuBanners[0].video.asset && menuBanners[0].video.asset._ref}
    function create_if_block_2$8(ctx) {
    	let video;
    	let video_src_value;

    	const block = {
    		c: function create() {
    			video = element("video");
    			video.playsInline = "playsinline";
    			if (video.src !== (video_src_value = "https://cdn.sanity.io/files/gj963qwj/production/" + /*menuBanners*/ ctx[9][0].video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"))) attr_dev(video, "src", video_src_value);
    			video.autoplay = true;
    			video.muted = true;
    			video.loop = true;
    			add_location(video, file$o, 261, 14, 6955);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$menuBanners*/ 4 && video.src !== (video_src_value = "https://cdn.sanity.io/files/gj963qwj/production/" + /*menuBanners*/ ctx[9][0].video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"))) {
    				attr_dev(video, "src", video_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(261:12) {#if menuBanners[0].video && menuBanners[0].video.asset && menuBanners[0].video.asset._ref}",
    		ctx
    	});

    	return block;
    }

    // (271:12) {#if menuBanners[0].image}
    function create_if_block_1$d(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "novembre.global");
    			if (img.src !== (img_src_value = urlFor(/*menuBanners*/ ctx[9][0].image).width(700).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "svelte-zp2cec");
    			add_location(img, file$o, 271, 14, 7340);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$menuBanners*/ 4 && img.src !== (img_src_value = urlFor(/*menuBanners*/ ctx[9][0].image).width(700).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(271:12) {#if menuBanners[0].image}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  NAVIGATION BAR   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { Router, links }
    function create_pending_block$6(ctx) {
    	const block = { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$6.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  NAVIGATION BAR   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { Router, links }",
    		ctx
    	});

    	return block;
    }

    // (207:2) <Router>
    function create_default_slot$7(ctx) {
    	let div2;
    	let div0;
    	let logo;
    	let t0;
    	let div1;
    	let t1_value = (/*menuActive*/ ctx[0] ? "CLOSE" : "MENU") + "";
    	let t1;
    	let t2;
    	let menu;
    	let t3;
    	let promise;
    	let current;
    	let mounted;
    	let dispose;

    	logo = new Logo({
    			props: { black: /*menuActive*/ ctx[0] },
    			$$inline: true
    		});

    	let if_block = /*menuActive*/ ctx[0] && create_if_block_3$7(ctx);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$6,
    		then: create_then_block$6,
    		catch: create_catch_block$6,
    		value: 9
    	};

    	handle_promise(promise = /*$menuBanners*/ ctx[2], info);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			menu = element("menu");
    			if (if_block) if_block.c();
    			t3 = space();
    			info.block.c();
    			attr_dev(div0, "class", "navigation__logo svelte-zp2cec");
    			add_location(div0, file$o, 209, 6, 5388);
    			attr_dev(div1, "class", "navigation__toggle svelte-zp2cec");
    			add_location(div1, file$o, 212, 6, 5518);
    			attr_dev(div2, "class", "navigation__bar svelte-zp2cec");
    			add_location(div2, file$o, 208, 4, 5352);
    			attr_dev(menu, "class", "navigation__menu svelte-zp2cec");
    			add_location(menu, file$o, 223, 4, 5750);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(logo, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, menu, anchor);
    			if (if_block) if_block.m(menu, null);
    			append_dev(menu, t3);
    			info.block.m(menu, info.anchor = null);
    			info.mount = () => menu;
    			info.anchor = null;
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(div1, "click", /*click_handler_1*/ ctx[5], false, false, false),
    					listen_dev(menu, "click", /*click_handler_2*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const logo_changes = {};
    			if (dirty & /*menuActive*/ 1) logo_changes.black = /*menuActive*/ ctx[0];
    			logo.$set(logo_changes);
    			if ((!current || dirty & /*menuActive*/ 1) && t1_value !== (t1_value = (/*menuActive*/ ctx[0] ? "CLOSE" : "MENU") + "")) set_data_dev(t1, t1_value);

    			if (/*menuActive*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*menuActive*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(menu, t3);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			info.ctx = ctx;

    			if (dirty & /*$menuBanners*/ 4 && promise !== (promise = /*$menuBanners*/ ctx[2]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[9] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(logo);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(menu);
    			if (if_block) if_block.d();
    			info.block.d();
    			info.token = null;
    			info = null;
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(207:2) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let nav;
    	let router;
    	let current;
    	let mounted;
    	let dispose;

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			create_component(router.$$.fragment);
    			attr_dev(nav, "class", "navigation svelte-zp2cec");
    			toggle_class(nav, "navigation--black", /*menuActive*/ ctx[0]);
    			toggle_class(nav, "navigation--expanded", /*menuActive*/ ctx[0]);
    			add_location(nav, file$o, 200, 0, 5215);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			mount_component(router, nav, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(links.call(null, nav));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, menuActive, $menuBanners, searchActive*/ 8199) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);

    			if (dirty & /*menuActive*/ 1) {
    				toggle_class(nav, "navigation--black", /*menuActive*/ ctx[0]);
    			}

    			if (dirty & /*menuActive*/ 1) {
    				toggle_class(nav, "navigation--expanded", /*menuActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(router);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $menuBanners;
    	validate_store(menuBanners, "menuBanners");
    	component_subscribe($$self, menuBanners, $$value => $$invalidate(2, $menuBanners = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Navigation", slots, []);
    	let menuActive = false;
    	let searchActive = false;

    	const menuItems = [
    		{ title: "FEED", target: "/" },
    		{ title: "BUREAU", target: "/bureau" },
    		{ title: "MAGAZINE", target: "/magazine" },
    		{ title: "ABOUT", target: "/about" },
    		{ title: "CONTACT", target: "/contact" }
    	]; // { title: "STOCKISTS", target: "/stockists" }

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navigation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, menuActive = !menuActive);
    	const click_handler_1 = () => $$invalidate(0, menuActive = !menuActive);

    	const closeMenu_handler = e => {
    		$$invalidate(0, menuActive = false);
    	};

    	const searchActive_handler = e => {
    		$$invalidate(1, searchActive = true);
    	};

    	const click_handler_2 = () => $$invalidate(0, menuActive = !menuActive);

    	$$self.$capture_state = () => ({
    		Router,
    		links,
    		isEmpty: isEmpty_1,
    		Logo,
    		SearchBox,
    		urlFor,
    		menuBanners,
    		navigationColor,
    		menuActiveGlobal,
    		menuActive,
    		searchActive,
    		menuItems,
    		$menuBanners
    	});

    	$$self.$inject_state = $$props => {
    		if ("menuActive" in $$props) $$invalidate(0, menuActive = $$props.menuActive);
    		if ("searchActive" in $$props) $$invalidate(1, searchActive = $$props.searchActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*menuActive*/ 1) {
    			// *** REACTIVE
    			menuActiveGlobal.set(menuActive);
    		}

    		if ($$self.$$.dirty & /*menuActive*/ 1) {
    			{
    				menuActive
    				? document.querySelector("body").classList.add("no-scroll")
    				: document.querySelector("body").classList.remove("no-scroll");
    			}
    		}
    	};

    	return [
    		menuActive,
    		searchActive,
    		$menuBanners,
    		menuItems,
    		click_handler,
    		click_handler_1,
    		closeMenu_handler,
    		searchActive_handler,
    		click_handler_2
    	];
    }

    class Navigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigation",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    var js_cookie = createCommonjsModule(function (module, exports) {
    (function (factory) {
    	var registeredInModuleLoader;
    	{
    		module.exports = factory();
    		registeredInModuleLoader = true;
    	}
    	if (!registeredInModuleLoader) {
    		var OldCookies = window.Cookies;
    		var api = window.Cookies = factory();
    		api.noConflict = function () {
    			window.Cookies = OldCookies;
    			return api;
    		};
    	}
    }(function () {
    	function extend () {
    		var i = 0;
    		var result = {};
    		for (; i < arguments.length; i++) {
    			var attributes = arguments[ i ];
    			for (var key in attributes) {
    				result[key] = attributes[key];
    			}
    		}
    		return result;
    	}

    	function decode (s) {
    		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    	}

    	function init (converter) {
    		function api() {}

    		function set (key, value, attributes) {
    			if (typeof document === 'undefined') {
    				return;
    			}

    			attributes = extend({
    				path: '/'
    			}, api.defaults, attributes);

    			if (typeof attributes.expires === 'number') {
    				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
    			}

    			// We're using "expires" because "max-age" is not supported by IE
    			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

    			try {
    				var result = JSON.stringify(value);
    				if (/^[\{\[]/.test(result)) {
    					value = result;
    				}
    			} catch (e) {}

    			value = converter.write ?
    				converter.write(value, key) :
    				encodeURIComponent(String(value))
    					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

    			key = encodeURIComponent(String(key))
    				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
    				.replace(/[\(\)]/g, escape);

    			var stringifiedAttributes = '';
    			for (var attributeName in attributes) {
    				if (!attributes[attributeName]) {
    					continue;
    				}
    				stringifiedAttributes += '; ' + attributeName;
    				if (attributes[attributeName] === true) {
    					continue;
    				}

    				// Considers RFC 6265 section 5.2:
    				// ...
    				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
    				//     character:
    				// Consume the characters of the unparsed-attributes up to,
    				// not including, the first %x3B (";") character.
    				// ...
    				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    			}

    			return (document.cookie = key + '=' + value + stringifiedAttributes);
    		}

    		function get (key, json) {
    			if (typeof document === 'undefined') {
    				return;
    			}

    			var jar = {};
    			// To prevent the for loop in the first place assign an empty array
    			// in case there are no cookies at all.
    			var cookies = document.cookie ? document.cookie.split('; ') : [];
    			var i = 0;

    			for (; i < cookies.length; i++) {
    				var parts = cookies[i].split('=');
    				var cookie = parts.slice(1).join('=');

    				if (!json && cookie.charAt(0) === '"') {
    					cookie = cookie.slice(1, -1);
    				}

    				try {
    					var name = decode(parts[0]);
    					cookie = (converter.read || converter)(cookie, name) ||
    						decode(cookie);

    					if (json) {
    						try {
    							cookie = JSON.parse(cookie);
    						} catch (e) {}
    					}

    					jar[name] = cookie;

    					if (key === name) {
    						break;
    					}
    				} catch (e) {}
    			}

    			return key ? jar[key] : jar;
    		}

    		api.set = set;
    		api.get = function (key) {
    			return get(key, false /* read as raw */);
    		};
    		api.getJSON = function (key) {
    			return get(key, true /* read as json */);
    		};
    		api.remove = function (key, attributes) {
    			set(key, '', extend(attributes, {
    				expires: -1
    			}));
    		};

    		api.defaults = {};

    		api.withConverter = init;

    		return api;
    	}

    	return init(function () {});
    }));
    });

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity$1 } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    var evEmitter = createCommonjsModule(function (module) {
    /**
     * EvEmitter v1.1.0
     * Lil' event emitter
     * MIT License
     */

    /* jshint unused: true, undef: true, strict: true */

    ( function( global, factory ) {
      // universal module definition
      /* jshint strict: false */ /* globals define, module, window */
      if ( module.exports ) {
        // CommonJS - Browserify, Webpack
        module.exports = factory();
      } else {
        // Browser globals
        global.EvEmitter = factory();
      }

    }( typeof window != 'undefined' ? window : commonjsGlobal, function() {

    function EvEmitter() {}

    var proto = EvEmitter.prototype;

    proto.on = function( eventName, listener ) {
      if ( !eventName || !listener ) {
        return;
      }
      // set events hash
      var events = this._events = this._events || {};
      // set listeners array
      var listeners = events[ eventName ] = events[ eventName ] || [];
      // only add once
      if ( listeners.indexOf( listener ) == -1 ) {
        listeners.push( listener );
      }

      return this;
    };

    proto.once = function( eventName, listener ) {
      if ( !eventName || !listener ) {
        return;
      }
      // add event
      this.on( eventName, listener );
      // set once flag
      // set onceEvents hash
      var onceEvents = this._onceEvents = this._onceEvents || {};
      // set onceListeners object
      var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
      // set flag
      onceListeners[ listener ] = true;

      return this;
    };

    proto.off = function( eventName, listener ) {
      var listeners = this._events && this._events[ eventName ];
      if ( !listeners || !listeners.length ) {
        return;
      }
      var index = listeners.indexOf( listener );
      if ( index != -1 ) {
        listeners.splice( index, 1 );
      }

      return this;
    };

    proto.emitEvent = function( eventName, args ) {
      var listeners = this._events && this._events[ eventName ];
      if ( !listeners || !listeners.length ) {
        return;
      }
      // copy over to avoid interference if .off() in listener
      listeners = listeners.slice(0);
      args = args || [];
      // once stuff
      var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

      for ( var i=0; i < listeners.length; i++ ) {
        var listener = listeners[i];
        var isOnce = onceListeners && onceListeners[ listener ];
        if ( isOnce ) {
          // remove listener
          // remove before trigger to prevent recursion
          this.off( eventName, listener );
          // unset once flag
          delete onceListeners[ listener ];
        }
        // trigger listener
        listener.apply( this, args );
      }

      return this;
    };

    proto.allOff = function() {
      delete this._events;
      delete this._onceEvents;
    };

    return EvEmitter;

    }));
    });

    var getSize = createCommonjsModule(function (module) {
    /*!
     * getSize v2.0.3
     * measure size of elements
     * MIT license
     */

    /* jshint browser: true, strict: true, undef: true, unused: true */
    /* globals console: false */

    ( function( window, factory ) {
      /* jshint strict: false */ /* globals define, module */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.getSize = factory();
      }

    })( window, function factory() {

    // -------------------------- helpers -------------------------- //

    // get a number from a string, not a percentage
    function getStyleSize( value ) {
      var num = parseFloat( value );
      // not a percent like '100%', and a number
      var isValid = value.indexOf('%') == -1 && !isNaN( num );
      return isValid && num;
    }

    function noop() {}

    var logError = typeof console == 'undefined' ? noop :
      function( message ) {
        console.error( message );
      };

    // -------------------------- measurements -------------------------- //

    var measurements = [
      'paddingLeft',
      'paddingRight',
      'paddingTop',
      'paddingBottom',
      'marginLeft',
      'marginRight',
      'marginTop',
      'marginBottom',
      'borderLeftWidth',
      'borderRightWidth',
      'borderTopWidth',
      'borderBottomWidth'
    ];

    var measurementsLength = measurements.length;

    function getZeroSize() {
      var size = {
        width: 0,
        height: 0,
        innerWidth: 0,
        innerHeight: 0,
        outerWidth: 0,
        outerHeight: 0
      };
      for ( var i=0; i < measurementsLength; i++ ) {
        var measurement = measurements[i];
        size[ measurement ] = 0;
      }
      return size;
    }

    // -------------------------- getStyle -------------------------- //

    /**
     * getStyle, get style of element, check for Firefox bug
     * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
     */
    function getStyle( elem ) {
      var style = getComputedStyle( elem );
      if ( !style ) {
        logError( 'Style returned ' + style +
          '. Are you running this code in a hidden iframe on Firefox? ' +
          'See https://bit.ly/getsizebug1' );
      }
      return style;
    }

    // -------------------------- setup -------------------------- //

    var isSetup = false;

    var isBoxSizeOuter;

    /**
     * setup
     * check isBoxSizerOuter
     * do on first getSize() rather than on page load for Firefox bug
     */
    function setup() {
      // setup once
      if ( isSetup ) {
        return;
      }
      isSetup = true;

      // -------------------------- box sizing -------------------------- //

      /**
       * Chrome & Safari measure the outer-width on style.width on border-box elems
       * IE11 & Firefox<29 measures the inner-width
       */
      var div = document.createElement('div');
      div.style.width = '200px';
      div.style.padding = '1px 2px 3px 4px';
      div.style.borderStyle = 'solid';
      div.style.borderWidth = '1px 2px 3px 4px';
      div.style.boxSizing = 'border-box';

      var body = document.body || document.documentElement;
      body.appendChild( div );
      var style = getStyle( div );
      // round value for browser zoom. desandro/masonry#928
      isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;
      getSize.isBoxSizeOuter = isBoxSizeOuter;

      body.removeChild( div );
    }

    // -------------------------- getSize -------------------------- //

    function getSize( elem ) {
      setup();

      // use querySeletor if elem is string
      if ( typeof elem == 'string' ) {
        elem = document.querySelector( elem );
      }

      // do not proceed on non-objects
      if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
        return;
      }

      var style = getStyle( elem );

      // if hidden, everything is 0
      if ( style.display == 'none' ) {
        return getZeroSize();
      }

      var size = {};
      size.width = elem.offsetWidth;
      size.height = elem.offsetHeight;

      var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

      // get all measurements
      for ( var i=0; i < measurementsLength; i++ ) {
        var measurement = measurements[i];
        var value = style[ measurement ];
        var num = parseFloat( value );
        // any 'auto', 'medium' value will be 0
        size[ measurement ] = !isNaN( num ) ? num : 0;
      }

      var paddingWidth = size.paddingLeft + size.paddingRight;
      var paddingHeight = size.paddingTop + size.paddingBottom;
      var marginWidth = size.marginLeft + size.marginRight;
      var marginHeight = size.marginTop + size.marginBottom;
      var borderWidth = size.borderLeftWidth + size.borderRightWidth;
      var borderHeight = size.borderTopWidth + size.borderBottomWidth;

      var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

      // overwrite width and height if we can get it from style
      var styleWidth = getStyleSize( style.width );
      if ( styleWidth !== false ) {
        size.width = styleWidth +
          // add padding and border unless it's already including it
          ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
      }

      var styleHeight = getStyleSize( style.height );
      if ( styleHeight !== false ) {
        size.height = styleHeight +
          // add padding and border unless it's already including it
          ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
      }

      size.innerWidth = size.width - ( paddingWidth + borderWidth );
      size.innerHeight = size.height - ( paddingHeight + borderHeight );

      size.outerWidth = size.width + marginWidth;
      size.outerHeight = size.height + marginHeight;

      return size;
    }

    return getSize;

    });
    });

    var matchesSelector = createCommonjsModule(function (module) {
    /**
     * matchesSelector v2.0.2
     * matchesSelector( element, '.selector' )
     * MIT license
     */

    /*jshint browser: true, strict: true, undef: true, unused: true */

    ( function( window, factory ) {
      // universal module definition
      if ( module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.matchesSelector = factory();
      }

    }( window, function factory() {

      var matchesMethod = ( function() {
        var ElemProto = window.Element.prototype;
        // check for the standard method name first
        if ( ElemProto.matches ) {
          return 'matches';
        }
        // check un-prefixed
        if ( ElemProto.matchesSelector ) {
          return 'matchesSelector';
        }
        // check vendor prefixes
        var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];

        for ( var i=0; i < prefixes.length; i++ ) {
          var prefix = prefixes[i];
          var method = prefix + 'MatchesSelector';
          if ( ElemProto[ method ] ) {
            return method;
          }
        }
      })();

      return function matchesSelector( elem, selector ) {
        return elem[ matchesMethod ]( selector );
      };

    }));
    });

    var utils = createCommonjsModule(function (module) {
    /**
     * Fizzy UI utils v2.0.7
     * MIT license
     */

    /*jshint browser: true, undef: true, unused: true, strict: true */

    ( function( window, factory ) {
      // universal module definition
      /*jshint strict: false */ /*globals define, module, require */

      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          matchesSelector
        );
      } else {
        // browser global
        window.fizzyUIUtils = factory(
          window,
          window.matchesSelector
        );
      }

    }( window, function factory( window, matchesSelector ) {

    var utils = {};

    // ----- extend ----- //

    // extends objects
    utils.extend = function( a, b ) {
      for ( var prop in b ) {
        a[ prop ] = b[ prop ];
      }
      return a;
    };

    // ----- modulo ----- //

    utils.modulo = function( num, div ) {
      return ( ( num % div ) + div ) % div;
    };

    // ----- makeArray ----- //

    var arraySlice = Array.prototype.slice;

    // turn element or nodeList into an array
    utils.makeArray = function( obj ) {
      if ( Array.isArray( obj ) ) {
        // use object if already an array
        return obj;
      }
      // return empty array if undefined or null. #6
      if ( obj === null || obj === undefined ) {
        return [];
      }

      var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
      if ( isArrayLike ) {
        // convert nodeList to array
        return arraySlice.call( obj );
      }

      // array of single index
      return [ obj ];
    };

    // ----- removeFrom ----- //

    utils.removeFrom = function( ary, obj ) {
      var index = ary.indexOf( obj );
      if ( index != -1 ) {
        ary.splice( index, 1 );
      }
    };

    // ----- getParent ----- //

    utils.getParent = function( elem, selector ) {
      while ( elem.parentNode && elem != document.body ) {
        elem = elem.parentNode;
        if ( matchesSelector( elem, selector ) ) {
          return elem;
        }
      }
    };

    // ----- getQueryElement ----- //

    // use element as selector string
    utils.getQueryElement = function( elem ) {
      if ( typeof elem == 'string' ) {
        return document.querySelector( elem );
      }
      return elem;
    };

    // ----- handleEvent ----- //

    // enable .ontype to trigger from .addEventListener( elem, 'type' )
    utils.handleEvent = function( event ) {
      var method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };

    // ----- filterFindElements ----- //

    utils.filterFindElements = function( elems, selector ) {
      // make array of elems
      elems = utils.makeArray( elems );
      var ffElems = [];

      elems.forEach( function( elem ) {
        // check that elem is an actual element
        if ( !( elem instanceof HTMLElement ) ) {
          return;
        }
        // add elem if no selector
        if ( !selector ) {
          ffElems.push( elem );
          return;
        }
        // filter & find items if we have a selector
        // filter
        if ( matchesSelector( elem, selector ) ) {
          ffElems.push( elem );
        }
        // find children
        var childElems = elem.querySelectorAll( selector );
        // concat childElems to filterFound array
        for ( var i=0; i < childElems.length; i++ ) {
          ffElems.push( childElems[i] );
        }
      });

      return ffElems;
    };

    // ----- debounceMethod ----- //

    utils.debounceMethod = function( _class, methodName, threshold ) {
      threshold = threshold || 100;
      // original method
      var method = _class.prototype[ methodName ];
      var timeoutName = methodName + 'Timeout';

      _class.prototype[ methodName ] = function() {
        var timeout = this[ timeoutName ];
        clearTimeout( timeout );

        var args = arguments;
        var _this = this;
        this[ timeoutName ] = setTimeout( function() {
          method.apply( _this, args );
          delete _this[ timeoutName ];
        }, threshold );
      };
    };

    // ----- docReady ----- //

    utils.docReady = function( callback ) {
      var readyState = document.readyState;
      if ( readyState == 'complete' || readyState == 'interactive' ) {
        // do async to allow for other scripts to run. metafizzy/flickity#441
        setTimeout( callback );
      } else {
        document.addEventListener( 'DOMContentLoaded', callback );
      }
    };

    // ----- htmlInit ----- //

    // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
    utils.toDashed = function( str ) {
      return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
        return $1 + '-' + $2;
      }).toLowerCase();
    };

    var console = window.console;
    /**
     * allow user to initialize classes via [data-namespace] or .js-namespace class
     * htmlInit( Widget, 'widgetName' )
     * options are parsed from data-namespace-options
     */
    utils.htmlInit = function( WidgetClass, namespace ) {
      utils.docReady( function() {
        var dashedNamespace = utils.toDashed( namespace );
        var dataAttr = 'data-' + dashedNamespace;
        var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
        var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
        var elems = utils.makeArray( dataAttrElems )
          .concat( utils.makeArray( jsDashElems ) );
        var dataOptionsAttr = dataAttr + '-options';
        var jQuery = window.jQuery;

        elems.forEach( function( elem ) {
          var attr = elem.getAttribute( dataAttr ) ||
            elem.getAttribute( dataOptionsAttr );
          var options;
          try {
            options = attr && JSON.parse( attr );
          } catch ( error ) {
            // log error, do not initialize
            if ( console ) {
              console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
              ': ' + error );
            }
            return;
          }
          // initialize
          var instance = new WidgetClass( elem, options );
          // make available via $().data('namespace')
          if ( jQuery ) {
            jQuery.data( elem, namespace, instance );
          }
        });

      });
    };

    // -----  ----- //

    return utils;

    }));
    });

    var cell = createCommonjsModule(function (module) {
    // Flickity.Cell
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          getSize
        );
      } else {
        // browser global
        window.Flickity = window.Flickity || {};
        window.Flickity.Cell = factory(
          window,
          window.getSize
        );
      }

    }( window, function factory( window, getSize ) {

    function Cell( elem, parent ) {
      this.element = elem;
      this.parent = parent;

      this.create();
    }

    var proto = Cell.prototype;

    proto.create = function() {
      this.element.style.position = 'absolute';
      this.element.setAttribute( 'aria-hidden', 'true' );
      this.x = 0;
      this.shift = 0;
    };

    proto.destroy = function() {
      // reset style
      this.unselect();
      this.element.style.position = '';
      var side = this.parent.originSide;
      this.element.style[ side ] = '';
    };

    proto.getSize = function() {
      this.size = getSize( this.element );
    };

    proto.setPosition = function( x ) {
      this.x = x;
      this.updateTarget();
      this.renderPosition( x );
    };

    // setDefaultTarget v1 method, backwards compatibility, remove in v3
    proto.updateTarget = proto.setDefaultTarget = function() {
      var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';
      this.target = this.x + this.size[ marginProperty ] +
        this.size.width * this.parent.cellAlign;
    };

    proto.renderPosition = function( x ) {
      // render position of cell with in slider
      var side = this.parent.originSide;
      this.element.style[ side ] = this.parent.getPositionValue( x );
    };

    proto.select = function() {
      this.element.classList.add('is-selected');
      this.element.removeAttribute('aria-hidden');
    };

    proto.unselect = function() {
      this.element.classList.remove('is-selected');
      this.element.setAttribute( 'aria-hidden', 'true' );
    };

    /**
     * @param {Integer} factor - 0, 1, or -1
    **/
    proto.wrapShift = function( shift ) {
      this.shift = shift;
      this.renderPosition( this.x + this.parent.slideableWidth * shift );
    };

    proto.remove = function() {
      this.element.parentNode.removeChild( this.element );
    };

    return Cell;

    }));
    });

    var slide = createCommonjsModule(function (module) {
    // slide
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory();
      } else {
        // browser global
        window.Flickity = window.Flickity || {};
        window.Flickity.Slide = factory();
      }

    }( window, function factory() {

    function Slide( parent ) {
      this.parent = parent;
      this.isOriginLeft = parent.originSide == 'left';
      this.cells = [];
      this.outerWidth = 0;
      this.height = 0;
    }

    var proto = Slide.prototype;

    proto.addCell = function( cell ) {
      this.cells.push( cell );
      this.outerWidth += cell.size.outerWidth;
      this.height = Math.max( cell.size.outerHeight, this.height );
      // first cell stuff
      if ( this.cells.length == 1 ) {
        this.x = cell.x; // x comes from first cell
        var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';
        this.firstMargin = cell.size[ beginMargin ];
      }
    };

    proto.updateTarget = function() {
      var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';
      var lastCell = this.getLastCell();
      var lastMargin = lastCell ? lastCell.size[ endMargin ] : 0;
      var slideWidth = this.outerWidth - ( this.firstMargin + lastMargin );
      this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;
    };

    proto.getLastCell = function() {
      return this.cells[ this.cells.length - 1 ];
    };

    proto.select = function() {
      this.cells.forEach( function( cell ) {
        cell.select();
      });
    };

    proto.unselect = function() {
      this.cells.forEach( function( cell ) {
        cell.unselect();
      });
    };

    proto.getCellElements = function() {
      return this.cells.map( function( cell ) {
        return cell.element;
      });
    };

    return Slide;

    }));
    });

    var animate = createCommonjsModule(function (module) {
    // animate
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          utils
        );
      } else {
        // browser global
        window.Flickity = window.Flickity || {};
        window.Flickity.animatePrototype = factory(
          window,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( window, utils ) {

    // -------------------------- animate -------------------------- //

    var proto = {};

    proto.startAnimation = function() {
      if ( this.isAnimating ) {
        return;
      }

      this.isAnimating = true;
      this.restingFrames = 0;
      this.animate();
    };

    proto.animate = function() {
      this.applyDragForce();
      this.applySelectedAttraction();

      var previousX = this.x;

      this.integratePhysics();
      this.positionSlider();
      this.settle( previousX );
      // animate next frame
      if ( this.isAnimating ) {
        var _this = this;
        requestAnimationFrame( function animateFrame() {
          _this.animate();
        });
      }
    };

    proto.positionSlider = function() {
      var x = this.x;
      // wrap position around
      if ( this.options.wrapAround && this.cells.length > 1 ) {
        x = utils.modulo( x, this.slideableWidth );
        x = x - this.slideableWidth;
        this.shiftWrapCells( x );
      }

      this.setTranslateX( x, this.isAnimating );
      this.dispatchScrollEvent();
    };

    proto.setTranslateX = function( x, is3d ) {
      x += this.cursorPosition;
      // reverse if right-to-left and using transform
      x = this.options.rightToLeft ? -x : x;
      var translateX = this.getPositionValue( x );
      // use 3D tranforms for hardware acceleration on iOS
      // but use 2D when settled, for better font-rendering
      this.slider.style.transform = is3d ?
        'translate3d(' + translateX + ',0,0)' : 'translateX(' + translateX + ')';
    };

    proto.dispatchScrollEvent = function() {
      var firstSlide = this.slides[0];
      if ( !firstSlide ) {
        return;
      }
      var positionX = -this.x - firstSlide.target;
      var progress = positionX / this.slidesWidth;
      this.dispatchEvent( 'scroll', null, [ progress, positionX ] );
    };

    proto.positionSliderAtSelected = function() {
      if ( !this.cells.length ) {
        return;
      }
      this.x = -this.selectedSlide.target;
      this.velocity = 0; // stop wobble
      this.positionSlider();
    };

    proto.getPositionValue = function( position ) {
      if ( this.options.percentPosition ) {
        // percent position, round to 2 digits, like 12.34%
        return ( Math.round( ( position / this.size.innerWidth ) * 10000 ) * 0.01 )+ '%';
      } else {
        // pixel positioning
        return Math.round( position ) + 'px';
      }
    };

    proto.settle = function( previousX ) {
      // keep track of frames where x hasn't moved
      if ( !this.isPointerDown && Math.round( this.x * 100 ) == Math.round( previousX * 100 ) ) {
        this.restingFrames++;
      }
      // stop animating if resting for 3 or more frames
      if ( this.restingFrames > 2 ) {
        this.isAnimating = false;
        delete this.isFreeScrolling;
        // render position with translateX when settled
        this.positionSlider();
        this.dispatchEvent( 'settle', null, [ this.selectedIndex ] );
      }
    };

    proto.shiftWrapCells = function( x ) {
      // shift before cells
      var beforeGap = this.cursorPosition + x;
      this._shiftCells( this.beforeShiftCells, beforeGap, -1 );
      // shift after cells
      var afterGap = this.size.innerWidth - ( x + this.slideableWidth + this.cursorPosition );
      this._shiftCells( this.afterShiftCells, afterGap, 1 );
    };

    proto._shiftCells = function( cells, gap, shift ) {
      for ( var i=0; i < cells.length; i++ ) {
        var cell = cells[i];
        var cellShift = gap > 0 ? shift : 0;
        cell.wrapShift( cellShift );
        gap -= cell.size.outerWidth;
      }
    };

    proto._unshiftCells = function( cells ) {
      if ( !cells || !cells.length ) {
        return;
      }
      for ( var i=0; i < cells.length; i++ ) {
        cells[i].wrapShift( 0 );
      }
    };

    // -------------------------- physics -------------------------- //

    proto.integratePhysics = function() {
      this.x += this.velocity;
      this.velocity *= this.getFrictionFactor();
    };

    proto.applyForce = function( force ) {
      this.velocity += force;
    };

    proto.getFrictionFactor = function() {
      return 1 - this.options[ this.isFreeScrolling ? 'freeScrollFriction' : 'friction' ];
    };

    proto.getRestingPosition = function() {
      // my thanks to Steven Wittens, who simplified this math greatly
      return this.x + this.velocity / ( 1 - this.getFrictionFactor() );
    };

    proto.applyDragForce = function() {
      if ( !this.isDraggable || !this.isPointerDown ) {
        return;
      }
      // change the position to drag position by applying force
      var dragVelocity = this.dragX - this.x;
      var dragForce = dragVelocity - this.velocity;
      this.applyForce( dragForce );
    };

    proto.applySelectedAttraction = function() {
      // do not attract if pointer down or no slides
      var dragDown = this.isDraggable && this.isPointerDown;
      if ( dragDown || this.isFreeScrolling || !this.slides.length ) {
        return;
      }
      var distance = this.selectedSlide.target * -1 - this.x;
      var force = distance * this.options.selectedAttraction;
      this.applyForce( force );
    };

    return proto;

    }));
    });

    var flickity = createCommonjsModule(function (module) {
    // Flickity main
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          evEmitter,
          getSize,
          utils,
          cell,
          slide,
          animate
        );
      } else {
        // browser global
        var _Flickity = window.Flickity;

        window.Flickity = factory(
          window,
          window.EvEmitter,
          window.getSize,
          window.fizzyUIUtils,
          _Flickity.Cell,
          _Flickity.Slide,
          _Flickity.animatePrototype
        );
      }

    }( window, function factory( window, EvEmitter, getSize,
      utils, Cell, Slide, animatePrototype ) {

    // vars
    var jQuery = window.jQuery;
    var getComputedStyle = window.getComputedStyle;
    var console = window.console;

    function moveElements( elems, toElem ) {
      elems = utils.makeArray( elems );
      while ( elems.length ) {
        toElem.appendChild( elems.shift() );
      }
    }

    // -------------------------- Flickity -------------------------- //

    // globally unique identifiers
    var GUID = 0;
    // internal store of all Flickity intances
    var instances = {};

    function Flickity( element, options ) {
      var queryElement = utils.getQueryElement( element );
      if ( !queryElement ) {
        if ( console ) {
          console.error( 'Bad element for Flickity: ' + ( queryElement || element ) );
        }
        return;
      }
      this.element = queryElement;
      // do not initialize twice on same element
      if ( this.element.flickityGUID ) {
        var instance = instances[ this.element.flickityGUID ];
        instance.option( options );
        return instance;
      }

      // add jQuery
      if ( jQuery ) {
        this.$element = jQuery( this.element );
      }
      // options
      this.options = utils.extend( {}, this.constructor.defaults );
      this.option( options );

      // kick things off
      this._create();
    }

    Flickity.defaults = {
      accessibility: true,
      // adaptiveHeight: false,
      cellAlign: 'center',
      // cellSelector: undefined,
      // contain: false,
      freeScrollFriction: 0.075, // friction when free-scrolling
      friction: 0.28, // friction when selecting
      namespaceJQueryEvents: true,
      // initialIndex: 0,
      percentPosition: true,
      resize: true,
      selectedAttraction: 0.025,
      setGallerySize: true
      // watchCSS: false,
      // wrapAround: false
    };

    // hash of methods triggered on _create()
    Flickity.createMethods = [];

    var proto = Flickity.prototype;
    // inherit EventEmitter
    utils.extend( proto, EvEmitter.prototype );

    proto._create = function() {
      // add id for Flickity.data
      var id = this.guid = ++GUID;
      this.element.flickityGUID = id; // expando
      instances[ id ] = this; // associate via id
      // initial properties
      this.selectedIndex = 0;
      // how many frames slider has been in same position
      this.restingFrames = 0;
      // initial physics properties
      this.x = 0;
      this.velocity = 0;
      this.originSide = this.options.rightToLeft ? 'right' : 'left';
      // create viewport & slider
      this.viewport = document.createElement('div');
      this.viewport.className = 'flickity-viewport';
      this._createSlider();

      if ( this.options.resize || this.options.watchCSS ) {
        window.addEventListener( 'resize', this );
      }

      // add listeners from on option
      for ( var eventName in this.options.on ) {
        var listener = this.options.on[ eventName ];
        this.on( eventName, listener );
      }

      Flickity.createMethods.forEach( function( method ) {
        this[ method ]();
      }, this );

      if ( this.options.watchCSS ) {
        this.watchCSS();
      } else {
        this.activate();
      }

    };

    /**
     * set options
     * @param {Object} opts
     */
    proto.option = function( opts ) {
      utils.extend( this.options, opts );
    };

    proto.activate = function() {
      if ( this.isActive ) {
        return;
      }
      this.isActive = true;
      this.element.classList.add('flickity-enabled');
      if ( this.options.rightToLeft ) {
        this.element.classList.add('flickity-rtl');
      }

      this.getSize();
      // move initial cell elements so they can be loaded as cells
      var cellElems = this._filterFindCellElements( this.element.children );
      moveElements( cellElems, this.slider );
      this.viewport.appendChild( this.slider );
      this.element.appendChild( this.viewport );
      // get cells from children
      this.reloadCells();

      if ( this.options.accessibility ) {
        // allow element to focusable
        this.element.tabIndex = 0;
        // listen for key presses
        this.element.addEventListener( 'keydown', this );
      }

      this.emitEvent('activate');
      this.selectInitialIndex();
      // flag for initial activation, for using initialIndex
      this.isInitActivated = true;
      // ready event. #493
      this.dispatchEvent('ready');
    };

    // slider positions the cells
    proto._createSlider = function() {
      // slider element does all the positioning
      var slider = document.createElement('div');
      slider.className = 'flickity-slider';
      slider.style[ this.originSide ] = 0;
      this.slider = slider;
    };

    proto._filterFindCellElements = function( elems ) {
      return utils.filterFindElements( elems, this.options.cellSelector );
    };

    // goes through all children
    proto.reloadCells = function() {
      // collection of item elements
      this.cells = this._makeCells( this.slider.children );
      this.positionCells();
      this._getWrapShiftCells();
      this.setGallerySize();
    };

    /**
     * turn elements into Flickity.Cells
     * @param {Array or NodeList or HTMLElement} elems
     * @returns {Array} items - collection of new Flickity Cells
     */
    proto._makeCells = function( elems ) {
      var cellElems = this._filterFindCellElements( elems );

      // create new Flickity for collection
      var cells = cellElems.map( function( cellElem ) {
        return new Cell( cellElem, this );
      }, this );

      return cells;
    };

    proto.getLastCell = function() {
      return this.cells[ this.cells.length - 1 ];
    };

    proto.getLastSlide = function() {
      return this.slides[ this.slides.length - 1 ];
    };

    // positions all cells
    proto.positionCells = function() {
      // size all cells
      this._sizeCells( this.cells );
      // position all cells
      this._positionCells( 0 );
    };

    /**
     * position certain cells
     * @param {Integer} index - which cell to start with
     */
    proto._positionCells = function( index ) {
      index = index || 0;
      // also measure maxCellHeight
      // start 0 if positioning all cells
      this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
      var cellX = 0;
      // get cellX
      if ( index > 0 ) {
        var startCell = this.cells[ index - 1 ];
        cellX = startCell.x + startCell.size.outerWidth;
      }
      var len = this.cells.length;
      for ( var i=index; i < len; i++ ) {
        var cell = this.cells[i];
        cell.setPosition( cellX );
        cellX += cell.size.outerWidth;
        this.maxCellHeight = Math.max( cell.size.outerHeight, this.maxCellHeight );
      }
      // keep track of cellX for wrap-around
      this.slideableWidth = cellX;
      // slides
      this.updateSlides();
      // contain slides target
      this._containSlides();
      // update slidesWidth
      this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;
    };

    /**
     * cell.getSize() on multiple cells
     * @param {Array} cells
     */
    proto._sizeCells = function( cells ) {
      cells.forEach( function( cell ) {
        cell.getSize();
      });
    };

    // --------------------------  -------------------------- //

    proto.updateSlides = function() {
      this.slides = [];
      if ( !this.cells.length ) {
        return;
      }

      var slide = new Slide( this );
      this.slides.push( slide );
      var isOriginLeft = this.originSide == 'left';
      var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';

      var canCellFit = this._getCanCellFit();

      this.cells.forEach( function( cell, i ) {
        // just add cell if first cell in slide
        if ( !slide.cells.length ) {
          slide.addCell( cell );
          return;
        }

        var slideWidth = ( slide.outerWidth - slide.firstMargin ) +
          ( cell.size.outerWidth - cell.size[ nextMargin ] );

        if ( canCellFit.call( this, i, slideWidth ) ) {
          slide.addCell( cell );
        } else {
          // doesn't fit, new slide
          slide.updateTarget();

          slide = new Slide( this );
          this.slides.push( slide );
          slide.addCell( cell );
        }
      }, this );
      // last slide
      slide.updateTarget();
      // update .selectedSlide
      this.updateSelectedSlide();
    };

    proto._getCanCellFit = function() {
      var groupCells = this.options.groupCells;
      if ( !groupCells ) {
        return function() {
          return false;
        };
      } else if ( typeof groupCells == 'number' ) {
        // group by number. 3 -> [0,1,2], [3,4,5], ...
        var number = parseInt( groupCells, 10 );
        return function( i ) {
          return ( i % number ) !== 0;
        };
      }
      // default, group by width of slide
      // parse '75%
      var percentMatch = typeof groupCells == 'string' &&
        groupCells.match(/^(\d+)%$/);
      var percent = percentMatch ? parseInt( percentMatch[1], 10 ) / 100 : 1;
      return function( i, slideWidth ) {
        return slideWidth <= ( this.size.innerWidth + 1 ) * percent;
      };
    };

    // alias _init for jQuery plugin .flickity()
    proto._init =
    proto.reposition = function() {
      this.positionCells();
      this.positionSliderAtSelected();
    };

    proto.getSize = function() {
      this.size = getSize( this.element );
      this.setCellAlign();
      this.cursorPosition = this.size.innerWidth * this.cellAlign;
    };

    var cellAlignShorthands = {
      // cell align, then based on origin side
      center: {
        left: 0.5,
        right: 0.5
      },
      left: {
        left: 0,
        right: 1
      },
      right: {
        right: 0,
        left: 1
      }
    };

    proto.setCellAlign = function() {
      var shorthand = cellAlignShorthands[ this.options.cellAlign ];
      this.cellAlign = shorthand ? shorthand[ this.originSide ] : this.options.cellAlign;
    };

    proto.setGallerySize = function() {
      if ( this.options.setGallerySize ) {
        var height = this.options.adaptiveHeight && this.selectedSlide ?
          this.selectedSlide.height : this.maxCellHeight;
        this.viewport.style.height = height + 'px';
      }
    };

    proto._getWrapShiftCells = function() {
      // only for wrap-around
      if ( !this.options.wrapAround ) {
        return;
      }
      // unshift previous cells
      this._unshiftCells( this.beforeShiftCells );
      this._unshiftCells( this.afterShiftCells );
      // get before cells
      // initial gap
      var gapX = this.cursorPosition;
      var cellIndex = this.cells.length - 1;
      this.beforeShiftCells = this._getGapCells( gapX, cellIndex, -1 );
      // get after cells
      // ending gap between last cell and end of gallery viewport
      gapX = this.size.innerWidth - this.cursorPosition;
      // start cloning at first cell, working forwards
      this.afterShiftCells = this._getGapCells( gapX, 0, 1 );
    };

    proto._getGapCells = function( gapX, cellIndex, increment ) {
      // keep adding cells until the cover the initial gap
      var cells = [];
      while ( gapX > 0 ) {
        var cell = this.cells[ cellIndex ];
        if ( !cell ) {
          break;
        }
        cells.push( cell );
        cellIndex += increment;
        gapX -= cell.size.outerWidth;
      }
      return cells;
    };

    // ----- contain ----- //

    // contain cell targets so no excess sliding
    proto._containSlides = function() {
      if ( !this.options.contain || this.options.wrapAround || !this.cells.length ) {
        return;
      }
      var isRightToLeft = this.options.rightToLeft;
      var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';
      var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';
      var contentWidth = this.slideableWidth - this.getLastCell().size[ endMargin ];
      // content is less than gallery size
      var isContentSmaller = contentWidth < this.size.innerWidth;
      // bounds
      var beginBound = this.cursorPosition + this.cells[0].size[ beginMargin ];
      var endBound = contentWidth - this.size.innerWidth * ( 1 - this.cellAlign );
      // contain each cell target
      this.slides.forEach( function( slide ) {
        if ( isContentSmaller ) {
          // all cells fit inside gallery
          slide.target = contentWidth * this.cellAlign;
        } else {
          // contain to bounds
          slide.target = Math.max( slide.target, beginBound );
          slide.target = Math.min( slide.target, endBound );
        }
      }, this );
    };

    // -----  ----- //

    /**
     * emits events via eventEmitter and jQuery events
     * @param {String} type - name of event
     * @param {Event} event - original event
     * @param {Array} args - extra arguments
     */
    proto.dispatchEvent = function( type, event, args ) {
      var emitArgs = event ? [ event ].concat( args ) : args;
      this.emitEvent( type, emitArgs );

      if ( jQuery && this.$element ) {
        // default trigger with type if no event
        type += this.options.namespaceJQueryEvents ? '.flickity' : '';
        var $event = type;
        if ( event ) {
          // create jQuery event
          var jQEvent = jQuery.Event( event );
          jQEvent.type = type;
          $event = jQEvent;
        }
        this.$element.trigger( $event, args );
      }
    };

    // -------------------------- select -------------------------- //

    /**
     * @param {Integer} index - index of the slide
     * @param {Boolean} isWrap - will wrap-around to last/first if at the end
     * @param {Boolean} isInstant - will immediately set position at selected cell
     */
    proto.select = function( index, isWrap, isInstant ) {
      if ( !this.isActive ) {
        return;
      }
      index = parseInt( index, 10 );
      this._wrapSelect( index );

      if ( this.options.wrapAround || isWrap ) {
        index = utils.modulo( index, this.slides.length );
      }
      // bail if invalid index
      if ( !this.slides[ index ] ) {
        return;
      }
      var prevIndex = this.selectedIndex;
      this.selectedIndex = index;
      this.updateSelectedSlide();
      if ( isInstant ) {
        this.positionSliderAtSelected();
      } else {
        this.startAnimation();
      }
      if ( this.options.adaptiveHeight ) {
        this.setGallerySize();
      }
      // events
      this.dispatchEvent( 'select', null, [ index ] );
      // change event if new index
      if ( index != prevIndex ) {
        this.dispatchEvent( 'change', null, [ index ] );
      }
      // old v1 event name, remove in v3
      this.dispatchEvent('cellSelect');
    };

    // wraps position for wrapAround, to move to closest slide. #113
    proto._wrapSelect = function( index ) {
      var len = this.slides.length;
      var isWrapping = this.options.wrapAround && len > 1;
      if ( !isWrapping ) {
        return index;
      }
      var wrapIndex = utils.modulo( index, len );
      // go to shortest
      var delta = Math.abs( wrapIndex - this.selectedIndex );
      var backWrapDelta = Math.abs( ( wrapIndex + len ) - this.selectedIndex );
      var forewardWrapDelta = Math.abs( ( wrapIndex - len ) - this.selectedIndex );
      if ( !this.isDragSelect && backWrapDelta < delta ) {
        index += len;
      } else if ( !this.isDragSelect && forewardWrapDelta < delta ) {
        index -= len;
      }
      // wrap position so slider is within normal area
      if ( index < 0 ) {
        this.x -= this.slideableWidth;
      } else if ( index >= len ) {
        this.x += this.slideableWidth;
      }
    };

    proto.previous = function( isWrap, isInstant ) {
      this.select( this.selectedIndex - 1, isWrap, isInstant );
    };

    proto.next = function( isWrap, isInstant ) {
      this.select( this.selectedIndex + 1, isWrap, isInstant );
    };

    proto.updateSelectedSlide = function() {
      var slide = this.slides[ this.selectedIndex ];
      // selectedIndex could be outside of slides, if triggered before resize()
      if ( !slide ) {
        return;
      }
      // unselect previous selected slide
      this.unselectSelectedSlide();
      // update new selected slide
      this.selectedSlide = slide;
      slide.select();
      this.selectedCells = slide.cells;
      this.selectedElements = slide.getCellElements();
      // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility
      // Remove in v3?
      this.selectedCell = slide.cells[0];
      this.selectedElement = this.selectedElements[0];
    };

    proto.unselectSelectedSlide = function() {
      if ( this.selectedSlide ) {
        this.selectedSlide.unselect();
      }
    };

    proto.selectInitialIndex = function() {
      var initialIndex = this.options.initialIndex;
      // already activated, select previous selectedIndex
      if ( this.isInitActivated ) {
        this.select( this.selectedIndex, false, true );
        return;
      }
      // select with selector string
      if ( initialIndex && typeof initialIndex == 'string' ) {
        var cell = this.queryCell( initialIndex );
        if ( cell ) {
          this.selectCell( initialIndex, false, true );
          return;
        }
      }

      var index = 0;
      // select with number
      if ( initialIndex && this.slides[ initialIndex ] ) {
        index = initialIndex;
      }
      // select instantly
      this.select( index, false, true );
    };

    /**
     * select slide from number or cell element
     * @param {Element or Number} elem
     */
    proto.selectCell = function( value, isWrap, isInstant ) {
      // get cell
      var cell = this.queryCell( value );
      if ( !cell ) {
        return;
      }

      var index = this.getCellSlideIndex( cell );
      this.select( index, isWrap, isInstant );
    };

    proto.getCellSlideIndex = function( cell ) {
      // get index of slides that has cell
      for ( var i=0; i < this.slides.length; i++ ) {
        var slide = this.slides[i];
        var index = slide.cells.indexOf( cell );
        if ( index != -1 ) {
          return i;
        }
      }
    };

    // -------------------------- get cells -------------------------- //

    /**
     * get Flickity.Cell, given an Element
     * @param {Element} elem
     * @returns {Flickity.Cell} item
     */
    proto.getCell = function( elem ) {
      // loop through cells to get the one that matches
      for ( var i=0; i < this.cells.length; i++ ) {
        var cell = this.cells[i];
        if ( cell.element == elem ) {
          return cell;
        }
      }
    };

    /**
     * get collection of Flickity.Cells, given Elements
     * @param {Element, Array, NodeList} elems
     * @returns {Array} cells - Flickity.Cells
     */
    proto.getCells = function( elems ) {
      elems = utils.makeArray( elems );
      var cells = [];
      elems.forEach( function( elem ) {
        var cell = this.getCell( elem );
        if ( cell ) {
          cells.push( cell );
        }
      }, this );
      return cells;
    };

    /**
     * get cell elements
     * @returns {Array} cellElems
     */
    proto.getCellElements = function() {
      return this.cells.map( function( cell ) {
        return cell.element;
      });
    };

    /**
     * get parent cell from an element
     * @param {Element} elem
     * @returns {Flickit.Cell} cell
     */
    proto.getParentCell = function( elem ) {
      // first check if elem is cell
      var cell = this.getCell( elem );
      if ( cell ) {
        return cell;
      }
      // try to get parent cell elem
      elem = utils.getParent( elem, '.flickity-slider > *' );
      return this.getCell( elem );
    };

    /**
     * get cells adjacent to a slide
     * @param {Integer} adjCount - number of adjacent slides
     * @param {Integer} index - index of slide to start
     * @returns {Array} cells - array of Flickity.Cells
     */
    proto.getAdjacentCellElements = function( adjCount, index ) {
      if ( !adjCount ) {
        return this.selectedSlide.getCellElements();
      }
      index = index === undefined ? this.selectedIndex : index;

      var len = this.slides.length;
      if ( 1 + ( adjCount * 2 ) >= len ) {
        return this.getCellElements();
      }

      var cellElems = [];
      for ( var i = index - adjCount; i <= index + adjCount ; i++ ) {
        var slideIndex = this.options.wrapAround ? utils.modulo( i, len ) : i;
        var slide = this.slides[ slideIndex ];
        if ( slide ) {
          cellElems = cellElems.concat( slide.getCellElements() );
        }
      }
      return cellElems;
    };

    /**
     * select slide from number or cell element
     * @param {Element, Selector String, or Number} selector
     */
    proto.queryCell = function( selector ) {
      if ( typeof selector == 'number' ) {
        // use number as index
        return this.cells[ selector ];
      }
      if ( typeof selector == 'string' ) {
        // do not select invalid selectors from hash: #123, #/. #791
        if ( selector.match(/^[#\.]?[\d\/]/) ) {
          return;
        }
        // use string as selector, get element
        selector = this.element.querySelector( selector );
      }
      // get cell from element
      return this.getCell( selector );
    };

    // -------------------------- events -------------------------- //

    proto.uiChange = function() {
      this.emitEvent('uiChange');
    };

    // keep focus on element when child UI elements are clicked
    proto.childUIPointerDown = function( event ) {
      // HACK iOS does not allow touch events to bubble up?!
      if ( event.type != 'touchstart' ) {
        event.preventDefault();
      }
      this.focus();
    };

    // ----- resize ----- //

    proto.onresize = function() {
      this.watchCSS();
      this.resize();
    };

    utils.debounceMethod( Flickity, 'onresize', 150 );

    proto.resize = function() {
      if ( !this.isActive ) {
        return;
      }
      this.getSize();
      // wrap values
      if ( this.options.wrapAround ) {
        this.x = utils.modulo( this.x, this.slideableWidth );
      }
      this.positionCells();
      this._getWrapShiftCells();
      this.setGallerySize();
      this.emitEvent('resize');
      // update selected index for group slides, instant
      // TODO: position can be lost between groups of various numbers
      var selectedElement = this.selectedElements && this.selectedElements[0];
      this.selectCell( selectedElement, false, true );
    };

    // watches the :after property, activates/deactivates
    proto.watchCSS = function() {
      var watchOption = this.options.watchCSS;
      if ( !watchOption ) {
        return;
      }

      var afterContent = getComputedStyle( this.element, ':after' ).content;
      // activate if :after { content: 'flickity' }
      if ( afterContent.indexOf('flickity') != -1 ) {
        this.activate();
      } else {
        this.deactivate();
      }
    };

    // ----- keydown ----- //

    // go previous/next if left/right keys pressed
    proto.onkeydown = function( event ) {
      // only work if element is in focus
      var isNotFocused = document.activeElement && document.activeElement != this.element;
      if ( !this.options.accessibility ||isNotFocused ) {
        return;
      }

      var handler = Flickity.keyboardHandlers[ event.keyCode ];
      if ( handler ) {
        handler.call( this );
      }
    };

    Flickity.keyboardHandlers = {
      // left arrow
      37: function() {
        var leftMethod = this.options.rightToLeft ? 'next' : 'previous';
        this.uiChange();
        this[ leftMethod ]();
      },
      // right arrow
      39: function() {
        var rightMethod = this.options.rightToLeft ? 'previous' : 'next';
        this.uiChange();
        this[ rightMethod ]();
      },
    };

    // ----- focus ----- //

    proto.focus = function() {
      // TODO remove scrollTo once focus options gets more support
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus#Browser_compatibility
      var prevScrollY = window.pageYOffset;
      this.element.focus({ preventScroll: true });
      // hack to fix scroll jump after focus, #76
      if ( window.pageYOffset != prevScrollY ) {
        window.scrollTo( window.pageXOffset, prevScrollY );
      }
    };

    // -------------------------- destroy -------------------------- //

    // deactivate all Flickity functionality, but keep stuff available
    proto.deactivate = function() {
      if ( !this.isActive ) {
        return;
      }
      this.element.classList.remove('flickity-enabled');
      this.element.classList.remove('flickity-rtl');
      this.unselectSelectedSlide();
      // destroy cells
      this.cells.forEach( function( cell ) {
        cell.destroy();
      });
      this.element.removeChild( this.viewport );
      // move child elements back into element
      moveElements( this.slider.children, this.element );
      if ( this.options.accessibility ) {
        this.element.removeAttribute('tabIndex');
        this.element.removeEventListener( 'keydown', this );
      }
      // set flags
      this.isActive = false;
      this.emitEvent('deactivate');
    };

    proto.destroy = function() {
      this.deactivate();
      window.removeEventListener( 'resize', this );
      this.allOff();
      this.emitEvent('destroy');
      if ( jQuery && this.$element ) {
        jQuery.removeData( this.element, 'flickity' );
      }
      delete this.element.flickityGUID;
      delete instances[ this.guid ];
    };

    // -------------------------- prototype -------------------------- //

    utils.extend( proto, animatePrototype );

    // -------------------------- extras -------------------------- //

    /**
     * get Flickity instance from element
     * @param {Element} elem
     * @returns {Flickity}
     */
    Flickity.data = function( elem ) {
      elem = utils.getQueryElement( elem );
      var id = elem && elem.flickityGUID;
      return id && instances[ id ];
    };

    utils.htmlInit( Flickity, 'flickity' );

    if ( jQuery && jQuery.bridget ) {
      jQuery.bridget( 'flickity', Flickity );
    }

    // set internal jQuery, for Webpack + jQuery v3, #478
    Flickity.setJQuery = function( jq ) {
      jQuery = jq;
    };

    Flickity.Cell = Cell;
    Flickity.Slide = Slide;

    return Flickity;

    }));
    });

    var unipointer = createCommonjsModule(function (module) {
    /*!
     * Unipointer v2.3.0
     * base class for doing one thing with pointer event
     * MIT license
     */

    /*jshint browser: true, undef: true, unused: true, strict: true */

    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */ /*global define, module, require */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          evEmitter
        );
      } else {
        // browser global
        window.Unipointer = factory(
          window,
          window.EvEmitter
        );
      }

    }( window, function factory( window, EvEmitter ) {

    function noop() {}

    function Unipointer() {}

    // inherit EvEmitter
    var proto = Unipointer.prototype = Object.create( EvEmitter.prototype );

    proto.bindStartEvent = function( elem ) {
      this._bindStartEvent( elem, true );
    };

    proto.unbindStartEvent = function( elem ) {
      this._bindStartEvent( elem, false );
    };

    /**
     * Add or remove start event
     * @param {Boolean} isAdd - remove if falsey
     */
    proto._bindStartEvent = function( elem, isAdd ) {
      // munge isAdd, default to true
      isAdd = isAdd === undefined ? true : isAdd;
      var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';

      // default to mouse events
      var startEvent = 'mousedown';
      if ( window.PointerEvent ) {
        // Pointer Events
        startEvent = 'pointerdown';
      } else if ( 'ontouchstart' in window ) {
        // Touch Events. iOS Safari
        startEvent = 'touchstart';
      }
      elem[ bindMethod ]( startEvent, this );
    };

    // trigger handler methods for events
    proto.handleEvent = function( event ) {
      var method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };

    // returns the touch that we're keeping track of
    proto.getTouch = function( touches ) {
      for ( var i=0; i < touches.length; i++ ) {
        var touch = touches[i];
        if ( touch.identifier == this.pointerIdentifier ) {
          return touch;
        }
      }
    };

    // ----- start event ----- //

    proto.onmousedown = function( event ) {
      // dismiss clicks from right or middle buttons
      var button = event.button;
      if ( button && ( button !== 0 && button !== 1 ) ) {
        return;
      }
      this._pointerDown( event, event );
    };

    proto.ontouchstart = function( event ) {
      this._pointerDown( event, event.changedTouches[0] );
    };

    proto.onpointerdown = function( event ) {
      this._pointerDown( event, event );
    };

    /**
     * pointer start
     * @param {Event} event
     * @param {Event or Touch} pointer
     */
    proto._pointerDown = function( event, pointer ) {
      // dismiss right click and other pointers
      // button = 0 is okay, 1-4 not
      if ( event.button || this.isPointerDown ) {
        return;
      }

      this.isPointerDown = true;
      // save pointer identifier to match up touch events
      this.pointerIdentifier = pointer.pointerId !== undefined ?
        // pointerId for pointer events, touch.indentifier for touch events
        pointer.pointerId : pointer.identifier;

      this.pointerDown( event, pointer );
    };

    proto.pointerDown = function( event, pointer ) {
      this._bindPostStartEvents( event );
      this.emitEvent( 'pointerDown', [ event, pointer ] );
    };

    // hash of events to be bound after start event
    var postStartEvents = {
      mousedown: [ 'mousemove', 'mouseup' ],
      touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],
      pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],
    };

    proto._bindPostStartEvents = function( event ) {
      if ( !event ) {
        return;
      }
      // get proper events to match start event
      var events = postStartEvents[ event.type ];
      // bind events to node
      events.forEach( function( eventName ) {
        window.addEventListener( eventName, this );
      }, this );
      // save these arguments
      this._boundPointerEvents = events;
    };

    proto._unbindPostStartEvents = function() {
      // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)
      if ( !this._boundPointerEvents ) {
        return;
      }
      this._boundPointerEvents.forEach( function( eventName ) {
        window.removeEventListener( eventName, this );
      }, this );

      delete this._boundPointerEvents;
    };

    // ----- move event ----- //

    proto.onmousemove = function( event ) {
      this._pointerMove( event, event );
    };

    proto.onpointermove = function( event ) {
      if ( event.pointerId == this.pointerIdentifier ) {
        this._pointerMove( event, event );
      }
    };

    proto.ontouchmove = function( event ) {
      var touch = this.getTouch( event.changedTouches );
      if ( touch ) {
        this._pointerMove( event, touch );
      }
    };

    /**
     * pointer move
     * @param {Event} event
     * @param {Event or Touch} pointer
     * @private
     */
    proto._pointerMove = function( event, pointer ) {
      this.pointerMove( event, pointer );
    };

    // public
    proto.pointerMove = function( event, pointer ) {
      this.emitEvent( 'pointerMove', [ event, pointer ] );
    };

    // ----- end event ----- //


    proto.onmouseup = function( event ) {
      this._pointerUp( event, event );
    };

    proto.onpointerup = function( event ) {
      if ( event.pointerId == this.pointerIdentifier ) {
        this._pointerUp( event, event );
      }
    };

    proto.ontouchend = function( event ) {
      var touch = this.getTouch( event.changedTouches );
      if ( touch ) {
        this._pointerUp( event, touch );
      }
    };

    /**
     * pointer up
     * @param {Event} event
     * @param {Event or Touch} pointer
     * @private
     */
    proto._pointerUp = function( event, pointer ) {
      this._pointerDone();
      this.pointerUp( event, pointer );
    };

    // public
    proto.pointerUp = function( event, pointer ) {
      this.emitEvent( 'pointerUp', [ event, pointer ] );
    };

    // ----- pointer done ----- //

    // triggered on pointer up & pointer cancel
    proto._pointerDone = function() {
      this._pointerReset();
      this._unbindPostStartEvents();
      this.pointerDone();
    };

    proto._pointerReset = function() {
      // reset properties
      this.isPointerDown = false;
      delete this.pointerIdentifier;
    };

    proto.pointerDone = noop;

    // ----- pointer cancel ----- //

    proto.onpointercancel = function( event ) {
      if ( event.pointerId == this.pointerIdentifier ) {
        this._pointerCancel( event, event );
      }
    };

    proto.ontouchcancel = function( event ) {
      var touch = this.getTouch( event.changedTouches );
      if ( touch ) {
        this._pointerCancel( event, touch );
      }
    };

    /**
     * pointer cancel
     * @param {Event} event
     * @param {Event or Touch} pointer
     * @private
     */
    proto._pointerCancel = function( event, pointer ) {
      this._pointerDone();
      this.pointerCancel( event, pointer );
    };

    // public
    proto.pointerCancel = function( event, pointer ) {
      this.emitEvent( 'pointerCancel', [ event, pointer ] );
    };

    // -----  ----- //

    // utility function for getting x/y coords from event
    Unipointer.getPointerPoint = function( pointer ) {
      return {
        x: pointer.pageX,
        y: pointer.pageY
      };
    };

    // -----  ----- //

    return Unipointer;

    }));
    });

    var unidragger = createCommonjsModule(function (module) {
    /*!
     * Unidragger v2.3.0
     * Draggable base class
     * MIT license
     */

    /*jshint browser: true, unused: true, undef: true, strict: true */

    ( function( window, factory ) {
      // universal module definition
      /*jshint strict: false */ /*globals define, module, require */

      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          unipointer
        );
      } else {
        // browser global
        window.Unidragger = factory(
          window,
          window.Unipointer
        );
      }

    }( window, function factory( window, Unipointer ) {

    // -------------------------- Unidragger -------------------------- //

    function Unidragger() {}

    // inherit Unipointer & EvEmitter
    var proto = Unidragger.prototype = Object.create( Unipointer.prototype );

    // ----- bind start ----- //

    proto.bindHandles = function() {
      this._bindHandles( true );
    };

    proto.unbindHandles = function() {
      this._bindHandles( false );
    };

    /**
     * Add or remove start event
     * @param {Boolean} isAdd
     */
    proto._bindHandles = function( isAdd ) {
      // munge isAdd, default to true
      isAdd = isAdd === undefined ? true : isAdd;
      // bind each handle
      var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';
      var touchAction = isAdd ? this._touchActionValue : '';
      for ( var i=0; i < this.handles.length; i++ ) {
        var handle = this.handles[i];
        this._bindStartEvent( handle, isAdd );
        handle[ bindMethod ]( 'click', this );
        // touch-action: none to override browser touch gestures. metafizzy/flickity#540
        if ( window.PointerEvent ) {
          handle.style.touchAction = touchAction;
        }
      }
    };

    // prototype so it can be overwriteable by Flickity
    proto._touchActionValue = 'none';

    // ----- start event ----- //

    /**
     * pointer start
     * @param {Event} event
     * @param {Event or Touch} pointer
     */
    proto.pointerDown = function( event, pointer ) {
      var isOkay = this.okayPointerDown( event );
      if ( !isOkay ) {
        return;
      }
      // track start event position
      this.pointerDownPointer = pointer;

      event.preventDefault();
      this.pointerDownBlur();
      // bind move and end events
      this._bindPostStartEvents( event );
      this.emitEvent( 'pointerDown', [ event, pointer ] );
    };

    // nodes that have text fields
    var cursorNodes = {
      TEXTAREA: true,
      INPUT: true,
      SELECT: true,
      OPTION: true,
    };

    // input types that do not have text fields
    var clickTypes = {
      radio: true,
      checkbox: true,
      button: true,
      submit: true,
      image: true,
      file: true,
    };

    // dismiss inputs with text fields. flickity#403, flickity#404
    proto.okayPointerDown = function( event ) {
      var isCursorNode = cursorNodes[ event.target.nodeName ];
      var isClickType = clickTypes[ event.target.type ];
      var isOkay = !isCursorNode || isClickType;
      if ( !isOkay ) {
        this._pointerReset();
      }
      return isOkay;
    };

    // kludge to blur previously focused input
    proto.pointerDownBlur = function() {
      var focused = document.activeElement;
      // do not blur body for IE10, metafizzy/flickity#117
      var canBlur = focused && focused.blur && focused != document.body;
      if ( canBlur ) {
        focused.blur();
      }
    };

    // ----- move event ----- //

    /**
     * drag move
     * @param {Event} event
     * @param {Event or Touch} pointer
     */
    proto.pointerMove = function( event, pointer ) {
      var moveVector = this._dragPointerMove( event, pointer );
      this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );
      this._dragMove( event, pointer, moveVector );
    };

    // base pointer move logic
    proto._dragPointerMove = function( event, pointer ) {
      var moveVector = {
        x: pointer.pageX - this.pointerDownPointer.pageX,
        y: pointer.pageY - this.pointerDownPointer.pageY
      };
      // start drag if pointer has moved far enough to start drag
      if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {
        this._dragStart( event, pointer );
      }
      return moveVector;
    };

    // condition if pointer has moved far enough to start drag
    proto.hasDragStarted = function( moveVector ) {
      return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;
    };

    // ----- end event ----- //

    /**
     * pointer up
     * @param {Event} event
     * @param {Event or Touch} pointer
     */
    proto.pointerUp = function( event, pointer ) {
      this.emitEvent( 'pointerUp', [ event, pointer ] );
      this._dragPointerUp( event, pointer );
    };

    proto._dragPointerUp = function( event, pointer ) {
      if ( this.isDragging ) {
        this._dragEnd( event, pointer );
      } else {
        // pointer didn't move enough for drag to start
        this._staticClick( event, pointer );
      }
    };

    // -------------------------- drag -------------------------- //

    // dragStart
    proto._dragStart = function( event, pointer ) {
      this.isDragging = true;
      // prevent clicks
      this.isPreventingClicks = true;
      this.dragStart( event, pointer );
    };

    proto.dragStart = function( event, pointer ) {
      this.emitEvent( 'dragStart', [ event, pointer ] );
    };

    // dragMove
    proto._dragMove = function( event, pointer, moveVector ) {
      // do not drag if not dragging yet
      if ( !this.isDragging ) {
        return;
      }

      this.dragMove( event, pointer, moveVector );
    };

    proto.dragMove = function( event, pointer, moveVector ) {
      event.preventDefault();
      this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );
    };

    // dragEnd
    proto._dragEnd = function( event, pointer ) {
      // set flags
      this.isDragging = false;
      // re-enable clicking async
      setTimeout( function() {
        delete this.isPreventingClicks;
      }.bind( this ) );

      this.dragEnd( event, pointer );
    };

    proto.dragEnd = function( event, pointer ) {
      this.emitEvent( 'dragEnd', [ event, pointer ] );
    };

    // ----- onclick ----- //

    // handle all clicks and prevent clicks when dragging
    proto.onclick = function( event ) {
      if ( this.isPreventingClicks ) {
        event.preventDefault();
      }
    };

    // ----- staticClick ----- //

    // triggered after pointer down & up with no/tiny movement
    proto._staticClick = function( event, pointer ) {
      // ignore emulated mouse up clicks
      if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {
        return;
      }

      this.staticClick( event, pointer );

      // set flag for emulated clicks 300ms after touchend
      if ( event.type != 'mouseup' ) {
        this.isIgnoringMouseUp = true;
        // reset flag after 300ms
        setTimeout( function() {
          delete this.isIgnoringMouseUp;
        }.bind( this ), 400 );
      }
    };

    proto.staticClick = function( event, pointer ) {
      this.emitEvent( 'staticClick', [ event, pointer ] );
    };

    // ----- utils ----- //

    Unidragger.getPointerPoint = Unipointer.getPointerPoint;

    // -----  ----- //

    return Unidragger;

    }));
    });

    var drag = createCommonjsModule(function (module) {
    // drag
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          flickity,
          unidragger,
          utils
        );
      } else {
        // browser global
        window.Flickity = factory(
          window,
          window.Flickity,
          window.Unidragger,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( window, Flickity, Unidragger, utils ) {

    // ----- defaults ----- //

    utils.extend( Flickity.defaults, {
      draggable: '>1',
      dragThreshold: 3,
    });

    // ----- create ----- //

    Flickity.createMethods.push('_createDrag');

    // -------------------------- drag prototype -------------------------- //

    var proto = Flickity.prototype;
    utils.extend( proto, Unidragger.prototype );
    proto._touchActionValue = 'pan-y';

    // --------------------------  -------------------------- //

    var isTouch = 'createTouch' in document;
    var isTouchmoveScrollCanceled = false;

    proto._createDrag = function() {
      this.on( 'activate', this.onActivateDrag );
      this.on( 'uiChange', this._uiChangeDrag );
      this.on( 'deactivate', this.onDeactivateDrag );
      this.on( 'cellChange', this.updateDraggable );
      // TODO updateDraggable on resize? if groupCells & slides change
      // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior
      // #457, RubaXa/Sortable#973
      if ( isTouch && !isTouchmoveScrollCanceled ) {
        window.addEventListener( 'touchmove', function() {});
        isTouchmoveScrollCanceled = true;
      }
    };

    proto.onActivateDrag = function() {
      this.handles = [ this.viewport ];
      this.bindHandles();
      this.updateDraggable();
    };

    proto.onDeactivateDrag = function() {
      this.unbindHandles();
      this.element.classList.remove('is-draggable');
    };

    proto.updateDraggable = function() {
      // disable dragging if less than 2 slides. #278
      if ( this.options.draggable == '>1' ) {
        this.isDraggable = this.slides.length > 1;
      } else {
        this.isDraggable = this.options.draggable;
      }
      if ( this.isDraggable ) {
        this.element.classList.add('is-draggable');
      } else {
        this.element.classList.remove('is-draggable');
      }
    };

    // backwards compatibility
    proto.bindDrag = function() {
      this.options.draggable = true;
      this.updateDraggable();
    };

    proto.unbindDrag = function() {
      this.options.draggable = false;
      this.updateDraggable();
    };

    proto._uiChangeDrag = function() {
      delete this.isFreeScrolling;
    };

    // -------------------------- pointer events -------------------------- //

    proto.pointerDown = function( event, pointer ) {
      if ( !this.isDraggable ) {
        this._pointerDownDefault( event, pointer );
        return;
      }
      var isOkay = this.okayPointerDown( event );
      if ( !isOkay ) {
        return;
      }

      this._pointerDownPreventDefault( event );
      this.pointerDownFocus( event );
      // blur
      if ( document.activeElement != this.element ) {
        // do not blur if already focused
        this.pointerDownBlur();
      }

      // stop if it was moving
      this.dragX = this.x;
      this.viewport.classList.add('is-pointer-down');
      // track scrolling
      this.pointerDownScroll = getScrollPosition();
      window.addEventListener( 'scroll', this );

      this._pointerDownDefault( event, pointer );
    };

    // default pointerDown logic, used for staticClick
    proto._pointerDownDefault = function( event, pointer ) {
      // track start event position
      // Safari 9 overrides pageX and pageY. These values needs to be copied. #779
      this.pointerDownPointer = {
        pageX: pointer.pageX,
        pageY: pointer.pageY,
      };
      // bind move and end events
      this._bindPostStartEvents( event );
      this.dispatchEvent( 'pointerDown', event, [ pointer ] );
    };

    var focusNodes = {
      INPUT: true,
      TEXTAREA: true,
      SELECT: true,
    };

    proto.pointerDownFocus = function( event ) {
      var isFocusNode = focusNodes[ event.target.nodeName ];
      if ( !isFocusNode ) {
        this.focus();
      }
    };

    proto._pointerDownPreventDefault = function( event ) {
      var isTouchStart = event.type == 'touchstart';
      var isTouchPointer = event.pointerType == 'touch';
      var isFocusNode = focusNodes[ event.target.nodeName ];
      if ( !isTouchStart && !isTouchPointer && !isFocusNode ) {
        event.preventDefault();
      }
    };

    // ----- move ----- //

    proto.hasDragStarted = function( moveVector ) {
      return Math.abs( moveVector.x ) > this.options.dragThreshold;
    };

    // ----- up ----- //

    proto.pointerUp = function( event, pointer ) {
      delete this.isTouchScrolling;
      this.viewport.classList.remove('is-pointer-down');
      this.dispatchEvent( 'pointerUp', event, [ pointer ] );
      this._dragPointerUp( event, pointer );
    };

    proto.pointerDone = function() {
      window.removeEventListener( 'scroll', this );
      delete this.pointerDownScroll;
    };

    // -------------------------- dragging -------------------------- //

    proto.dragStart = function( event, pointer ) {
      if ( !this.isDraggable ) {
        return;
      }
      this.dragStartPosition = this.x;
      this.startAnimation();
      window.removeEventListener( 'scroll', this );
      this.dispatchEvent( 'dragStart', event, [ pointer ] );
    };

    proto.pointerMove = function( event, pointer ) {
      var moveVector = this._dragPointerMove( event, pointer );
      this.dispatchEvent( 'pointerMove', event, [ pointer, moveVector ] );
      this._dragMove( event, pointer, moveVector );
    };

    proto.dragMove = function( event, pointer, moveVector ) {
      if ( !this.isDraggable ) {
        return;
      }
      event.preventDefault();

      this.previousDragX = this.dragX;
      // reverse if right-to-left
      var direction = this.options.rightToLeft ? -1 : 1;
      if ( this.options.wrapAround ) {
        // wrap around move. #589
        moveVector.x = moveVector.x % this.slideableWidth;
      }
      var dragX = this.dragStartPosition + moveVector.x * direction;

      if ( !this.options.wrapAround && this.slides.length ) {
        // slow drag
        var originBound = Math.max( -this.slides[0].target, this.dragStartPosition );
        dragX = dragX > originBound ? ( dragX + originBound ) * 0.5 : dragX;
        var endBound = Math.min( -this.getLastSlide().target, this.dragStartPosition );
        dragX = dragX < endBound ? ( dragX + endBound ) * 0.5 : dragX;
      }

      this.dragX = dragX;

      this.dragMoveTime = new Date();
      this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );
    };

    proto.dragEnd = function( event, pointer ) {
      if ( !this.isDraggable ) {
        return;
      }
      if ( this.options.freeScroll ) {
        this.isFreeScrolling = true;
      }
      // set selectedIndex based on where flick will end up
      var index = this.dragEndRestingSelect();

      if ( this.options.freeScroll && !this.options.wrapAround ) {
        // if free-scroll & not wrap around
        // do not free-scroll if going outside of bounding slides
        // so bounding slides can attract slider, and keep it in bounds
        var restingX = this.getRestingPosition();
        this.isFreeScrolling = -restingX > this.slides[0].target &&
          -restingX < this.getLastSlide().target;
      } else if ( !this.options.freeScroll && index == this.selectedIndex ) {
        // boost selection if selected index has not changed
        index += this.dragEndBoostSelect();
      }
      delete this.previousDragX;
      // apply selection
      // TODO refactor this, selecting here feels weird
      // HACK, set flag so dragging stays in correct direction
      this.isDragSelect = this.options.wrapAround;
      this.select( index );
      delete this.isDragSelect;
      this.dispatchEvent( 'dragEnd', event, [ pointer ] );
    };

    proto.dragEndRestingSelect = function() {
      var restingX = this.getRestingPosition();
      // how far away from selected slide
      var distance = Math.abs( this.getSlideDistance( -restingX, this.selectedIndex ) );
      // get closet resting going up and going down
      var positiveResting = this._getClosestResting( restingX, distance, 1 );
      var negativeResting = this._getClosestResting( restingX, distance, -1 );
      // use closer resting for wrap-around
      var index = positiveResting.distance < negativeResting.distance ?
        positiveResting.index : negativeResting.index;
      return index;
    };

    /**
     * given resting X and distance to selected cell
     * get the distance and index of the closest cell
     * @param {Number} restingX - estimated post-flick resting position
     * @param {Number} distance - distance to selected cell
     * @param {Integer} increment - +1 or -1, going up or down
     * @returns {Object} - { distance: {Number}, index: {Integer} }
     */
    proto._getClosestResting = function( restingX, distance, increment ) {
      var index = this.selectedIndex;
      var minDistance = Infinity;
      var condition = this.options.contain && !this.options.wrapAround ?
        // if contain, keep going if distance is equal to minDistance
        function( d, md ) { return d <= md; } : function( d, md ) { return d < md; };
      while ( condition( distance, minDistance ) ) {
        // measure distance to next cell
        index += increment;
        minDistance = distance;
        distance = this.getSlideDistance( -restingX, index );
        if ( distance === null ) {
          break;
        }
        distance = Math.abs( distance );
      }
      return {
        distance: minDistance,
        // selected was previous index
        index: index - increment
      };
    };

    /**
     * measure distance between x and a slide target
     * @param {Number} x
     * @param {Integer} index - slide index
     */
    proto.getSlideDistance = function( x, index ) {
      var len = this.slides.length;
      // wrap around if at least 2 slides
      var isWrapAround = this.options.wrapAround && len > 1;
      var slideIndex = isWrapAround ? utils.modulo( index, len ) : index;
      var slide = this.slides[ slideIndex ];
      if ( !slide ) {
        return null;
      }
      // add distance for wrap-around slides
      var wrap = isWrapAround ? this.slideableWidth * Math.floor( index / len ) : 0;
      return x - ( slide.target + wrap );
    };

    proto.dragEndBoostSelect = function() {
      // do not boost if no previousDragX or dragMoveTime
      if ( this.previousDragX === undefined || !this.dragMoveTime ||
        // or if drag was held for 100 ms
        new Date() - this.dragMoveTime > 100 ) {
        return 0;
      }

      var distance = this.getSlideDistance( -this.dragX, this.selectedIndex );
      var delta = this.previousDragX - this.dragX;
      if ( distance > 0 && delta > 0 ) {
        // boost to next if moving towards the right, and positive velocity
        return 1;
      } else if ( distance < 0 && delta < 0 ) {
        // boost to previous if moving towards the left, and negative velocity
        return -1;
      }
      return 0;
    };

    // ----- staticClick ----- //

    proto.staticClick = function( event, pointer ) {
      // get clickedCell, if cell was clicked
      var clickedCell = this.getParentCell( event.target );
      var cellElem = clickedCell && clickedCell.element;
      var cellIndex = clickedCell && this.cells.indexOf( clickedCell );
      this.dispatchEvent( 'staticClick', event, [ pointer, cellElem, cellIndex ] );
    };

    // ----- scroll ----- //

    proto.onscroll = function() {
      var scroll = getScrollPosition();
      var scrollMoveX = this.pointerDownScroll.x - scroll.x;
      var scrollMoveY = this.pointerDownScroll.y - scroll.y;
      // cancel click/tap if scroll is too much
      if ( Math.abs( scrollMoveX ) > 3 || Math.abs( scrollMoveY ) > 3 ) {
        this._pointerDone();
      }
    };

    // ----- utils ----- //

    function getScrollPosition() {
      return {
        x: window.pageXOffset,
        y: window.pageYOffset
      };
    }

    // -----  ----- //

    return Flickity;

    }));
    });

    var prevNextButton = createCommonjsModule(function (module) {
    // prev/next buttons
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          flickity,
          unipointer,
          utils
        );
      } else {
        // browser global
        factory(
          window,
          window.Flickity,
          window.Unipointer,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( window, Flickity, Unipointer, utils ) {

    var svgURI = 'http://www.w3.org/2000/svg';

    // -------------------------- PrevNextButton -------------------------- //

    function PrevNextButton( direction, parent ) {
      this.direction = direction;
      this.parent = parent;
      this._create();
    }

    PrevNextButton.prototype = Object.create( Unipointer.prototype );

    PrevNextButton.prototype._create = function() {
      // properties
      this.isEnabled = true;
      this.isPrevious = this.direction == -1;
      var leftDirection = this.parent.options.rightToLeft ? 1 : -1;
      this.isLeft = this.direction == leftDirection;

      var element = this.element = document.createElement('button');
      element.className = 'flickity-button flickity-prev-next-button';
      element.className += this.isPrevious ? ' previous' : ' next';
      // prevent button from submitting form http://stackoverflow.com/a/10836076/182183
      element.setAttribute( 'type', 'button' );
      // init as disabled
      this.disable();

      element.setAttribute( 'aria-label', this.isPrevious ? 'Previous' : 'Next' );

      // create arrow
      var svg = this.createSVG();
      element.appendChild( svg );
      // events
      this.parent.on( 'select', this.update.bind( this ) );
      this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );
    };

    PrevNextButton.prototype.activate = function() {
      this.bindStartEvent( this.element );
      this.element.addEventListener( 'click', this );
      // add to DOM
      this.parent.element.appendChild( this.element );
    };

    PrevNextButton.prototype.deactivate = function() {
      // remove from DOM
      this.parent.element.removeChild( this.element );
      // click events
      this.unbindStartEvent( this.element );
      this.element.removeEventListener( 'click', this );
    };

    PrevNextButton.prototype.createSVG = function() {
      var svg = document.createElementNS( svgURI, 'svg');
      svg.setAttribute( 'class', 'flickity-button-icon' );
      svg.setAttribute( 'viewBox', '0 0 100 100' );
      var path = document.createElementNS( svgURI, 'path');
      var pathMovements = getArrowMovements( this.parent.options.arrowShape );
      path.setAttribute( 'd', pathMovements );
      path.setAttribute( 'class', 'arrow' );
      // rotate arrow
      if ( !this.isLeft ) {
        path.setAttribute( 'transform', 'translate(100, 100) rotate(180) ' );
      }
      svg.appendChild( path );
      return svg;
    };

    // get SVG path movmement
    function getArrowMovements( shape ) {
      // use shape as movement if string
      if ( typeof shape == 'string' ) {
        return shape;
      }
      // create movement string
      return 'M ' + shape.x0 + ',50' +
        ' L ' + shape.x1 + ',' + ( shape.y1 + 50 ) +
        ' L ' + shape.x2 + ',' + ( shape.y2 + 50 ) +
        ' L ' + shape.x3 + ',50 ' +
        ' L ' + shape.x2 + ',' + ( 50 - shape.y2 ) +
        ' L ' + shape.x1 + ',' + ( 50 - shape.y1 ) +
        ' Z';
    }

    PrevNextButton.prototype.handleEvent = utils.handleEvent;

    PrevNextButton.prototype.onclick = function() {
      if ( !this.isEnabled ) {
        return;
      }
      this.parent.uiChange();
      var method = this.isPrevious ? 'previous' : 'next';
      this.parent[ method ]();
    };

    // -----  ----- //

    PrevNextButton.prototype.enable = function() {
      if ( this.isEnabled ) {
        return;
      }
      this.element.disabled = false;
      this.isEnabled = true;
    };

    PrevNextButton.prototype.disable = function() {
      if ( !this.isEnabled ) {
        return;
      }
      this.element.disabled = true;
      this.isEnabled = false;
    };

    PrevNextButton.prototype.update = function() {
      // index of first or last slide, if previous or next
      var slides = this.parent.slides;
      // enable is wrapAround and at least 2 slides
      if ( this.parent.options.wrapAround && slides.length > 1 ) {
        this.enable();
        return;
      }
      var lastIndex = slides.length ? slides.length - 1 : 0;
      var boundIndex = this.isPrevious ? 0 : lastIndex;
      var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';
      this[ method ]();
    };

    PrevNextButton.prototype.destroy = function() {
      this.deactivate();
      this.allOff();
    };

    // -------------------------- Flickity prototype -------------------------- //

    utils.extend( Flickity.defaults, {
      prevNextButtons: true,
      arrowShape: {
        x0: 10,
        x1: 60, y1: 50,
        x2: 70, y2: 40,
        x3: 30
      }
    });

    Flickity.createMethods.push('_createPrevNextButtons');
    var proto = Flickity.prototype;

    proto._createPrevNextButtons = function() {
      if ( !this.options.prevNextButtons ) {
        return;
      }

      this.prevButton = new PrevNextButton( -1, this );
      this.nextButton = new PrevNextButton( 1, this );

      this.on( 'activate', this.activatePrevNextButtons );
    };

    proto.activatePrevNextButtons = function() {
      this.prevButton.activate();
      this.nextButton.activate();
      this.on( 'deactivate', this.deactivatePrevNextButtons );
    };

    proto.deactivatePrevNextButtons = function() {
      this.prevButton.deactivate();
      this.nextButton.deactivate();
      this.off( 'deactivate', this.deactivatePrevNextButtons );
    };

    // --------------------------  -------------------------- //

    Flickity.PrevNextButton = PrevNextButton;

    return Flickity;

    }));
    });

    var pageDots = createCommonjsModule(function (module) {
    // page dots
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          flickity,
          unipointer,
          utils
        );
      } else {
        // browser global
        factory(
          window,
          window.Flickity,
          window.Unipointer,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( window, Flickity, Unipointer, utils ) {

    function PageDots( parent ) {
      this.parent = parent;
      this._create();
    }

    PageDots.prototype = Object.create( Unipointer.prototype );

    PageDots.prototype._create = function() {
      // create holder element
      this.holder = document.createElement('ol');
      this.holder.className = 'flickity-page-dots';
      // create dots, array of elements
      this.dots = [];
      // events
      this.handleClick = this.onClick.bind( this );
      this.on( 'pointerDown', this.parent.childUIPointerDown.bind( this.parent ) );
    };

    PageDots.prototype.activate = function() {
      this.setDots();
      this.holder.addEventListener( 'click', this.handleClick );
      this.bindStartEvent( this.holder );
      // add to DOM
      this.parent.element.appendChild( this.holder );
    };

    PageDots.prototype.deactivate = function() {
      this.holder.removeEventListener( 'click', this.handleClick );
      this.unbindStartEvent( this.holder );
      // remove from DOM
      this.parent.element.removeChild( this.holder );
    };

    PageDots.prototype.setDots = function() {
      // get difference between number of slides and number of dots
      var delta = this.parent.slides.length - this.dots.length;
      if ( delta > 0 ) {
        this.addDots( delta );
      } else if ( delta < 0 ) {
        this.removeDots( -delta );
      }
    };

    PageDots.prototype.addDots = function( count ) {
      var fragment = document.createDocumentFragment();
      var newDots = [];
      var length = this.dots.length;
      var max = length + count;

      for ( var i = length; i < max; i++ ) {
        var dot = document.createElement('li');
        dot.className = 'dot';
        dot.setAttribute( 'aria-label', 'Page dot ' + ( i + 1 ) );
        fragment.appendChild( dot );
        newDots.push( dot );
      }

      this.holder.appendChild( fragment );
      this.dots = this.dots.concat( newDots );
    };

    PageDots.prototype.removeDots = function( count ) {
      // remove from this.dots collection
      var removeDots = this.dots.splice( this.dots.length - count, count );
      // remove from DOM
      removeDots.forEach( function( dot ) {
        this.holder.removeChild( dot );
      }, this );
    };

    PageDots.prototype.updateSelected = function() {
      // remove selected class on previous
      if ( this.selectedDot ) {
        this.selectedDot.className = 'dot';
        this.selectedDot.removeAttribute('aria-current');
      }
      // don't proceed if no dots
      if ( !this.dots.length ) {
        return;
      }
      this.selectedDot = this.dots[ this.parent.selectedIndex ];
      this.selectedDot.className = 'dot is-selected';
      this.selectedDot.setAttribute( 'aria-current', 'step' );
    };

    PageDots.prototype.onTap = // old method name, backwards-compatible
    PageDots.prototype.onClick = function( event ) {
      var target = event.target;
      // only care about dot clicks
      if ( target.nodeName != 'LI' ) {
        return;
      }

      this.parent.uiChange();
      var index = this.dots.indexOf( target );
      this.parent.select( index );
    };

    PageDots.prototype.destroy = function() {
      this.deactivate();
      this.allOff();
    };

    Flickity.PageDots = PageDots;

    // -------------------------- Flickity -------------------------- //

    utils.extend( Flickity.defaults, {
      pageDots: true
    });

    Flickity.createMethods.push('_createPageDots');

    var proto = Flickity.prototype;

    proto._createPageDots = function() {
      if ( !this.options.pageDots ) {
        return;
      }
      this.pageDots = new PageDots( this );
      // events
      this.on( 'activate', this.activatePageDots );
      this.on( 'select', this.updateSelectedPageDots );
      this.on( 'cellChange', this.updatePageDots );
      this.on( 'resize', this.updatePageDots );
      this.on( 'deactivate', this.deactivatePageDots );
    };

    proto.activatePageDots = function() {
      this.pageDots.activate();
    };

    proto.updateSelectedPageDots = function() {
      this.pageDots.updateSelected();
    };

    proto.updatePageDots = function() {
      this.pageDots.setDots();
    };

    proto.deactivatePageDots = function() {
      this.pageDots.deactivate();
    };

    // -----  ----- //

    Flickity.PageDots = PageDots;

    return Flickity;

    }));
    });

    var player = createCommonjsModule(function (module) {
    // player & autoPlay
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          evEmitter,
          utils,
          flickity
        );
      } else {
        // browser global
        factory(
          window.EvEmitter,
          window.fizzyUIUtils,
          window.Flickity
        );
      }

    }( window, function factory( EvEmitter, utils, Flickity ) {

    // -------------------------- Player -------------------------- //

    function Player( parent ) {
      this.parent = parent;
      this.state = 'stopped';
      // visibility change event handler
      this.onVisibilityChange = this.visibilityChange.bind( this );
      this.onVisibilityPlay = this.visibilityPlay.bind( this );
    }

    Player.prototype = Object.create( EvEmitter.prototype );

    // start play
    Player.prototype.play = function() {
      if ( this.state == 'playing' ) {
        return;
      }
      // do not play if page is hidden, start playing when page is visible
      var isPageHidden = document.hidden;
      if ( isPageHidden ) {
        document.addEventListener( 'visibilitychange', this.onVisibilityPlay );
        return;
      }

      this.state = 'playing';
      // listen to visibility change
      document.addEventListener( 'visibilitychange', this.onVisibilityChange );
      // start ticking
      this.tick();
    };

    Player.prototype.tick = function() {
      // do not tick if not playing
      if ( this.state != 'playing' ) {
        return;
      }

      var time = this.parent.options.autoPlay;
      // default to 3 seconds
      time = typeof time == 'number' ? time : 3000;
      var _this = this;
      // HACK: reset ticks if stopped and started within interval
      this.clear();
      this.timeout = setTimeout( function() {
        _this.parent.next( true );
        _this.tick();
      }, time );
    };

    Player.prototype.stop = function() {
      this.state = 'stopped';
      this.clear();
      // remove visibility change event
      document.removeEventListener( 'visibilitychange', this.onVisibilityChange );
    };

    Player.prototype.clear = function() {
      clearTimeout( this.timeout );
    };

    Player.prototype.pause = function() {
      if ( this.state == 'playing' ) {
        this.state = 'paused';
        this.clear();
      }
    };

    Player.prototype.unpause = function() {
      // re-start play if paused
      if ( this.state == 'paused' ) {
        this.play();
      }
    };

    // pause if page visibility is hidden, unpause if visible
    Player.prototype.visibilityChange = function() {
      var isPageHidden = document.hidden;
      this[ isPageHidden ? 'pause' : 'unpause' ]();
    };

    Player.prototype.visibilityPlay = function() {
      this.play();
      document.removeEventListener( 'visibilitychange', this.onVisibilityPlay );
    };

    // -------------------------- Flickity -------------------------- //

    utils.extend( Flickity.defaults, {
      pauseAutoPlayOnHover: true
    });

    Flickity.createMethods.push('_createPlayer');
    var proto = Flickity.prototype;

    proto._createPlayer = function() {
      this.player = new Player( this );

      this.on( 'activate', this.activatePlayer );
      this.on( 'uiChange', this.stopPlayer );
      this.on( 'pointerDown', this.stopPlayer );
      this.on( 'deactivate', this.deactivatePlayer );
    };

    proto.activatePlayer = function() {
      if ( !this.options.autoPlay ) {
        return;
      }
      this.player.play();
      this.element.addEventListener( 'mouseenter', this );
    };

    // Player API, don't hate the ... thanks I know where the door is

    proto.playPlayer = function() {
      this.player.play();
    };

    proto.stopPlayer = function() {
      this.player.stop();
    };

    proto.pausePlayer = function() {
      this.player.pause();
    };

    proto.unpausePlayer = function() {
      this.player.unpause();
    };

    proto.deactivatePlayer = function() {
      this.player.stop();
      this.element.removeEventListener( 'mouseenter', this );
    };

    // ----- mouseenter/leave ----- //

    // pause auto-play on hover
    proto.onmouseenter = function() {
      if ( !this.options.pauseAutoPlayOnHover ) {
        return;
      }
      this.player.pause();
      this.element.addEventListener( 'mouseleave', this );
    };

    // resume auto-play on hover off
    proto.onmouseleave = function() {
      this.player.unpause();
      this.element.removeEventListener( 'mouseleave', this );
    };

    // -----  ----- //

    Flickity.Player = Player;

    return Flickity;

    }));
    });

    var addRemoveCell = createCommonjsModule(function (module) {
    // add, remove cell
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          flickity,
          utils
        );
      } else {
        // browser global
        factory(
          window,
          window.Flickity,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( window, Flickity, utils ) {

    // append cells to a document fragment
    function getCellsFragment( cells ) {
      var fragment = document.createDocumentFragment();
      cells.forEach( function( cell ) {
        fragment.appendChild( cell.element );
      });
      return fragment;
    }

    // -------------------------- add/remove cell prototype -------------------------- //

    var proto = Flickity.prototype;

    /**
     * Insert, prepend, or append cells
     * @param {Element, Array, NodeList} elems
     * @param {Integer} index
     */
    proto.insert = function( elems, index ) {
      var cells = this._makeCells( elems );
      if ( !cells || !cells.length ) {
        return;
      }
      var len = this.cells.length;
      // default to append
      index = index === undefined ? len : index;
      // add cells with document fragment
      var fragment = getCellsFragment( cells );
      // append to slider
      var isAppend = index == len;
      if ( isAppend ) {
        this.slider.appendChild( fragment );
      } else {
        var insertCellElement = this.cells[ index ].element;
        this.slider.insertBefore( fragment, insertCellElement );
      }
      // add to this.cells
      if ( index === 0 ) {
        // prepend, add to start
        this.cells = cells.concat( this.cells );
      } else if ( isAppend ) {
        // append, add to end
        this.cells = this.cells.concat( cells );
      } else {
        // insert in this.cells
        var endCells = this.cells.splice( index, len - index );
        this.cells = this.cells.concat( cells ).concat( endCells );
      }

      this._sizeCells( cells );
      this.cellChange( index, true );
    };

    proto.append = function( elems ) {
      this.insert( elems, this.cells.length );
    };

    proto.prepend = function( elems ) {
      this.insert( elems, 0 );
    };

    /**
     * Remove cells
     * @param {Element, Array, NodeList} elems
     */
    proto.remove = function( elems ) {
      var cells = this.getCells( elems );
      if ( !cells || !cells.length ) {
        return;
      }

      var minCellIndex = this.cells.length - 1;
      // remove cells from collection & DOM
      cells.forEach( function( cell ) {
        cell.remove();
        var index = this.cells.indexOf( cell );
        minCellIndex = Math.min( index, minCellIndex );
        utils.removeFrom( this.cells, cell );
      }, this );

      this.cellChange( minCellIndex, true );
    };

    /**
     * logic to be run after a cell's size changes
     * @param {Element} elem - cell's element
     */
    proto.cellSizeChange = function( elem ) {
      var cell = this.getCell( elem );
      if ( !cell ) {
        return;
      }
      cell.getSize();

      var index = this.cells.indexOf( cell );
      this.cellChange( index );
    };

    /**
     * logic any time a cell is changed: added, removed, or size changed
     * @param {Integer} changedCellIndex - index of the changed cell, optional
     */
    proto.cellChange = function( changedCellIndex, isPositioningSlider ) {
      var prevSelectedElem = this.selectedElement;
      this._positionCells( changedCellIndex );
      this._getWrapShiftCells();
      this.setGallerySize();
      // update selectedIndex
      // try to maintain position & select previous selected element
      var cell = this.getCell( prevSelectedElem );
      if ( cell ) {
        this.selectedIndex = this.getCellSlideIndex( cell );
      }
      this.selectedIndex = Math.min( this.slides.length - 1, this.selectedIndex );

      this.emitEvent( 'cellChange', [ changedCellIndex ] );
      // position slider
      this.select( this.selectedIndex );
      // do not position slider after lazy load
      if ( isPositioningSlider ) {
        this.positionSliderAtSelected();
      }
    };

    // -----  ----- //

    return Flickity;

    }));
    });

    var lazyload = createCommonjsModule(function (module) {
    // lazyload
    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          flickity,
          utils
        );
      } else {
        // browser global
        factory(
          window,
          window.Flickity,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( window, Flickity, utils ) {

    Flickity.createMethods.push('_createLazyload');
    var proto = Flickity.prototype;

    proto._createLazyload = function() {
      this.on( 'select', this.lazyLoad );
    };

    proto.lazyLoad = function() {
      var lazyLoad = this.options.lazyLoad;
      if ( !lazyLoad ) {
        return;
      }
      // get adjacent cells, use lazyLoad option for adjacent count
      var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
      var cellElems = this.getAdjacentCellElements( adjCount );
      // get lazy images in those cells
      var lazyImages = [];
      cellElems.forEach( function( cellElem ) {
        var lazyCellImages = getCellLazyImages( cellElem );
        lazyImages = lazyImages.concat( lazyCellImages );
      });
      // load lazy images
      lazyImages.forEach( function( img ) {
        new LazyLoader( img, this );
      }, this );
    };

    function getCellLazyImages( cellElem ) {
      // check if cell element is lazy image
      if ( cellElem.nodeName == 'IMG' ) {
        var lazyloadAttr = cellElem.getAttribute('data-flickity-lazyload');
        var srcAttr = cellElem.getAttribute('data-flickity-lazyload-src');
        var srcsetAttr = cellElem.getAttribute('data-flickity-lazyload-srcset');
        if ( lazyloadAttr || srcAttr || srcsetAttr ) {
          return [ cellElem ];
        }
      }
      // select lazy images in cell
      var lazySelector = 'img[data-flickity-lazyload], ' +
        'img[data-flickity-lazyload-src], img[data-flickity-lazyload-srcset]';
      var imgs = cellElem.querySelectorAll( lazySelector );
      return utils.makeArray( imgs );
    }

    // -------------------------- LazyLoader -------------------------- //

    /**
     * class to handle loading images
     */
    function LazyLoader( img, flickity ) {
      this.img = img;
      this.flickity = flickity;
      this.load();
    }

    LazyLoader.prototype.handleEvent = utils.handleEvent;

    LazyLoader.prototype.load = function() {
      this.img.addEventListener( 'load', this );
      this.img.addEventListener( 'error', this );
      // get src & srcset
      var src = this.img.getAttribute('data-flickity-lazyload') ||
        this.img.getAttribute('data-flickity-lazyload-src');
      var srcset = this.img.getAttribute('data-flickity-lazyload-srcset');
      // set src & serset
      this.img.src = src;
      if ( srcset ) {
        this.img.setAttribute( 'srcset', srcset );
      }
      // remove attr
      this.img.removeAttribute('data-flickity-lazyload');
      this.img.removeAttribute('data-flickity-lazyload-src');
      this.img.removeAttribute('data-flickity-lazyload-srcset');
    };

    LazyLoader.prototype.onload = function( event ) {
      this.complete( event, 'flickity-lazyloaded' );
    };

    LazyLoader.prototype.onerror = function( event ) {
      this.complete( event, 'flickity-lazyerror' );
    };

    LazyLoader.prototype.complete = function( event, className ) {
      // unbind events
      this.img.removeEventListener( 'load', this );
      this.img.removeEventListener( 'error', this );

      var cell = this.flickity.getParentCell( this.img );
      var cellElem = cell && cell.element;
      this.flickity.cellSizeChange( cellElem );

      this.img.classList.add( className );
      this.flickity.dispatchEvent( 'lazyLoad', event, cellElem );
    };

    // -----  ----- //

    Flickity.LazyLoader = LazyLoader;

    return Flickity;

    }));
    });

    var js = createCommonjsModule(function (module) {
    /*!
     * Flickity v2.2.1
     * Touch, responsive, flickable carousels
     *
     * Licensed GPLv3 for open source use
     * or Flickity Commercial License for commercial use
     *
     * https://flickity.metafizzy.co
     * Copyright 2015-2019 Metafizzy
     */

    ( function( window, factory ) {
      // universal module definition
      /* jshint strict: false */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          flickity,
          drag,
          prevNextButton,
          pageDots,
          player,
          addRemoveCell,
          lazyload
        );
      }

    })( window, function factory( Flickity ) {
      /*jshint strict: false*/
      return Flickity;
    });
    });

    /* src/Components/ScrollList.svelte generated by Svelte v3.35.0 */

    const file$n = "src/Components/ScrollList.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (172:4) {#each tagArray as t}
    function create_each_block$8(ctx) {
    	let div;
    	let span;
    	let t0_value = /*t*/ ctx[7].title + "";
    	let t0;
    	let t1;
    	let div_data_tag_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(span, "class", "taxonomy__item taxonomy-scroller__link svelte-juoz8m");
    			toggle_class(span, "active", /*t*/ ctx[7].slug === /*$activeQuery*/ ctx[3]);
    			add_location(span, file$n, 173, 8, 4237);
    			attr_dev(div, "data-tag", div_data_tag_value = /*t*/ ctx[7].slug);
    			attr_dev(div, "class", "carousel-cell taxonomy-scroller__slide svelte-juoz8m");
    			add_location(div, file$n, 172, 6, 4158);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tagArray*/ 1 && t0_value !== (t0_value = /*t*/ ctx[7].title + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*tagArray, $activeQuery*/ 9) {
    				toggle_class(span, "active", /*t*/ ctx[7].slug === /*$activeQuery*/ ctx[3]);
    			}

    			if (dirty & /*tagArray*/ 1 && div_data_tag_value !== (div_data_tag_value = /*t*/ ctx[7].slug)) {
    				attr_dev(div, "data-tag", div_data_tag_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(172:4) {#each tagArray as t}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div1;
    	let div0;
    	let each_value = /*tagArray*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "main-carousel taxonomy-scroller__slideshow\n    taxonomy-scroller__slideshow--large svelte-juoz8m");
    			toggle_class(div0, "loaded", /*loaded*/ ctx[2]);
    			add_location(div0, file$n, 166, 2, 3979);
    			attr_dev(div1, "class", "taxonomy-scroller svelte-juoz8m");
    			add_location(div1, file$n, 165, 0, 3945);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div0_binding*/ ctx[4](div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tagArray, $activeQuery*/ 9) {
    				each_value = /*tagArray*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*loaded*/ 4) {
    				toggle_class(div0, "loaded", /*loaded*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			/*div0_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $activeCategory;
    	let $activeQuery;
    	validate_store(activeCategory, "activeCategory");
    	component_subscribe($$self, activeCategory, $$value => $$invalidate(5, $activeCategory = $$value));
    	validate_store(activeQuery, "activeQuery");
    	component_subscribe($$self, activeQuery, $$value => $$invalidate(3, $activeQuery = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ScrollList", slots, []);
    	let { tagArray = [] } = $$props;

    	// *** DOM REFERENCES
    	let scrollListEl;

    	let loaded = false;

    	// TODO: change speed for mobile
    	const startTicker = function () {
    		// Play with this value to change the speed
    		let tickerSpeed = 0.7;

    		let flickity = null;
    		let isPaused = true;

    		const update = () => {
    			if (isPaused) return;

    			if (flickity.slides) {
    				flickity.x = (flickity.x - tickerSpeed) % flickity.slideableWidth;
    				flickity.selectedIndex = flickity.dragEndRestingSelect();
    				flickity.updateSelectedSlide();
    				flickity.settle(flickity.x);
    			}

    			window.requestAnimationFrame(update);
    		};

    		const pause = () => {
    			isPaused = true;
    		};

    		const play = () => {
    			if (isPaused) {
    				isPaused = false;
    				window.requestAnimationFrame(update);
    			}
    		};

    		let options = {
    			wrapAround: true,
    			autoPlay: false,
    			draggable: true,
    			prevNextButtons: false,
    			pageDots: false,
    			// selectedAttraction: 0.025,
    			freeScrollFriction: 0.03
    		}; // friction: 0.85

    		try {
    			flickity = new js(scrollListEl, options);
    		} catch(err) {
    			Sentry.captureException(err);
    		}

    		flickity.x = 0;
    		scrollListEl.addEventListener("mouseenter", pause, false);
    		scrollListEl.addEventListener("focusin", pause, false);
    		scrollListEl.addEventListener("mouseleave", play, false);
    		scrollListEl.addEventListener("focusout", play, false);

    		flickity.on("dragStart", () => {
    			isPaused = true;
    		});

    		flickity.on("staticClick", function (event, pointer, cellElement, cellIndex) {
    			navigate("/" + $activeCategory + "/category/" + cellElement.dataset.tag);
    		});

    		play();

    		setTimeout(
    			() => {
    				$$invalidate(2, loaded = true);
    			},
    			500
    		);
    	};

    	// *** ON MOUNT
    	onMount(async () => {
    		await tick();
    		startTicker();
    	});

    	const writable_props = ["tagArray"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ScrollList> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			scrollListEl = $$value;
    			$$invalidate(1, scrollListEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("tagArray" in $$props) $$invalidate(0, tagArray = $$props.tagArray);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		scale,
    		Flickity: js,
    		navigate,
    		activeQuery,
    		activeCategory,
    		tagArray,
    		scrollListEl,
    		loaded,
    		startTicker,
    		$activeCategory,
    		$activeQuery
    	});

    	$$self.$inject_state = $$props => {
    		if ("tagArray" in $$props) $$invalidate(0, tagArray = $$props.tagArray);
    		if ("scrollListEl" in $$props) $$invalidate(1, scrollListEl = $$props.scrollListEl);
    		if ("loaded" in $$props) $$invalidate(2, loaded = $$props.loaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [tagArray, scrollListEl, loaded, $activeQuery, div0_binding];
    }

    class ScrollList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { tagArray: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ScrollList",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get tagArray() {
    		throw new Error("<ScrollList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tagArray(value) {
    		throw new Error("<ScrollList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/NewsletterSignUp.svelte generated by Svelte v3.35.0 */

    const { console: console_1$5 } = globals;
    const file$m = "src/Components/NewsletterSignUp.svelte";

    // (140:2) {:else}
    function create_else_block$6(ctx) {
    	let form;
    	let t0;
    	let div0;
    	let input0;
    	let t1;
    	let div1;
    	let input1;
    	let t2;
    	let div2;
    	let input2;
    	let t3;
    	let div3;
    	let input3;
    	let t4;
    	let div5;
    	let div4;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*compact*/ ctx[0]) return create_if_block_1$c;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			form = element("form");
    			if_block.c();
    			t0 = space();
    			div0 = element("div");
    			input0 = element("input");
    			t1 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t2 = space();
    			div2 = element("div");
    			input2 = element("input");
    			t3 = space();
    			div3 = element("div");
    			input3 = element("input");
    			t4 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div4.textContent = "Sign up";
    			attr_dev(input0, "name", "email_first_name");
    			attr_dev(input0, "placeholder", "FIRST NAME");
    			attr_dev(input0, "class", "mailing-list__input svelte-yf2ls4");
    			add_location(input0, file$m, 149, 8, 3853);
    			attr_dev(div0, "class", "form-section svelte-yf2ls4");
    			add_location(div0, file$m, 148, 6, 3818);
    			attr_dev(input1, "name", "email_last_name");
    			attr_dev(input1, "placeholder", "LAST NAME");
    			attr_dev(input1, "class", "mailing-list__input svelte-yf2ls4");
    			add_location(input1, file$m, 157, 8, 4063);
    			attr_dev(div1, "class", "form-section svelte-yf2ls4");
    			add_location(div1, file$m, 156, 6, 4028);
    			attr_dev(input2, "name", "email_company");
    			attr_dev(input2, "placeholder", "COMPANY");
    			attr_dev(input2, "class", "mailing-list__input svelte-yf2ls4");
    			add_location(input2, file$m, 165, 8, 4270);
    			attr_dev(div2, "class", "form-section svelte-yf2ls4");
    			add_location(div2, file$m, 164, 6, 4235);
    			attr_dev(input3, "placeholder", "EMAIL ADDRESS");
    			attr_dev(input3, "class", "mailing-list__input svelte-yf2ls4");
    			add_location(input3, file$m, 174, 8, 4493);
    			attr_dev(div3, "class", "form-section svelte-yf2ls4");
    			add_location(div3, file$m, 173, 6, 4458);
    			attr_dev(div4, "class", "submit svelte-yf2ls4");
    			add_location(div4, file$m, 181, 8, 4684);
    			attr_dev(div5, "class", "form-section submit-button svelte-yf2ls4");
    			add_location(div5, file$m, 180, 6, 4635);
    			attr_dev(form, "class", "newsletter-signup svelte-yf2ls4");
    			toggle_class(form, "compact", /*compact*/ ctx[0]);
    			add_location(form, file$m, 140, 4, 3557);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			if_block.m(form, null);
    			append_dev(form, t0);
    			append_dev(form, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*emailFirstName*/ ctx[2]);
    			append_dev(form, t1);
    			append_dev(form, div1);
    			append_dev(div1, input1);
    			set_input_value(input1, /*emailLastName*/ ctx[3]);
    			append_dev(form, t2);
    			append_dev(form, div2);
    			append_dev(div2, input2);
    			set_input_value(input2, /*emailCompany*/ ctx[4]);
    			append_dev(form, t3);
    			append_dev(form, div3);
    			append_dev(div3, input3);
    			set_input_value(input3, /*emailAddress*/ ctx[1]);
    			append_dev(form, t4);
    			append_dev(form, div5);
    			append_dev(div5, div4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[9]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[10]),
    					listen_dev(div4, "click", /*submit*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(form, t0);
    				}
    			}

    			if (dirty & /*emailFirstName*/ 4 && input0.value !== /*emailFirstName*/ ctx[2]) {
    				set_input_value(input0, /*emailFirstName*/ ctx[2]);
    			}

    			if (dirty & /*emailLastName*/ 8 && input1.value !== /*emailLastName*/ ctx[3]) {
    				set_input_value(input1, /*emailLastName*/ ctx[3]);
    			}

    			if (dirty & /*emailCompany*/ 16 && input2.value !== /*emailCompany*/ ctx[4]) {
    				set_input_value(input2, /*emailCompany*/ ctx[4]);
    			}

    			if (dirty & /*emailAddress*/ 2 && input3.value !== /*emailAddress*/ ctx[1]) {
    				set_input_value(input3, /*emailAddress*/ ctx[1]);
    			}

    			if (dirty & /*compact*/ 1) {
    				toggle_class(form, "compact", /*compact*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(140:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (133:2) {#if success}
    function create_if_block$g(ctx) {
    	let span;
    	let strong;
    	let t1;
    	let br;
    	let t2;
    	let t3;
    	let t4;
    	let span_intro;

    	const block = {
    		c: function create() {
    			span = element("span");
    			strong = element("strong");
    			strong.textContent = "Thank you.";
    			t1 = space();
    			br = element("br");
    			t2 = text("\n      You will receive a sign up confirmation at the address ");
    			t3 = text(/*emailAddress*/ ctx[1]);
    			t4 = text("\n      shortly.");
    			attr_dev(strong, "class", "svelte-yf2ls4");
    			add_location(strong, file$m, 134, 6, 3399);
    			attr_dev(br, "class", "svelte-yf2ls4");
    			add_location(br, file$m, 135, 6, 3433);
    			attr_dev(span, "class", "svelte-yf2ls4");
    			add_location(span, file$m, 133, 4, 3378);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, strong);
    			append_dev(span, t1);
    			append_dev(span, br);
    			append_dev(span, t2);
    			append_dev(span, t3);
    			append_dev(span, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*emailAddress*/ 2) set_data_dev(t3, /*emailAddress*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (!span_intro) {
    				add_render_callback(() => {
    					span_intro = create_in_transition(span, fade, {});
    					span_intro.start();
    				});
    			}
    		},
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(133:2) {#if success}",
    		ctx
    	});

    	return block;
    }

    // (144:6) {:else}
    function create_else_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "NEWSLETTER";
    			attr_dev(div, "class", "form-section svelte-yf2ls4");
    			add_location(div, file$m, 144, 8, 3726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(144:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (142:6) {#if compact}
    function create_if_block_1$c(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Subscribe to our correspondence channel";
    			attr_dev(div, "class", "form-section svelte-yf2ls4");
    			add_location(div, file$m, 142, 8, 3632);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(142:6) {#if compact}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*success*/ ctx[5]) return create_if_block$g;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "id", "mailing-list");
    			attr_dev(div, "class", "mailing-list svelte-yf2ls4");
    			toggle_class(div, "compact", /*compact*/ ctx[0]);
    			add_location(div, file$m, 131, 0, 3299);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			}

    			if (dirty & /*compact*/ 1) {
    				toggle_class(div, "compact", /*compact*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			transition_in(if_block);
    		},
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NewsletterSignUp", slots, []);
    	let { compact = false } = $$props;

    	// VARIABLES
    	let emailAddress = "";

    	let emailFirstName = "";
    	let emailLastName = "";
    	let emailCompany = "";
    	let success = false;

    	// LOGIC
    	const submit = () => {
    		const url = "https://novembre.global/.netlify/functions/signup?email=" + encodeURIComponent(emailAddress) + "&firstname=" + encodeURIComponent(emailFirstName) + "&lastname=" + encodeURIComponent(emailLastName) + "&company=" + encodeURIComponent(emailCompany);

    		fetch(url).then(function (response) {
    			console.log(response);
    			$$invalidate(5, success = true);
    		}).catch(err => {
    			console.error(err);
    			Sentry.captureException(err);
    		});
    	};

    	const writable_props = ["compact"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<NewsletterSignUp> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		emailFirstName = this.value;
    		$$invalidate(2, emailFirstName);
    	}

    	function input1_input_handler() {
    		emailLastName = this.value;
    		$$invalidate(3, emailLastName);
    	}

    	function input2_input_handler() {
    		emailCompany = this.value;
    		$$invalidate(4, emailCompany);
    	}

    	function input3_input_handler() {
    		emailAddress = this.value;
    		$$invalidate(1, emailAddress);
    	}

    	$$self.$$set = $$props => {
    		if ("compact" in $$props) $$invalidate(0, compact = $$props.compact);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		compact,
    		emailAddress,
    		emailFirstName,
    		emailLastName,
    		emailCompany,
    		success,
    		submit
    	});

    	$$self.$inject_state = $$props => {
    		if ("compact" in $$props) $$invalidate(0, compact = $$props.compact);
    		if ("emailAddress" in $$props) $$invalidate(1, emailAddress = $$props.emailAddress);
    		if ("emailFirstName" in $$props) $$invalidate(2, emailFirstName = $$props.emailFirstName);
    		if ("emailLastName" in $$props) $$invalidate(3, emailLastName = $$props.emailLastName);
    		if ("emailCompany" in $$props) $$invalidate(4, emailCompany = $$props.emailCompany);
    		if ("success" in $$props) $$invalidate(5, success = $$props.success);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		compact,
    		emailAddress,
    		emailFirstName,
    		emailLastName,
    		emailCompany,
    		success,
    		submit,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler
    	];
    }

    class NewsletterSignUp extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { compact: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NewsletterSignUp",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get compact() {
    		throw new Error("<NewsletterSignUp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set compact(value) {
    		throw new Error("<NewsletterSignUp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate$1(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - Now `isValid` doesn't throw an exception
     *   if the first argument is not an instance of Date.
     *   Instead, argument is converted beforehand using `toDate`.
     *
     *   Examples:
     *
     *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
     *   |---------------------------|---------------|---------------|
     *   | `new Date()`              | `true`        | `true`        |
     *   | `new Date('2016-01-01')`  | `true`        | `true`        |
     *   | `new Date('')`            | `false`       | `false`       |
     *   | `new Date(1488370835081)` | `true`        | `true`        |
     *   | `new Date(NaN)`           | `false`       | `false`       |
     *   | `'2016-01-01'`            | `TypeError`   | `false`       |
     *   | `''`                      | `TypeError`   | `false`       |
     *   | `1488370835081`           | `TypeError`   | `true`        |
     *   | `NaN`                     | `TypeError`   | `false`       |
     *
     *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
     *   that try to coerce arguments to the expected type
     *   (which is also the case with other *date-fns* functions).
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * var result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * var result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * var result = isValid(new Date(''))
     * //=> false
     */

    function isValid(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate$1(dirtyDate);
      return !isNaN(date);
    }

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };
    function formatDistance(token, count, options) {
      options = options || {};
      var result;

      if (typeof formatDistanceLocale[token] === 'string') {
        result = formatDistanceLocale[token];
      } else if (count === 1) {
        result = formatDistanceLocale[token].one;
      } else {
        result = formatDistanceLocale[token].other.replace('{{count}}', count);
      }

      if (options.addSuffix) {
        if (options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    }

    function buildFormatLongFn(args) {
      return function (dirtyOptions) {
        var options = dirtyOptions || {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };
    function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    }

    function buildLocalizeFn(args) {
      return function (dirtyIndex, dirtyOptions) {
        var options = dirtyOptions || {};
        var context = options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }

    var eraValues = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
      // If you are making a new locale based on this one, check if the same is true for the language you're working on.
      // Generally, formatted dates should look like they are in the middle of a sentence,
      // e.g. in Spanish language the weekdays and months should be in the lowercase.

    };
    var monthValues = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    function ordinalNumber(dirtyNumber, _dirtyOptions) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`:
      //
      //   var options = dirtyOptions || {}
      //   var unit = String(options.unit)
      //
      // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    }

    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };

    function buildMatchPatternFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var matchResult = string.match(args.matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);

        if (!parseResult) {
          return null;
        }

        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function buildMatchFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var value;

        if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
          value = findIndex(parsePatterns, function (pattern) {
            return pattern.test(matchedString);
          });
        } else {
          value = findKey(parsePatterns, function (pattern) {
            return pattern.test(matchedString);
          });
        }

        value = args.valueCallback ? args.valueCallback(value) : value;
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
    }

    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
    }

    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale = {
      code: 'en-US',
      formatDistance: formatDistance,
      formatLong: formatLong,
      formatRelative: formatRelative,
      localize: localize,
      match: match,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    function toInteger$1(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }

      var number = Number(dirtyNumber);

      if (isNaN(number)) {
        return number;
      }

      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */

    function addMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var timestamp = toDate$1(dirtyDate).getTime();
      var amount = toInteger$1(dirtyAmount);
      return new Date(timestamp + amount);
    }

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */

    function subMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger$1(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }

    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();

      while (output.length < targetLength) {
        output = '0' + output;
      }

      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */

    var formatters$1 = {
      // Year
      y: function (date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function (date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function (date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function (date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return dayPeriodEnumValue.toUpperCase();

          case 'aaa':
            return dayPeriodEnumValue;

          case 'aaaaa':
            return dayPeriodEnumValue[0];

          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function (date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function (date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function (date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function (date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function (date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };

    var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCDayOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate$1(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var weekStartsOn = 1;
      var date = toDate$1(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate$1(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate$1(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCWeek(dirtyDate, dirtyOptions) {
      requiredArgs(1, arguments);
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
      var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
      var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate$1(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCWeekYear(dirtyDate, dirtyOptions) {
      requiredArgs(1, arguments);
      var date = toDate$1(dirtyDate, dirtyOptions);
      var year = date.getUTCFullYear();
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
      requiredArgs(1, arguments);
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate);
      var year = getUTCWeekYear(dirtyDate, dirtyOptions);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, dirtyOptions);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate$1(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
      /*
       * |     | Unit                           |     | Unit                           |
       * |-----|--------------------------------|-----|--------------------------------|
       * |  a  | AM, PM                         |  A* | Milliseconds in day            |
       * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
       * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
       * |  d  | Day of month                   |  D  | Day of year                    |
       * |  e  | Local day of week              |  E  | Day of week                    |
       * |  f  |                                |  F* | Day of week in month           |
       * |  g* | Modified Julian day            |  G  | Era                            |
       * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
       * |  i! | ISO day of week                |  I! | ISO week of year               |
       * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
       * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
       * |  l* | (deprecated)                   |  L  | Stand-alone month              |
       * |  m  | Minute                         |  M  | Month                          |
       * |  n  |                                |  N  |                                |
       * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
       * |  p! | Long localized time            |  P! | Long localized date            |
       * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
       * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
       * |  s  | Second                         |  S  | Fraction of second             |
       * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
       * |  u  | Extended year                  |  U* | Cyclic year                    |
       * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
       * |  w  | Local week of year             |  W* | Week of month                  |
       * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
       * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
       * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
       *
       * Letters marked by * are not implemented but reserved by Unicode standard.
       *
       * Letters marked by ! are non-standard, but implemented by date-fns:
       * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
       * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
       *   i.e. 7 for Sunday, 1 for Monday, etc.
       * - `I` is ISO week of year, as opposed to `w` which is local week of year.
       * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
       *   `R` is supposed to be used in conjunction with `I` and `i`
       *   for universal ISO week-numbering date, whereas
       *   `Y` is supposed to be used in conjunction with `w` and `e`
       *   for week-numbering date specific to the locale.
       * - `P` is long localized date format
       * - `p` is long localized time format
       */

    };
    var formatters = {
      // Era
      G: function (date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;

        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B

          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function (date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }

        return formatters$1.y(date, token);
      },
      // Local week-numbering year
      Y: function (date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        } // Ordinal number


        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        } // Padding


        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function (date, token) {
        var isoWeekYear = getUTCISOWeekYear(date); // Padding

        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function (date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'QQ':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'qq':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          case 'M':
          case 'MM':
            return formatters$1.M(date, token);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12

          case 'LL':
            return addLeadingZeros(month + 1, 2);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function (date, token, localize, options) {
        var week = getUTCWeek(date, options);

        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }

        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function (date, token, localize) {
        var isoWeek = getUTCISOWeek(date);

        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }

        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function (date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }

        return formatters$1.d(date, token);
      },
      // Day of year
      D: function (date, token, localize) {
        var dayOfYear = getUTCDayOfYear(date);

        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }

        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();

        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'ee':
            return addLeadingZeros(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th

          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'cc':
            return addLeadingZeros(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th

          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02

          case 'ii':
            return addLeadingZeros(isoDayOfWeek, token.length);
          // 2nd

          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }

        switch (token) {
          case 'b':
          case 'bb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            }).toLowerCase();

          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }

        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function (date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return formatters$1.h(date, token);
      },
      // Hour [0-23]
      H: function (date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }

        return formatters$1.H(date, token);
      },
      // Hour [0-11]
      K: function (date, token, localize) {
        var hours = date.getUTCHours() % 12;

        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function (date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;

        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function (date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }

        return formatters$1.m(date, token);
      },
      // Second
      s: function (date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }

        return formatters$1.s(date, token);
      },
      // Fraction of second
      S: function (date, token) {
        return formatters$1.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        if (timezoneOffset === 0) {
          return 'Z';
        }

        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`

          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`

          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`

          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`

          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };

    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;

      if (minutes === 0) {
        return sign + String(hours);
      }

      var delimiter = dirtyDelimiter || '';
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }

    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }

      return formatTimezone(offset, dirtyDelimiter);
    }

    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    function dateLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });

        case 'PP':
          return formatLong.date({
            width: 'medium'
          });

        case 'PPP':
          return formatLong.date({
            width: 'long'
          });

        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    }

    function timeLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });

        case 'pp':
          return formatLong.time({
            width: 'medium'
          });

        case 'ppp':
          return formatLong.time({
            width: 'long'
          });

        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    }

    function dateTimeLongFormatter(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/);
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];

      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }

      var dateTimeFormat;

      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;

        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;

        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;

        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }

      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    }

    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };

    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */
    function getTimezoneOffsetInMilliseconds(date) {
      var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      utcDate.setUTCFullYear(date.getFullYear());
      return date.getTime() - utcDate.getTime();
    }

    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      }
    }

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://git.io/fxCyr
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | AM, PM                          | a..aa   | AM, PM                            |       |
     * |                                 | aaa     | am, pm                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
     * |                                 | bbb     | am, pm, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 0001, ..., 999               |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 04/29/1453                        | 7     |
     * |                                 | PP      | Apr 29, 1453                      | 7     |
     * |                                 | PPP     | April 29th, 1453                  | 7     |
     * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
     * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
     *
     * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - The second argument is now required for the sake of explicitness.
     *
     *   ```javascript
     *   // Before v2.0.0
     *   format(new Date(2016, 0, 1))
     *
     *   // v2.0.0 onward
     *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
     *   ```
     *
     * - New format string API for `format` function
     *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
     *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
     *
     * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://git.io/fxCyr
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://git.io/fxCyr
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format$1(dirtyDate, dirtyFormatStr, dirtyOptions) {
      requiredArgs(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var options = dirtyOptions || {};
      var locale$1 = options.locale || locale;
      var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger$1(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger$1(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
      var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger$1(localeWeekStartsOn);
      var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger$1(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (!locale$1.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale$1.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      var originalDate = toDate$1(dirtyDate);

      if (!isValid(originalDate)) {
        throw new RangeError('Invalid time value');
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale$1,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale$1.formatLong, formatterOptions);
        }

        return substring;
      }).join('').match(formattingTokensRegExp).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        var firstCharacter = substring[0];

        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }

        var formatter = formatters[firstCharacter];

        if (formatter) {
          if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, dirtyDate);
          }

          if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, dirtyDate);
          }

          return formatter(utcDate, substring, locale$1.localize, formatterOptions);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        return substring;
      }).join('');
      return result;
    }

    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }

    /**
     * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
     * `date` as it will be rendered in the `timeZone`.
     */
    function tzTokenizeDate(date, timeZone) {
      var dtf = getDateTimeFormat(timeZone);
      return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date)
    }

    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      second: 5,
    };

    function partsOffset(dtf, date) {
      var formatted = dtf.formatToParts(date);
      var filled = [];
      for (var i = 0; i < formatted.length; i++) {
        var pos = typeToPos[formatted[i].type];

        if (pos >= 0) {
          filled[pos] = parseInt(formatted[i].value, 10);
        }
      }
      return filled
    }

    function hackyOffset(dtf, date) {
      var formatted = dtf.format(date).replace(/\u200E/g, '');
      var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
      // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
      // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]
      return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]]
    }

    // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
    // to get deterministic local date/time output according to the `en-US` locale which
    // can be used to extract local time parts as necessary.
    var dtfCache = {};
    function getDateTimeFormat(timeZone) {
      if (!dtfCache[timeZone]) {
        // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
        var testDateFormatted = new Intl.DateTimeFormat('en-US', {
          hour12: false,
          timeZone: 'America/New_York',
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
        }).format(new Date('2014-06-25T04:00:00.123Z'));
        var hourCycleSupported =
          testDateFormatted === '06/25/2014, 00:00:00' ||
          testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';

        dtfCache[timeZone] = hourCycleSupported
          ? new Intl.DateTimeFormat('en-US', {
              hour12: false,
              timeZone: timeZone,
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
            })
          : new Intl.DateTimeFormat('en-US', {
              hourCycle: 'h23',
              timeZone: timeZone,
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
            });
      }
      return dtfCache[timeZone]
    }

    var MILLISECONDS_IN_HOUR$1 = 3600000;
    var MILLISECONDS_IN_MINUTE$1 = 60000;

    var patterns$1 = {
      timezone: /([Z+-].*)$/,
      timezoneZ: /^(Z)$/,
      timezoneHH: /^([+-])(\d{2})$/,
      timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
      timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_-]+(?:\/[a-zA-Z_]+)?))$/,
    };

    // Parse various time zone offset formats to an offset in milliseconds
    function tzParseTimezone(timezoneString, date, isUtcDate) {
      var token;
      var absoluteOffset;

      // Z
      token = patterns$1.timezoneZ.exec(timezoneString);
      if (token) {
        return 0
      }

      var hours;

      // ±hh
      token = patterns$1.timezoneHH.exec(timezoneString);
      if (token) {
        hours = parseInt(token[2], 10);

        if (!validateTimezone()) {
          return NaN
        }

        absoluteOffset = hours * MILLISECONDS_IN_HOUR$1;
        return token[1] === '+' ? -absoluteOffset : absoluteOffset
      }

      // ±hh:mm or ±hhmm
      token = patterns$1.timezoneHHMM.exec(timezoneString);
      if (token) {
        hours = parseInt(token[2], 10);
        var minutes = parseInt(token[3], 10);

        if (!validateTimezone(hours, minutes)) {
          return NaN
        }

        absoluteOffset = hours * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$1;
        return token[1] === '+' ? -absoluteOffset : absoluteOffset
      }

      // IANA time zone
      token = patterns$1.timezoneIANA.exec(timezoneString);
      if (token) {
        date = new Date(date || Date.now());
        var utcDate = isUtcDate ? date : toUtcDate(date);

        var offset = calcOffset(utcDate, timezoneString);

        var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);

        return -fixedOffset
      }

      return 0
    }

    function toUtcDate(date) {
      return new Date(
        Date.UTC(
          date.getFullYear(),
          date.getMonth(),
          date.getDate(),
          date.getHours(),
          date.getMinutes(),
          date.getSeconds(),
          date.getMilliseconds()
        )
      )
    }

    function calcOffset(date, timezoneString) {
      var [year, month, day, hour, minute, second] = tzTokenizeDate(date, timezoneString);

      var asUTC = Date.UTC(year, month - 1, day, hour % 24, minute, second);

      var asTS = date.getTime();
      var over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return asUTC - asTS
    }

    function fixOffset(date, offset, timezoneString) {
      var localTS = date.getTime();

      // Our UTC time is just a guess because our offset is just a guess
      var utcGuess = localTS - offset;

      // Test whether the zone matches the offset for this ts
      var o2 = calcOffset(new Date(utcGuess), timezoneString);

      // If so, offset didn't change and we're done
      if (offset === o2) {
        return offset
      }

      // If not, change the ts by the difference in the offset
      utcGuess -= o2 - offset;

      // If that gives us the local time we want, we're done
      var o3 = calcOffset(new Date(utcGuess), timezoneString);
      if (o2 === o3) {
        return o2
      }

      // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time
      return Math.max(o2, o3)
    }

    function validateTimezone(hours, minutes) {
      if (minutes != null && (minutes < 0 || minutes > 59)) {
        return false
      }

      return true
    }

    var MILLISECONDS_IN_HOUR = 3600000;
    var MILLISECONDS_IN_MINUTE = 60000;
    var DEFAULT_ADDITIONAL_DIGITS = 2;

    var patterns = {
      dateTimeDelimeter: /[T ]/,
      plainTime: /:/,
      timeZoneDelimeter: /[Z ]/i,

      // year tokens
      YY: /^(\d{2})$/,
      YYY: [
        /^([+-]\d{2})$/, // 0 additional digits
        /^([+-]\d{3})$/, // 1 additional digit
        /^([+-]\d{4})$/, // 2 additional digits
      ],
      YYYY: /^(\d{4})/,
      YYYYY: [
        /^([+-]\d{4})/, // 0 additional digits
        /^([+-]\d{5})/, // 1 additional digit
        /^([+-]\d{6})/, // 2 additional digits
      ],

      // date tokens
      MM: /^-(\d{2})$/,
      DDD: /^-?(\d{3})$/,
      MMDD: /^-?(\d{2})-?(\d{2})$/,
      Www: /^-?W(\d{2})$/,
      WwwD: /^-?W(\d{2})-?(\d{1})$/,

      HH: /^(\d{2}([.,]\d*)?)$/,
      HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
      HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,

      // timezone tokens (to identify the presence of a tz)
      timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/,
    };

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If an argument is a string, the function tries to parse it.
     * Function accepts complete ISO 8601 formats as well as partial implementations.
     * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
     * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
     *
     * @param {Date|String|Number} argument - the value to convert
     * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
     * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
     * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
     *
     * @example
     * // Convert string '2014-02-11T11:30:30' to date:
     * var result = toDate('2014-02-11T11:30:30')
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert string '+02014101' to date,
     * // if the additional number of digits in the extended year format is 1:
     * var result = toDate('+02014101', {additionalDigits: 1})
     * //=> Fri Apr 11 2014 00:00:00
     */
    function toDate(argument, dirtyOptions) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
      }

      if (argument === null) {
        return new Date(NaN)
      }

      var options = dirtyOptions || {};

      var additionalDigits =
        options.additionalDigits == null
          ? DEFAULT_ADDITIONAL_DIGITS
          : toInteger$1(options.additionalDigits);
      if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
        throw new RangeError('additionalDigits must be 0, 1 or 2')
      }

      // Clone the date
      if (
        argument instanceof Date ||
        (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')
      ) {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime())
      } else if (
        typeof argument === 'number' ||
        Object.prototype.toString.call(argument) === '[object Number]'
      ) {
        return new Date(argument)
      } else if (
        !(
          typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]'
        )
      ) {
        return new Date(NaN)
      }

      var dateStrings = splitDateString(argument);

      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      var year = parseYearResult.year;
      var restDateString = parseYearResult.restDateString;

      var date = parseDate(restDateString, year);

      if (isNaN(date)) {
        return new Date(NaN)
      }

      if (date) {
        var timestamp = date.getTime();
        var time = 0;
        var offset;

        if (dateStrings.time) {
          time = parseTime(dateStrings.time);

          if (isNaN(time)) {
            return new Date(NaN)
          }
        }

        if (dateStrings.timezone || options.timeZone) {
          offset = tzParseTimezone(dateStrings.timezone || options.timeZone, new Date(timestamp + time));
          if (isNaN(offset)) {
            return new Date(NaN)
          }
        } else {
          // get offset accurate to hour in timezones that change offset
          offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
          offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
        }

        return new Date(timestamp + time + offset)
      } else {
        return new Date(NaN)
      }
    }

    function splitDateString(dateString) {
      var dateStrings = {};
      var array = dateString.split(patterns.dateTimeDelimeter);
      var timeString;

      if (patterns.plainTime.test(array[0])) {
        dateStrings.date = null;
        timeString = array[0];
      } else {
        dateStrings.date = array[0];
        timeString = array[1];
        dateStrings.timezone = array[2];
        if (patterns.timeZoneDelimeter.test(dateStrings.date)) {
          dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];
          timeString = dateString.substr(dateStrings.date.length, dateString.length);
        }
      }

      if (timeString) {
        var token = patterns.timezone.exec(timeString);
        if (token) {
          dateStrings.time = timeString.replace(token[1], '');
          dateStrings.timezone = token[1];
        } else {
          dateStrings.time = timeString;
        }
      }

      return dateStrings
    }

    function parseYear(dateString, additionalDigits) {
      var patternYYY = patterns.YYY[additionalDigits];
      var patternYYYYY = patterns.YYYYY[additionalDigits];

      var token;

      // YYYY or ±YYYYY
      token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
      if (token) {
        var yearString = token[1];
        return {
          year: parseInt(yearString, 10),
          restDateString: dateString.slice(yearString.length),
        }
      }

      // YY or ±YYY
      token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
      if (token) {
        var centuryString = token[1];
        return {
          year: parseInt(centuryString, 10) * 100,
          restDateString: dateString.slice(centuryString.length),
        }
      }

      // Invalid ISO-formatted year
      return {
        year: null,
      }
    }

    function parseDate(dateString, year) {
      // Invalid ISO-formatted year
      if (year === null) {
        return null
      }

      var token;
      var date;
      var month;
      var week;

      // YYYY
      if (dateString.length === 0) {
        date = new Date(0);
        date.setUTCFullYear(year);
        return date
      }

      // YYYY-MM
      token = patterns.MM.exec(dateString);
      if (token) {
        date = new Date(0);
        month = parseInt(token[1], 10) - 1;

        if (!validateDate(year, month)) {
          return new Date(NaN)
        }

        date.setUTCFullYear(year, month);
        return date
      }

      // YYYY-DDD or YYYYDDD
      token = patterns.DDD.exec(dateString);
      if (token) {
        date = new Date(0);
        var dayOfYear = parseInt(token[1], 10);

        if (!validateDayOfYearDate(year, dayOfYear)) {
          return new Date(NaN)
        }

        date.setUTCFullYear(year, 0, dayOfYear);
        return date
      }

      // yyyy-MM-dd or YYYYMMDD
      token = patterns.MMDD.exec(dateString);
      if (token) {
        date = new Date(0);
        month = parseInt(token[1], 10) - 1;
        var day = parseInt(token[2], 10);

        if (!validateDate(year, month, day)) {
          return new Date(NaN)
        }

        date.setUTCFullYear(year, month, day);
        return date
      }

      // YYYY-Www or YYYYWww
      token = patterns.Www.exec(dateString);
      if (token) {
        week = parseInt(token[1], 10) - 1;

        if (!validateWeekDate(year, week)) {
          return new Date(NaN)
        }

        return dayOfISOWeekYear(year, week)
      }

      // YYYY-Www-D or YYYYWwwD
      token = patterns.WwwD.exec(dateString);
      if (token) {
        week = parseInt(token[1], 10) - 1;
        var dayOfWeek = parseInt(token[2], 10) - 1;

        if (!validateWeekDate(year, week, dayOfWeek)) {
          return new Date(NaN)
        }

        return dayOfISOWeekYear(year, week, dayOfWeek)
      }

      // Invalid ISO-formatted date
      return null
    }

    function parseTime(timeString) {
      var token;
      var hours;
      var minutes;

      // hh
      token = patterns.HH.exec(timeString);
      if (token) {
        hours = parseFloat(token[1].replace(',', '.'));

        if (!validateTime(hours)) {
          return NaN
        }

        return (hours % 24) * MILLISECONDS_IN_HOUR
      }

      // hh:mm or hhmm
      token = patterns.HHMM.exec(timeString);
      if (token) {
        hours = parseInt(token[1], 10);
        minutes = parseFloat(token[2].replace(',', '.'));

        if (!validateTime(hours, minutes)) {
          return NaN
        }

        return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE
      }

      // hh:mm:ss or hhmmss
      token = patterns.HHMMSS.exec(timeString);
      if (token) {
        hours = parseInt(token[1], 10);
        minutes = parseInt(token[2], 10);
        var seconds = parseFloat(token[3].replace(',', '.'));

        if (!validateTime(hours, minutes, seconds)) {
          return NaN
        }

        return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000
      }

      // Invalid ISO-formatted time
      return null
    }

    function dayOfISOWeekYear(isoWeekYear, week, day) {
      week = week || 0;
      day = day || 0;
      var date = new Date(0);
      date.setUTCFullYear(isoWeekYear, 0, 4);
      var fourthOfJanuaryDay = date.getUTCDay() || 7;
      var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
      date.setUTCDate(date.getUTCDate() + diff);
      return date
    }

    // Validation functions

    var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

    function isLeapYearIndex(year) {
      return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
    }

    function validateDate(year, month, date) {
      if (month < 0 || month > 11) {
        return false
      }

      if (date != null) {
        if (date < 1) {
          return false
        }

        var isLeapYear = isLeapYearIndex(year);
        if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
          return false
        }
        if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
          return false
        }
      }

      return true
    }

    function validateDayOfYearDate(year, dayOfYear) {
      if (dayOfYear < 1) {
        return false
      }

      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear && dayOfYear > 366) {
        return false
      }
      if (!isLeapYear && dayOfYear > 365) {
        return false
      }

      return true
    }

    function validateWeekDate(year, week, day) {
      if (week < 0 || week > 52) {
        return false
      }

      if (day != null && (day < 0 || day > 6)) {
        return false
      }

      return true
    }

    function validateTime(hours, minutes, seconds) {
      if (hours != null && (hours < 0 || hours >= 25)) {
        return false
      }

      if (minutes != null && (minutes < 0 || minutes >= 60)) {
        return false
      }

      if (seconds != null && (seconds < 0 || seconds >= 60)) {
        return false
      }

      return true
    }

    function assign(target, dirtyObject) {
      if (target == null) {
        throw new TypeError('assign requires that input parameter not be null or undefined');
      }

      dirtyObject = dirtyObject || {};

      for (var property in dirtyObject) {
        if (dirtyObject.hasOwnProperty(property)) {
          target[property] = dirtyObject[property];
        }
      }

      return target;
    }

    function cloneObject(dirtyObject) {
      return assign({}, dirtyObject);
    }

    /**
     * @name zonedTimeToUtc
     * @category Time Zone Helpers
     * @summary Get the UTC date/time from a date representing local time in a given time zone
     *
     * @description
     * Returns a date instance with the UTC time of the provided date of which the values
     * represented the local time in the time zone specified. In other words, if the input
     * date represented local time in time time zone, the timestamp of the output date will
     * give the equivalent UTC of that local time regardless of the current system time zone.
     *
     * @param {Date|String|Number} date - the date with values representing the local time
     * @param {String} timeZone - the time zone of this local time, can be an offset or IANA time zone
     * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
     * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * @returns {Date} the new date with the equivalent time in the time zone
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
     *
     * @example
     * // In June 10am in Los Angeles is 5pm UTC
     * const result = zonedTimeToUtc(new Date(2014, 5, 25, 10, 0, 0), 'America/Los_Angeles')
     * //=> 2014-06-25T17:00:00.000Z
     */
    function zonedTimeToUtc(date, timeZone, options) {
      if (date instanceof Date) {
        date = format$1(date, "yyyy-MM-dd'T'HH:mm:ss.SSS");
      }
      var extendedOptions = cloneObject(options);
      extendedOptions.timeZone = timeZone;
      return toDate(date, extendedOptions)
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty$3.call(object, key);
    }

    var _baseHas = baseHas;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex;

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = _castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = _toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength_1(length) && _isIndex(key, length) &&
        (isArray_1(object) || isArguments_1(object));
    }

    var _hasPath = hasPath;

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && _hasPath(object, path, _baseHas);
    }

    var has_1 = has;

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce = arrayReduce;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf = basePropertyOf;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = _basePropertyOf(deburredLetters);

    var _deburrLetter = deburrLetter;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$4 = '\\u0300-\\u036f',
        reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
        rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4;

    /** Used to compose unicode capture groups. */
    var rsCombo$3 = '[' + rsComboRange$4 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$3, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString_1(string);
      return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
    }

    var deburr_1 = deburr;

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    var _asciiWords = asciiWords;

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    var _hasUnicodeWord = hasUnicodeWord;

    /** Used to compose unicode character classes. */
    var rsAstralRange$3 = '\\ud800-\\udfff',
        rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$3 = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$2 = '[' + rsComboRange$3 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange$3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$2 = '(?:' + rsCombo$2 + '|' + rsFitz$2 + ')',
        rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
        rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ$3 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$2 = rsModifier$2 + '?',
        rsOptVar$2 = '[' + rsVarRange$3 + ']?',
        rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
        rsEmoji = '(?:' + [rsDingbat, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsSeq$2;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    var _unicodeWords = unicodeWords;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString_1(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return _hasUnicodeWord(string) ? _unicodeWords(string) : _asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    var words_1 = words;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return _arrayReduce(words_1(deburr_1(string).replace(reApos, '')), callback, '');
      };
    }

    var _createCompounder = createCompounder;

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = _createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    var kebabCase_1 = kebabCase;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush;

    /** Built-in value references. */
    var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray_1(value) || isArguments_1(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    var _isFlattenable = isFlattenable;

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = _isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            _arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    var _baseFlatten = baseFlatten;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new _ListCache;
      this.size = 0;
    }

    var _stackClear = stackClear;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof _ListCache) {
        var pairs = data.__data__;
        if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new _MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new _ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = _stackClear;
    Stack.prototype['delete'] = _stackDelete;
    Stack.prototype.get = _stackGet;
    Stack.prototype.has = _stackHas;
    Stack.prototype.set = _stackSet;

    var _Stack = Stack;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    var _setCacheAdd = setCacheAdd;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new _MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
    SetCache.prototype.has = _setCacheHas;

    var _SetCache = SetCache;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new _SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!_arraySome(other, function(othValue, othIndex) {
                if (!_cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays;

    /** Built-in value references. */
    var Uint8Array$1 = _root.Uint8Array;

    var _Uint8Array = Uint8Array$1;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        regexpTag$1 = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq_1(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag$1:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = _mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = _setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    var stubArray_1 = stubArray;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return _arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray_1(value),
          isArg = !isArr && isArguments_1(value),
          isBuff = !isArr && !isArg && isBuffer_1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? _baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$2.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               _isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
    }

    var keys_1 = keys;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return _baseGetAllKeys(object, keys_1, _getSymbols);
    }

    var _getAllKeys = getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          objProps = _getAllKeys(object),
          objLength = objProps.length,
          othProps = _getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray_1(object),
          othIsArr = isArray_1(other),
          objTag = objIsArr ? arrayTag : _getTag(object),
          othTag = othIsArr ? arrayTag : _getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer_1(object)) {
        if (!isBuffer_1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new _Stack);
        return (objIsArr || isTypedArray_1(object))
          ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new _Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new _Stack);
      return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
        return value !== value && other !== other;
      }
      return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    var _baseIsEqual = baseIsEqual;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new _Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    var _baseIsMatch = baseIsMatch;

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject_1$1(value);
    }

    var _isStrictComparable = isStrictComparable;

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys_1(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, _isStrictComparable(value)];
      }
      return result;
    }

    var _getMatchData = getMatchData;

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    var _matchesStrictComparable = matchesStrictComparable;

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = _getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || _baseIsMatch(object, source, matchData);
      };
    }

    var _baseMatches = baseMatches;

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    var _baseHasIn = baseHasIn;

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && _hasPath(object, path, _baseHasIn);
    }

    var hasIn_1 = hasIn;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (_isKey(path) && _isStrictComparable(srcValue)) {
        return _matchesStrictComparable(_toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get_1(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn_1(object, path)
          : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    var _baseMatchesProperty = baseMatchesProperty;

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    var identity_1 = identity;

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    var _baseProperty = baseProperty;

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return _baseGet(object, path);
      };
    }

    var _basePropertyDeep = basePropertyDeep;

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
    }

    var property_1 = property;

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity_1;
      }
      if (typeof value == 'object') {
        return isArray_1(value)
          ? _baseMatchesProperty(value[0], value[1])
          : _baseMatches(value);
      }
      return property_1(value);
    }

    var _baseIteratee = baseIteratee;

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    var _createBaseFor = createBaseFor;

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = _createBaseFor();

    var _baseFor = baseFor;

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && _baseFor(object, iteratee, keys_1);
    }

    var _baseForOwn = baseForOwn;

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike_1(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    var _createBaseEach = createBaseEach;

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = _createBaseEach(_baseForOwn);

    var _baseEach = baseEach;

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike_1(collection) ? Array(collection.length) : [];

      _baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    var _baseMap = baseMap;

    /**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */
    function baseSortBy(array, comparer) {
      var length = array.length;

      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }

    var _baseSortBy = baseSortBy;

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol_1(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol_1(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    var _compareAscending = compareAscending;

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = _compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    var _compareMultiple = compareMultiple;

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = _arrayMap(iteratees, function(iteratee) {
          if (isArray_1(iteratee)) {
            return function(value) {
              return _baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity_1];
      }

      var index = -1;
      iteratees = _arrayMap(iteratees, _baseUnary(_baseIteratee));

      var result = _baseMap(collection, function(value, key, collection) {
        var criteria = _arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return _baseSortBy(result, function(object, other) {
        return _compareMultiple(object, other, orders);
      });
    }

    var _baseOrderBy = baseOrderBy;

    /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0: return func.call(thisArg);
        case 1: return func.call(thisArg, args[0]);
        case 2: return func.call(thisArg, args[0], args[1]);
        case 3: return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }

    var _apply = apply;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max;

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return _apply(func, this, otherArgs);
      };
    }

    var _overRest = overRest;

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    var constant_1 = constant;

    var defineProperty = (function() {
      try {
        var func = _getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    var _defineProperty = defineProperty;

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {
      return _defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant_1(string),
        'writable': true
      });
    };

    var _baseSetToString = baseSetToString;

    /** Used to detect hot functions by number of calls within a span of milliseconds. */
    var HOT_COUNT = 800,
        HOT_SPAN = 16;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeNow = Date.now;

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    var _shortOut = shortOut;

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = _shortOut(_baseSetToString);

    var _setToString = setToString;

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return _setToString(_overRest(func, start, identity_1), func + '');
    }

    var _baseRest = baseRest;

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject_1$1(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike_1(object) && _isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq_1(object[index], value);
      }
      return false;
    }

    var _isIterateeCall = isIterateeCall;

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = _baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
    });

    var sortBy_1 = sortBy;

    /* src/Components/TaxList.svelte generated by Svelte v3.35.0 */
    const file$l = "src/Components/TaxList.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (58:4) {#if !isEmpty(date)}
    function create_if_block_2$7(ctx) {
    	let span;
    	let t_value = format$1(new Date(/*date*/ ctx[3]), "yyyy/MM/dd") + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "taxonomy__item date svelte-2n58db");
    			add_location(span, file$l, 58, 6, 1501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 8 && t_value !== (t_value = format$1(new Date(/*date*/ ctx[3]), "yyyy/MM/dd") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(58:4) {#if !isEmpty(date)}",
    		ctx
    	});

    	return block;
    }

    // (64:4) {#if taxonomy.subCategory}
    function create_if_block_1$b(ctx) {
    	let span;
    	let a;
    	let t_value = /*taxonomy*/ ctx[0].subCategory.replace("-", " ") + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "href", a_href_value = "/" + /*taxonomy*/ ctx[0].category + "/category/" + /*taxonomy*/ ctx[0].subCategory);
    			add_location(a, file$l, 65, 8, 1683);
    			attr_dev(span, "class", "taxonomy__item svelte-2n58db");
    			add_location(span, file$l, 64, 6, 1645);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*taxonomy*/ 1 && t_value !== (t_value = /*taxonomy*/ ctx[0].subCategory.replace("-", " ") + "")) set_data_dev(t, t_value);

    			if (dirty & /*taxonomy*/ 1 && a_href_value !== (a_href_value = "/" + /*taxonomy*/ ctx[0].category + "/category/" + /*taxonomy*/ ctx[0].subCategory)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(64:4) {#if taxonomy.subCategory}",
    		ctx
    	});

    	return block;
    }

    // (72:4) {#if isArticle}
    function create_if_block$f(ctx) {
    	let each_1_anchor;
    	let each_value = sortBy_1(/*taxonomy*/ ctx[0].tags);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*sortBy, taxonomy*/ 1) {
    				each_value = sortBy_1(/*taxonomy*/ ctx[0].tags);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(72:4) {#if isArticle}",
    		ctx
    	});

    	return block;
    }

    // (73:6) {#each sortBy(taxonomy.tags) as t}
    function create_each_block$7(ctx) {
    	let span;
    	let a;
    	let t0_value = /*t*/ ctx[4] + "";
    	let t0;
    	let a_href_value;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "href", a_href_value = "/taxonomy/" + /*t*/ ctx[4]);
    			add_location(a, file$l, 74, 10, 1945);
    			attr_dev(span, "class", "taxonomy__item svelte-2n58db");
    			add_location(span, file$l, 73, 8, 1905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*taxonomy*/ 1 && t0_value !== (t0_value = /*t*/ ctx[4] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*taxonomy*/ 1 && a_href_value !== (a_href_value = "/taxonomy/" + /*t*/ ctx[4])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(73:6) {#each sortBy(taxonomy.tags) as t}",
    		ctx
    	});

    	return block;
    }

    // (54:0) <Router>
    function create_default_slot$6(ctx) {
    	let div;
    	let show_if = !isEmpty_1(/*date*/ ctx[3]);
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if && create_if_block_2$7(ctx);
    	let if_block1 = /*taxonomy*/ ctx[0].subCategory && create_if_block_1$b(ctx);
    	let if_block2 = /*isArticle*/ ctx[1] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div, "class", "taxonomy svelte-2n58db");
    			toggle_class(div, "white", /*white*/ ctx[2]);
    			add_location(div, file$l, 55, 2, 1424);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);

    			if (!mounted) {
    				dispose = action_destroyer(links.call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*date*/ 8) show_if = !isEmpty_1(/*date*/ ctx[3]);

    			if (show_if) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$7(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*taxonomy*/ ctx[0].subCategory) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$b(ctx);
    					if_block1.c();
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*isArticle*/ ctx[1]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$f(ctx);
    					if_block2.c();
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*white*/ 4) {
    				toggle_class(div, "white", /*white*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(54:0) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, white, taxonomy, isArticle, date*/ 143) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TaxList", slots, []);
    	let { taxonomy } = $$props;
    	let { isArticle = false } = $$props;
    	let { white = false } = $$props;
    	let { date = false } = $$props;
    	const writable_props = ["taxonomy", "isArticle", "white", "date"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TaxList> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("taxonomy" in $$props) $$invalidate(0, taxonomy = $$props.taxonomy);
    		if ("isArticle" in $$props) $$invalidate(1, isArticle = $$props.isArticle);
    		if ("white" in $$props) $$invalidate(2, white = $$props.white);
    		if ("date" in $$props) $$invalidate(3, date = $$props.date);
    	};

    	$$self.$capture_state = () => ({
    		Router,
    		links,
    		format: format$1,
    		sortBy: sortBy_1,
    		isEmpty: isEmpty_1,
    		taxonomy,
    		isArticle,
    		white,
    		date
    	});

    	$$self.$inject_state = $$props => {
    		if ("taxonomy" in $$props) $$invalidate(0, taxonomy = $$props.taxonomy);
    		if ("isArticle" in $$props) $$invalidate(1, isArticle = $$props.isArticle);
    		if ("white" in $$props) $$invalidate(2, white = $$props.white);
    		if ("date" in $$props) $$invalidate(3, date = $$props.date);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [taxonomy, isArticle, white, date];
    }

    class TaxList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			taxonomy: 0,
    			isArticle: 1,
    			white: 2,
    			date: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TaxList",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*taxonomy*/ ctx[0] === undefined && !("taxonomy" in props)) {
    			console.warn("<TaxList> was created without expected prop 'taxonomy'");
    		}
    	}

    	get taxonomy() {
    		throw new Error("<TaxList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set taxonomy(value) {
    		throw new Error("<TaxList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isArticle() {
    		throw new Error("<TaxList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isArticle(value) {
    		throw new Error("<TaxList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get white() {
    		throw new Error("<TaxList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set white(value) {
    		throw new Error("<TaxList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get date() {
    		throw new Error("<TaxList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set date(value) {
    		throw new Error("<TaxList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Modules/Video.svelte generated by Svelte v3.35.0 */

    const { isNaN: isNaN_1$1 } = globals;
    const file$k = "src/Components/Modules/Video.svelte";

    // (224:2) {#if !autoplay && !isListing}
    function create_if_block$e(ctx) {
    	let div1;
    	let div0;

    	function select_block_type(ctx, dirty) {
    		if (/*paused*/ ctx[10]) return create_if_block_1$a;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "buttons svelte-czvon8");
    			add_location(div0, file$k, 228, 6, 5171);
    			attr_dev(div1, "class", "controls svelte-czvon8");
    			set_style(div1, "opacity", /*duration*/ ctx[9] && /*showControls*/ ctx[11] ? 1 : 0);
    			add_location(div1, file$k, 224, 4, 5031);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_block.m(div0, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}

    			if (dirty & /*duration, showControls*/ 2560) {
    				set_style(div1, "opacity", /*duration*/ ctx[9] && /*showControls*/ ctx[11] ? 1 : 0);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(224:2) {#if !autoplay && !isListing}",
    		ctx
    	});

    	return block;
    }

    // (242:8) {:else}
    function create_else_block$5(ctx) {
    	let svg;
    	let rect0;
    	let rect1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			attr_dev(rect0, "x", "6");
    			attr_dev(rect0, "y", "4");
    			attr_dev(rect0, "width", "4");
    			attr_dev(rect0, "height", "16");
    			add_location(rect0, file$k, 251, 12, 5915);
    			attr_dev(rect1, "x", "14");
    			attr_dev(rect1, "y", "4");
    			attr_dev(rect1, "width", "4");
    			attr_dev(rect1, "height", "16");
    			add_location(rect1, file$k, 252, 12, 5970);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke", "currentColor");
    			attr_dev(svg, "stroke-width", "0.5");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			attr_dev(svg, "class", "feather feather-pause pause svelte-czvon8");
    			add_location(svg, file$k, 242, 10, 5610);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect0);
    			append_dev(svg, rect1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(242:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (230:8) {#if paused}
    function create_if_block_1$a(ctx) {
    	let svg;
    	let polygon;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			polygon = svg_element("polygon");
    			attr_dev(polygon, "points", "5 3 19 12 5 21 5 3");
    			add_location(polygon, file$k, 239, 12, 5527);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke", "currentColor");
    			attr_dev(svg, "stroke-width", "0.5");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			attr_dev(svg, "class", "feather feather-play play svelte-czvon8");
    			add_location(svg, file$k, 230, 10, 5224);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, polygon);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(230:8) {#if paused}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div;
    	let video;
    	let video_class_value;
    	let video_muted_value;
    	let video_poster_value;
    	let video_src_value;
    	let video_updating = false;
    	let video_animationframe;
    	let video_is_paused = true;
    	let t;
    	let mounted;
    	let dispose;

    	function video_timeupdate_handler() {
    		cancelAnimationFrame(video_animationframe);

    		if (!video.paused) {
    			video_animationframe = raf(video_timeupdate_handler);
    			video_updating = true;
    		}

    		/*video_timeupdate_handler*/ ctx[21].call(video);
    	}

    	let if_block = !/*autoplay*/ ctx[3] && !/*isListing*/ ctx[5] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			video = element("video");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(video, "class", video_class_value = "video-player " + /*alignment*/ ctx[2] + " svelte-czvon8");
    			attr_dev(video, "preload", "metadata");
    			video.playsInline = "playsinline";
    			video.loop = /*loop*/ ctx[6];
    			video.muted = video_muted_value = /*autoplay*/ ctx[3] || /*isListing*/ ctx[5];

    			attr_dev(video, "poster", video_poster_value = /*posterImage*/ ctx[1]
    			? urlFor(/*posterImage*/ ctx[1]).width(1200).quality(90).auto("format").url()
    			: "");

    			if (video.src !== (video_src_value = /*url*/ ctx[0])) attr_dev(video, "src", video_src_value);
    			if (/*duration*/ ctx[9] === void 0) add_render_callback(() => /*video_durationchange_handler*/ ctx[22].call(video));
    			add_location(video, file$k, 205, 2, 4539);
    			attr_dev(div, "class", "video svelte-czvon8");
    			attr_dev(div, "style", /*customStyles*/ ctx[12]);
    			toggle_class(div, "listing", /*isListing*/ ctx[5]);
    			toggle_class(div, "video--full", /*fullwidth*/ ctx[4] || /*isListing*/ ctx[5]);
    			add_location(div, file$k, 199, 0, 4418);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, video);
    			/*video_binding*/ ctx[24](video);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(video, "mousemove", /*handleMousemove*/ ctx[13], false, false, false),
    					listen_dev(video, "mousedown", /*handleMousedown*/ ctx[14], false, false, false),
    					listen_dev(video, "timeupdate", video_timeupdate_handler),
    					listen_dev(video, "durationchange", /*video_durationchange_handler*/ ctx[22]),
    					listen_dev(video, "play", /*video_play_pause_handler*/ ctx[23]),
    					listen_dev(video, "pause", /*video_play_pause_handler*/ ctx[23])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*alignment*/ 4 && video_class_value !== (video_class_value = "video-player " + /*alignment*/ ctx[2] + " svelte-czvon8")) {
    				attr_dev(video, "class", video_class_value);
    			}

    			if (dirty & /*loop*/ 64) {
    				prop_dev(video, "loop", /*loop*/ ctx[6]);
    			}

    			if (dirty & /*autoplay, isListing*/ 40 && video_muted_value !== (video_muted_value = /*autoplay*/ ctx[3] || /*isListing*/ ctx[5])) {
    				prop_dev(video, "muted", video_muted_value);
    			}

    			if (dirty & /*posterImage*/ 2 && video_poster_value !== (video_poster_value = /*posterImage*/ ctx[1]
    			? urlFor(/*posterImage*/ ctx[1]).width(1200).quality(90).auto("format").url()
    			: "")) {
    				attr_dev(video, "poster", video_poster_value);
    			}

    			if (dirty & /*url*/ 1 && video.src !== (video_src_value = /*url*/ ctx[0])) {
    				attr_dev(video, "src", video_src_value);
    			}

    			if (!video_updating && dirty & /*time*/ 256 && !isNaN_1$1(/*time*/ ctx[8])) {
    				video.currentTime = /*time*/ ctx[8];
    			}

    			video_updating = false;

    			if (dirty & /*paused*/ 1024 && video_is_paused !== (video_is_paused = /*paused*/ ctx[10])) {
    				video[video_is_paused ? "pause" : "play"]();
    			}

    			if (!/*autoplay*/ ctx[3] && !/*isListing*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*isListing*/ 32) {
    				toggle_class(div, "listing", /*isListing*/ ctx[5]);
    			}

    			if (dirty & /*fullwidth, isListing*/ 48) {
    				toggle_class(div, "video--full", /*fullwidth*/ ctx[4] || /*isListing*/ ctx[5]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*video_binding*/ ctx[24](null);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const VIDEO_ROOT = "https://res.cloudinary.com/pwr/video/upload/";
    const REMOTE_FOLDER = "novembre";

    function format(seconds) {
    	if (isNaN(seconds)) return "...";
    	const minutes = Math.floor(seconds / 60);
    	seconds = Math.floor(seconds % 60);
    	if (seconds < 10) seconds = "0" + seconds;
    	return `${minutes}:${seconds}`;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Video", slots, []);
    	let { url = "" } = $$props;
    	let { posterImage = {} } = $$props;
    	let { caption = false } = $$props;
    	let { backgroundColor = false } = $$props;
    	let { alignment = "" } = $$props;
    	let { maxHeight = false } = $$props;
    	let { autoplay = false } = $$props;
    	let { fullwidth = false } = $$props;
    	let { inlineDisplay = false } = $$props;
    	let { isListing = false } = $$props;
    	let { loop = true } = $$props;
    	let { muted = true } = $$props;
    	let { controls = false } = $$props;

    	const customStyles = (maxHeight ? "height:" + maxHeight + "vh; " : "") + (backgroundColor
    	? "background:" + backgroundColor.hex + ";"
    	: "");

    	// *** DOM REFERENCES
    	let videoEl = {};

    	// *** VARIABLES
    	let time = 0;

    	let duration = 0;
    	let paused = true;
    	let showControls = true;
    	let showControlsTimeout;
    	let controlsTimeoutDuration = 2500;
    	let post = {};
    	let videoUrl = "";
    	let videoSrc = "";

    	// --- Video controls
    	function handleMousemove(e) {
    		// Make the controls visible, but fade out after
    		// 2.5 seconds of inactivity
    		clearTimeout(showControlsTimeout);

    		showControlsTimeout = setTimeout(() => $$invalidate(11, showControls = false), controlsTimeoutDuration);
    		$$invalidate(11, showControls = true);
    		if (e.which !== 1) return; // mouse not down
    		if (!duration) return; // video not loaded yet
    		const { left, right } = this.getBoundingClientRect();
    		$$invalidate(8, time = duration * (e.clientX - left) / (right - left));
    	}

    	function handleMousedown(e) {
    		function handleMouseup() {
    			if (paused) {
    				e.target.play();
    			} else {
    				e.target.pause();
    			}

    			cancel();
    		}

    		function cancel() {
    			e.target.removeEventListener("mouseup", handleMouseup);
    		}

    		e.target.addEventListener("mouseup", handleMouseup);
    		setTimeout(cancel, 200);
    	}

    	// *** ON MOUNT
    	onMount(async () => {
    		if (autoplay || isListing) {
    			let promise = videoEl.play();

    			if (promise !== undefined) {
    				promise.catch(err => {
    					Sentry.captureException(err);
    				});
    			}
    		}
    	});

    	const writable_props = [
    		"url",
    		"posterImage",
    		"caption",
    		"backgroundColor",
    		"alignment",
    		"maxHeight",
    		"autoplay",
    		"fullwidth",
    		"inlineDisplay",
    		"isListing",
    		"loop",
    		"muted",
    		"controls"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Video> was created with unknown prop '${key}'`);
    	});

    	function video_timeupdate_handler() {
    		time = this.currentTime;
    		$$invalidate(8, time);
    	}

    	function video_durationchange_handler() {
    		duration = this.duration;
    		$$invalidate(9, duration);
    	}

    	function video_play_pause_handler() {
    		paused = this.paused;
    		$$invalidate(10, paused);
    	}

    	function video_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			videoEl = $$value;
    			$$invalidate(7, videoEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("posterImage" in $$props) $$invalidate(1, posterImage = $$props.posterImage);
    		if ("caption" in $$props) $$invalidate(15, caption = $$props.caption);
    		if ("backgroundColor" in $$props) $$invalidate(16, backgroundColor = $$props.backgroundColor);
    		if ("alignment" in $$props) $$invalidate(2, alignment = $$props.alignment);
    		if ("maxHeight" in $$props) $$invalidate(17, maxHeight = $$props.maxHeight);
    		if ("autoplay" in $$props) $$invalidate(3, autoplay = $$props.autoplay);
    		if ("fullwidth" in $$props) $$invalidate(4, fullwidth = $$props.fullwidth);
    		if ("inlineDisplay" in $$props) $$invalidate(18, inlineDisplay = $$props.inlineDisplay);
    		if ("isListing" in $$props) $$invalidate(5, isListing = $$props.isListing);
    		if ("loop" in $$props) $$invalidate(6, loop = $$props.loop);
    		if ("muted" in $$props) $$invalidate(19, muted = $$props.muted);
    		if ("controls" in $$props) $$invalidate(20, controls = $$props.controls);
    	};

    	$$self.$capture_state = () => ({
    		MediaQuery,
    		onMount,
    		urlFor,
    		url,
    		posterImage,
    		caption,
    		backgroundColor,
    		alignment,
    		maxHeight,
    		autoplay,
    		fullwidth,
    		inlineDisplay,
    		isListing,
    		loop,
    		muted,
    		controls,
    		customStyles,
    		videoEl,
    		VIDEO_ROOT,
    		REMOTE_FOLDER,
    		time,
    		duration,
    		paused,
    		showControls,
    		showControlsTimeout,
    		controlsTimeoutDuration,
    		post,
    		videoUrl,
    		videoSrc,
    		handleMousemove,
    		handleMousedown,
    		format
    	});

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("posterImage" in $$props) $$invalidate(1, posterImage = $$props.posterImage);
    		if ("caption" in $$props) $$invalidate(15, caption = $$props.caption);
    		if ("backgroundColor" in $$props) $$invalidate(16, backgroundColor = $$props.backgroundColor);
    		if ("alignment" in $$props) $$invalidate(2, alignment = $$props.alignment);
    		if ("maxHeight" in $$props) $$invalidate(17, maxHeight = $$props.maxHeight);
    		if ("autoplay" in $$props) $$invalidate(3, autoplay = $$props.autoplay);
    		if ("fullwidth" in $$props) $$invalidate(4, fullwidth = $$props.fullwidth);
    		if ("inlineDisplay" in $$props) $$invalidate(18, inlineDisplay = $$props.inlineDisplay);
    		if ("isListing" in $$props) $$invalidate(5, isListing = $$props.isListing);
    		if ("loop" in $$props) $$invalidate(6, loop = $$props.loop);
    		if ("muted" in $$props) $$invalidate(19, muted = $$props.muted);
    		if ("controls" in $$props) $$invalidate(20, controls = $$props.controls);
    		if ("videoEl" in $$props) $$invalidate(7, videoEl = $$props.videoEl);
    		if ("time" in $$props) $$invalidate(8, time = $$props.time);
    		if ("duration" in $$props) $$invalidate(9, duration = $$props.duration);
    		if ("paused" in $$props) $$invalidate(10, paused = $$props.paused);
    		if ("showControls" in $$props) $$invalidate(11, showControls = $$props.showControls);
    		if ("showControlsTimeout" in $$props) showControlsTimeout = $$props.showControlsTimeout;
    		if ("controlsTimeoutDuration" in $$props) controlsTimeoutDuration = $$props.controlsTimeoutDuration;
    		if ("post" in $$props) post = $$props.post;
    		if ("videoUrl" in $$props) videoUrl = $$props.videoUrl;
    		if ("videoSrc" in $$props) videoSrc = $$props.videoSrc;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		url,
    		posterImage,
    		alignment,
    		autoplay,
    		fullwidth,
    		isListing,
    		loop,
    		videoEl,
    		time,
    		duration,
    		paused,
    		showControls,
    		customStyles,
    		handleMousemove,
    		handleMousedown,
    		caption,
    		backgroundColor,
    		maxHeight,
    		inlineDisplay,
    		muted,
    		controls,
    		video_timeupdate_handler,
    		video_durationchange_handler,
    		video_play_pause_handler,
    		video_binding
    	];
    }

    class Video extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			url: 0,
    			posterImage: 1,
    			caption: 15,
    			backgroundColor: 16,
    			alignment: 2,
    			maxHeight: 17,
    			autoplay: 3,
    			fullwidth: 4,
    			inlineDisplay: 18,
    			isListing: 5,
    			loop: 6,
    			muted: 19,
    			controls: 20
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Video",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get url() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posterImage() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posterImage(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caption() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caption(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundColor() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundColor(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get alignment() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alignment(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxHeight() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxHeight(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoplay() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoplay(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullwidth() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullwidth(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineDisplay() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineDisplay(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListing() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListing(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loop() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loop(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get muted() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set muted(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get controls() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set controls(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Modules/Image.svelte generated by Svelte v3.35.0 */
    const file$j = "src/Components/Modules/Image.svelte";

    // (176:6) {#if caption}
    function create_if_block$d(ctx) {
    	let figcaption;
    	let t;

    	const block = {
    		c: function create() {
    			figcaption = element("figcaption");
    			t = text(/*caption*/ ctx[0]);
    			attr_dev(figcaption, "class", "svelte-1kgnd8k");
    			add_location(figcaption, file$j, 176, 8, 3745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figcaption, anchor);
    			append_dev(figcaption, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*caption*/ 1) set_data_dev(t, /*caption*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figcaption);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(176:6) {#if caption}",
    		ctx
    	});

    	return block;
    }

    // (169:2) <MediaQuery query="(min-width: 800px)" let:matches>
    function create_default_slot$5(ctx) {
    	let figure;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t;
    	let mounted;
    	let dispose;
    	let if_block = /*caption*/ ctx[0] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			figure = element("figure");
    			img = element("img");
    			t = space();
    			if (if_block) if_block.c();

    			if (img.src !== (img_src_value = /*matches*/ ctx[13]
    			? /*src*/ ctx[7]
    			: /*srcPortrait*/ ctx[8])) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", img_alt_value = /*caption*/ ctx[0]
    			? /*caption*/ ctx[0]
    			: "novembre.global");

    			attr_dev(img, "class", "svelte-1kgnd8k");
    			toggle_class(img, "loaded", /*loaded*/ ctx[5]);
    			add_location(img, file$j, 170, 6, 3555);
    			attr_dev(figure, "class", "svelte-1kgnd8k");
    			add_location(figure, file$j, 169, 4, 3540);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, figure, anchor);
    			append_dev(figure, img);
    			append_dev(figure, t);
    			if (if_block) if_block.m(figure, null);

    			if (!mounted) {
    				dispose = listen_dev(img, "load", /*load_handler*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*matches*/ 8192 && img.src !== (img_src_value = /*matches*/ ctx[13]
    			? /*src*/ ctx[7]
    			: /*srcPortrait*/ ctx[8])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*caption*/ 1 && img_alt_value !== (img_alt_value = /*caption*/ ctx[0]
    			? /*caption*/ ctx[0]
    			: "novembre.global")) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*loaded*/ 32) {
    				toggle_class(img, "loaded", /*loaded*/ ctx[5]);
    			}

    			if (/*caption*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(figure, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(figure);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(169:2) <MediaQuery query=\\\"(min-width: 800px)\\\" let:matches>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div;
    	let mediaquery;
    	let div_class_value;
    	let current;

    	mediaquery = new MediaQuery({
    			props: {
    				query: "(min-width: 800px)",
    				$$slots: {
    					default: [
    						create_default_slot$5,
    						({ matches }) => ({ 13: matches }),
    						({ matches }) => matches ? 8192 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(mediaquery.$$.fragment);
    			attr_dev(div, "class", div_class_value = "single-image " + /*alignment*/ ctx[1] + " svelte-1kgnd8k");
    			attr_dev(div, "style", /*customStyles*/ ctx[6]);
    			toggle_class(div, "fullwidth", /*fullwidth*/ ctx[2]);
    			toggle_class(div, "listing", /*isListing*/ ctx[3]);
    			toggle_class(div, "bottom-space", /*inlineDisplay*/ ctx[4]);
    			add_location(div, file$j, 162, 0, 3335);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(mediaquery, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mediaquery_changes = {};

    			if (dirty & /*$$scope, caption, matches, loaded*/ 24609) {
    				mediaquery_changes.$$scope = { dirty, ctx };
    			}

    			mediaquery.$set(mediaquery_changes);

    			if (!current || dirty & /*alignment*/ 2 && div_class_value !== (div_class_value = "single-image " + /*alignment*/ ctx[1] + " svelte-1kgnd8k")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*alignment, fullwidth*/ 6) {
    				toggle_class(div, "fullwidth", /*fullwidth*/ ctx[2]);
    			}

    			if (dirty & /*alignment, isListing*/ 10) {
    				toggle_class(div, "listing", /*isListing*/ ctx[3]);
    			}

    			if (dirty & /*alignment, inlineDisplay*/ 18) {
    				toggle_class(div, "bottom-space", /*inlineDisplay*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mediaquery.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mediaquery.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(mediaquery);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Image", slots, []);
    	let { imageObject = {} } = $$props;
    	let { caption = false } = $$props;
    	let { backgroundColor = false } = $$props;
    	let { alignment = "" } = $$props;
    	let { maxHeight = false } = $$props;
    	let { fullwidth = false } = $$props;
    	let { isListing = false } = $$props;
    	let { inlineDisplay = false } = $$props;

    	const customStyles = (maxHeight ? "height:" + maxHeight + "vh; " : "") + (backgroundColor
    	? "background:" + backgroundColor.hex + ";"
    	: "");

    	// *** VARIABLES
    	const src = fullwidth
    	? urlFor(imageObject).width(1600).height(1100).quality(90).auto("format").url()
    	: urlFor(imageObject).width(800).quality(90).auto("format").url();

    	const srcPortrait = urlFor(imageObject).width(800).quality(90).auto("format").url();
    	let loaded = false;

    	const writable_props = [
    		"imageObject",
    		"caption",
    		"backgroundColor",
    		"alignment",
    		"maxHeight",
    		"fullwidth",
    		"isListing",
    		"inlineDisplay"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Image> was created with unknown prop '${key}'`);
    	});

    	const load_handler = e => $$invalidate(5, loaded = true);

    	$$self.$$set = $$props => {
    		if ("imageObject" in $$props) $$invalidate(9, imageObject = $$props.imageObject);
    		if ("caption" in $$props) $$invalidate(0, caption = $$props.caption);
    		if ("backgroundColor" in $$props) $$invalidate(10, backgroundColor = $$props.backgroundColor);
    		if ("alignment" in $$props) $$invalidate(1, alignment = $$props.alignment);
    		if ("maxHeight" in $$props) $$invalidate(11, maxHeight = $$props.maxHeight);
    		if ("fullwidth" in $$props) $$invalidate(2, fullwidth = $$props.fullwidth);
    		if ("isListing" in $$props) $$invalidate(3, isListing = $$props.isListing);
    		if ("inlineDisplay" in $$props) $$invalidate(4, inlineDisplay = $$props.inlineDisplay);
    	};

    	$$self.$capture_state = () => ({
    		MediaQuery,
    		urlFor,
    		imageObject,
    		caption,
    		backgroundColor,
    		alignment,
    		maxHeight,
    		fullwidth,
    		isListing,
    		inlineDisplay,
    		customStyles,
    		src,
    		srcPortrait,
    		loaded
    	});

    	$$self.$inject_state = $$props => {
    		if ("imageObject" in $$props) $$invalidate(9, imageObject = $$props.imageObject);
    		if ("caption" in $$props) $$invalidate(0, caption = $$props.caption);
    		if ("backgroundColor" in $$props) $$invalidate(10, backgroundColor = $$props.backgroundColor);
    		if ("alignment" in $$props) $$invalidate(1, alignment = $$props.alignment);
    		if ("maxHeight" in $$props) $$invalidate(11, maxHeight = $$props.maxHeight);
    		if ("fullwidth" in $$props) $$invalidate(2, fullwidth = $$props.fullwidth);
    		if ("isListing" in $$props) $$invalidate(3, isListing = $$props.isListing);
    		if ("inlineDisplay" in $$props) $$invalidate(4, inlineDisplay = $$props.inlineDisplay);
    		if ("loaded" in $$props) $$invalidate(5, loaded = $$props.loaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		caption,
    		alignment,
    		fullwidth,
    		isListing,
    		inlineDisplay,
    		loaded,
    		customStyles,
    		src,
    		srcPortrait,
    		imageObject,
    		backgroundColor,
    		maxHeight,
    		load_handler
    	];
    }

    class Image$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			imageObject: 9,
    			caption: 0,
    			backgroundColor: 10,
    			alignment: 1,
    			maxHeight: 11,
    			fullwidth: 2,
    			isListing: 3,
    			inlineDisplay: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Image",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get imageObject() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageObject(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caption() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caption(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundColor() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundColor(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get alignment() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alignment(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxHeight() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxHeight(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullwidth() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullwidth(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListing() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListing(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineDisplay() {
    		throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineDisplay(value) {
    		throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Modules/ImageGroup.svelte generated by Svelte v3.35.0 */
    const file$i = "src/Components/Modules/ImageGroup.svelte";

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (216:2) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let div_class_value;
    	let div_style_value;
    	let each_value_1 = /*imageArray*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", div_class_value = "image-group " + /*alignment*/ ctx[4] + " svelte-96fjme");

    			attr_dev(div, "style", div_style_value = /*matches*/ ctx[15]
    			? /*customStyles*/ ctx[9]
    			: /*customStylesPhone*/ ctx[10]);

    			toggle_class(div, "listing", /*isListing*/ ctx[2]);
    			toggle_class(div, "header", /*isHeader*/ ctx[3]);
    			toggle_class(div, "fullwidth", /*fullwidth*/ ctx[5]);
    			toggle_class(div, "group-size-1", /*imageArray*/ ctx[0].length === 1);
    			toggle_class(div, "group-size-2", /*imageArray*/ ctx[0].length === 2);
    			toggle_class(div, "group-size-3", /*imageArray*/ ctx[0].length === 3);
    			toggle_class(div, "group-size-4", /*imageArray*/ ctx[0].length === 4);
    			toggle_class(div, "bottom-space", /*inlineDisplay*/ ctx[6]);
    			add_location(div, file$i, 216, 4, 5188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fullwidth, urlFor, imageArray, caption, loaded*/ 291) {
    				each_value_1 = /*imageArray*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*alignment*/ 16 && div_class_value !== (div_class_value = "image-group " + /*alignment*/ ctx[4] + " svelte-96fjme")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*matches*/ 32768 && div_style_value !== (div_style_value = /*matches*/ ctx[15]
    			? /*customStyles*/ ctx[9]
    			: /*customStylesPhone*/ ctx[10])) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty & /*alignment, isListing*/ 20) {
    				toggle_class(div, "listing", /*isListing*/ ctx[2]);
    			}

    			if (dirty & /*alignment, isHeader*/ 24) {
    				toggle_class(div, "header", /*isHeader*/ ctx[3]);
    			}

    			if (dirty & /*alignment, fullwidth*/ 48) {
    				toggle_class(div, "fullwidth", /*fullwidth*/ ctx[5]);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(div, "group-size-1", /*imageArray*/ ctx[0].length === 1);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(div, "group-size-2", /*imageArray*/ ctx[0].length === 2);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(div, "group-size-3", /*imageArray*/ ctx[0].length === 3);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(div, "group-size-4", /*imageArray*/ ctx[0].length === 4);
    			}

    			if (dirty & /*alignment, inlineDisplay*/ 80) {
    				toggle_class(div, "bottom-space", /*inlineDisplay*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(216:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (185:2) {#if linkUrl}
    function create_if_block_1$9(ctx) {
    	let a;
    	let a_class_value;
    	let a_style_value;
    	let each_value = /*imageArray*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			a = element("a");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(a, "href", /*linkUrl*/ ctx[7]);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", a_class_value = "image-group " + /*alignment*/ ctx[4] + " svelte-96fjme");

    			attr_dev(a, "style", a_style_value = /*matches*/ ctx[15]
    			? /*customStyles*/ ctx[9]
    			: /*customStylesPhone*/ ctx[10]);

    			toggle_class(a, "listing", /*isListing*/ ctx[2]);
    			toggle_class(a, "header", /*isHeader*/ ctx[3]);
    			toggle_class(a, "fullwidth", /*fullwidth*/ ctx[5]);
    			toggle_class(a, "group-size-1", /*imageArray*/ ctx[0].length === 1);
    			toggle_class(a, "group-size-2", /*imageArray*/ ctx[0].length === 2);
    			toggle_class(a, "group-size-3", /*imageArray*/ ctx[0].length === 3);
    			toggle_class(a, "group-size-4", /*imageArray*/ ctx[0].length === 4);
    			toggle_class(a, "bottom-space", /*inlineDisplay*/ ctx[6]);
    			add_location(a, file$i, 185, 4, 4178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(a, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fullwidth, urlFor, imageArray, caption, loaded*/ 291) {
    				each_value = /*imageArray*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(a, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*linkUrl*/ 128) {
    				attr_dev(a, "href", /*linkUrl*/ ctx[7]);
    			}

    			if (dirty & /*alignment*/ 16 && a_class_value !== (a_class_value = "image-group " + /*alignment*/ ctx[4] + " svelte-96fjme")) {
    				attr_dev(a, "class", a_class_value);
    			}

    			if (dirty & /*matches*/ 32768 && a_style_value !== (a_style_value = /*matches*/ ctx[15]
    			? /*customStyles*/ ctx[9]
    			: /*customStylesPhone*/ ctx[10])) {
    				attr_dev(a, "style", a_style_value);
    			}

    			if (dirty & /*alignment, isListing*/ 20) {
    				toggle_class(a, "listing", /*isListing*/ ctx[2]);
    			}

    			if (dirty & /*alignment, isHeader*/ 24) {
    				toggle_class(a, "header", /*isHeader*/ ctx[3]);
    			}

    			if (dirty & /*alignment, fullwidth*/ 48) {
    				toggle_class(a, "fullwidth", /*fullwidth*/ ctx[5]);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(a, "group-size-1", /*imageArray*/ ctx[0].length === 1);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(a, "group-size-2", /*imageArray*/ ctx[0].length === 2);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(a, "group-size-3", /*imageArray*/ ctx[0].length === 3);
    			}

    			if (dirty & /*alignment, imageArray*/ 17) {
    				toggle_class(a, "group-size-4", /*imageArray*/ ctx[0].length === 4);
    			}

    			if (dirty & /*alignment, inlineDisplay*/ 80) {
    				toggle_class(a, "bottom-space", /*inlineDisplay*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(185:2) {#if linkUrl}",
    		ctx
    	});

    	return block;
    }

    // (228:6) {#each imageArray as image}
    function create_each_block_1$1(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");

    			if (img.src !== (img_src_value = /*fullwidth*/ ctx[5]
    			? urlFor(/*image*/ ctx[16]).width(1800).height(1200).quality(90).auto("format").url()
    			: urlFor(/*image*/ ctx[16]).width(1200 / /*imageArray*/ ctx[0].length).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", img_alt_value = /*caption*/ ctx[1]
    			? /*caption*/ ctx[1]
    			: "novembre.global");

    			attr_dev(img, "class", "svelte-96fjme");
    			toggle_class(img, "loaded", /*loaded*/ ctx[8]);
    			add_location(img, file$i, 228, 8, 5660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "load", /*load_handler_1*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fullwidth, imageArray*/ 33 && img.src !== (img_src_value = /*fullwidth*/ ctx[5]
    			? urlFor(/*image*/ ctx[16]).width(1800).height(1200).quality(90).auto("format").url()
    			: urlFor(/*image*/ ctx[16]).width(1200 / /*imageArray*/ ctx[0].length).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*caption*/ 2 && img_alt_value !== (img_alt_value = /*caption*/ ctx[1]
    			? /*caption*/ ctx[1]
    			: "novembre.global")) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*loaded*/ 256) {
    				toggle_class(img, "loaded", /*loaded*/ ctx[8]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(228:6) {#each imageArray as image}",
    		ctx
    	});

    	return block;
    }

    // (199:6) {#each imageArray as image}
    function create_each_block$6(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");

    			if (img.src !== (img_src_value = /*fullwidth*/ ctx[5]
    			? urlFor(/*image*/ ctx[16]).width(1800).height(1200).quality(90).auto("format").url()
    			: urlFor(/*image*/ ctx[16]).width(1200 / /*imageArray*/ ctx[0].length).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", img_alt_value = /*caption*/ ctx[1]
    			? /*caption*/ ctx[1]
    			: "novembre.global");

    			attr_dev(img, "class", "svelte-96fjme");
    			toggle_class(img, "loaded", /*loaded*/ ctx[8]);
    			add_location(img, file$i, 199, 8, 4691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "load", /*load_handler*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fullwidth, imageArray*/ 33 && img.src !== (img_src_value = /*fullwidth*/ ctx[5]
    			? urlFor(/*image*/ ctx[16]).width(1800).height(1200).quality(90).auto("format").url()
    			: urlFor(/*image*/ ctx[16]).width(1200 / /*imageArray*/ ctx[0].length).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*caption*/ 2 && img_alt_value !== (img_alt_value = /*caption*/ ctx[1]
    			? /*caption*/ ctx[1]
    			: "novembre.global")) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*loaded*/ 256) {
    				toggle_class(img, "loaded", /*loaded*/ ctx[8]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(199:6) {#each imageArray as image}",
    		ctx
    	});

    	return block;
    }

    // (246:2) {#if caption}
    function create_if_block$c(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*caption*/ ctx[1]);
    			attr_dev(div, "class", "caption svelte-96fjme");
    			add_location(div, file$i, 246, 4, 6173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*caption*/ 2) set_data_dev(t, /*caption*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(246:2) {#if caption}",
    		ctx
    	});

    	return block;
    }

    // (184:0) <MediaQuery query="(min-width: 800px)" let:matches>
    function create_default_slot$4(ctx) {
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*linkUrl*/ ctx[7]) return create_if_block_1$9;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*caption*/ ctx[1] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			}

    			if (/*caption*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$c(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(184:0) <MediaQuery query=\\\"(min-width: 800px)\\\" let:matches>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let mediaquery;
    	let current;

    	mediaquery = new MediaQuery({
    			props: {
    				query: "(min-width: 800px)",
    				$$slots: {
    					default: [
    						create_default_slot$4,
    						({ matches }) => ({ 15: matches }),
    						({ matches }) => matches ? 32768 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mediaquery.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(mediaquery, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mediaquery_changes = {};

    			if (dirty & /*$$scope, caption, linkUrl, alignment, matches, isListing, isHeader, fullwidth, imageArray, inlineDisplay, loaded*/ 2130431) {
    				mediaquery_changes.$$scope = { dirty, ctx };
    			}

    			mediaquery.$set(mediaquery_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mediaquery.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mediaquery.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mediaquery, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ImageGroup", slots, []);
    	let { imageArray = [] } = $$props;
    	let { caption = false } = $$props;
    	let { isListing = false } = $$props;
    	let { isHeader = false } = $$props;
    	let { backgroundColor = false } = $$props;
    	let { alignment = "" } = $$props;
    	let { fullwidth = false } = $$props;
    	let { maxHeight = false } = $$props;
    	let { inlineDisplay = false } = $$props;
    	let { linkUrl = false } = $$props;

    	const customStyles = (maxHeight ? "height:" + maxHeight + "vh; " : "") + (backgroundColor
    	? "background:" + backgroundColor.hex + ";"
    	: "");

    	const customStylesPhone = backgroundColor
    	? "background:" + backgroundColor.hex + ";"
    	: "";

    	let loaded = false;

    	const writable_props = [
    		"imageArray",
    		"caption",
    		"isListing",
    		"isHeader",
    		"backgroundColor",
    		"alignment",
    		"fullwidth",
    		"maxHeight",
    		"inlineDisplay",
    		"linkUrl"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ImageGroup> was created with unknown prop '${key}'`);
    	});

    	const load_handler = e => $$invalidate(8, loaded = true);
    	const load_handler_1 = e => $$invalidate(8, loaded = true);

    	$$self.$$set = $$props => {
    		if ("imageArray" in $$props) $$invalidate(0, imageArray = $$props.imageArray);
    		if ("caption" in $$props) $$invalidate(1, caption = $$props.caption);
    		if ("isListing" in $$props) $$invalidate(2, isListing = $$props.isListing);
    		if ("isHeader" in $$props) $$invalidate(3, isHeader = $$props.isHeader);
    		if ("backgroundColor" in $$props) $$invalidate(11, backgroundColor = $$props.backgroundColor);
    		if ("alignment" in $$props) $$invalidate(4, alignment = $$props.alignment);
    		if ("fullwidth" in $$props) $$invalidate(5, fullwidth = $$props.fullwidth);
    		if ("maxHeight" in $$props) $$invalidate(12, maxHeight = $$props.maxHeight);
    		if ("inlineDisplay" in $$props) $$invalidate(6, inlineDisplay = $$props.inlineDisplay);
    		if ("linkUrl" in $$props) $$invalidate(7, linkUrl = $$props.linkUrl);
    	};

    	$$self.$capture_state = () => ({
    		MediaQuery,
    		urlFor,
    		imageArray,
    		caption,
    		isListing,
    		isHeader,
    		backgroundColor,
    		alignment,
    		fullwidth,
    		maxHeight,
    		inlineDisplay,
    		linkUrl,
    		customStyles,
    		customStylesPhone,
    		loaded
    	});

    	$$self.$inject_state = $$props => {
    		if ("imageArray" in $$props) $$invalidate(0, imageArray = $$props.imageArray);
    		if ("caption" in $$props) $$invalidate(1, caption = $$props.caption);
    		if ("isListing" in $$props) $$invalidate(2, isListing = $$props.isListing);
    		if ("isHeader" in $$props) $$invalidate(3, isHeader = $$props.isHeader);
    		if ("backgroundColor" in $$props) $$invalidate(11, backgroundColor = $$props.backgroundColor);
    		if ("alignment" in $$props) $$invalidate(4, alignment = $$props.alignment);
    		if ("fullwidth" in $$props) $$invalidate(5, fullwidth = $$props.fullwidth);
    		if ("maxHeight" in $$props) $$invalidate(12, maxHeight = $$props.maxHeight);
    		if ("inlineDisplay" in $$props) $$invalidate(6, inlineDisplay = $$props.inlineDisplay);
    		if ("linkUrl" in $$props) $$invalidate(7, linkUrl = $$props.linkUrl);
    		if ("loaded" in $$props) $$invalidate(8, loaded = $$props.loaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		imageArray,
    		caption,
    		isListing,
    		isHeader,
    		alignment,
    		fullwidth,
    		inlineDisplay,
    		linkUrl,
    		loaded,
    		customStyles,
    		customStylesPhone,
    		backgroundColor,
    		maxHeight,
    		load_handler,
    		load_handler_1
    	];
    }

    class ImageGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			imageArray: 0,
    			caption: 1,
    			isListing: 2,
    			isHeader: 3,
    			backgroundColor: 11,
    			alignment: 4,
    			fullwidth: 5,
    			maxHeight: 12,
    			inlineDisplay: 6,
    			linkUrl: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageGroup",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get imageArray() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageArray(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caption() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caption(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListing() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListing(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isHeader() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isHeader(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundColor() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundColor(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get alignment() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alignment(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fullwidth() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fullwidth(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxHeight() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxHeight(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inlineDisplay() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inlineDisplay(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get linkUrl() {
    		throw new Error("<ImageGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set linkUrl(value) {
    		throw new Error("<ImageGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var imagesloaded = createCommonjsModule(function (module) {
    /*!
     * imagesLoaded v4.1.4
     * JavaScript is all like "You images are done yet or what?"
     * MIT License
     */

    ( function( window, factory ) {  // universal module definition

      /*global define: false, module: false, require: false */

      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          window,
          evEmitter
        );
      } else {
        // browser global
        window.imagesLoaded = factory(
          window,
          window.EvEmitter
        );
      }

    })( typeof window !== 'undefined' ? window : commonjsGlobal,

    // --------------------------  factory -------------------------- //

    function factory( window, EvEmitter ) {

    var $ = window.jQuery;
    var console = window.console;

    // -------------------------- helpers -------------------------- //

    // extend objects
    function extend( a, b ) {
      for ( var prop in b ) {
        a[ prop ] = b[ prop ];
      }
      return a;
    }

    var arraySlice = Array.prototype.slice;

    // turn element or nodeList into an array
    function makeArray( obj ) {
      if ( Array.isArray( obj ) ) {
        // use object if already an array
        return obj;
      }

      var isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
      if ( isArrayLike ) {
        // convert nodeList to array
        return arraySlice.call( obj );
      }

      // array of single index
      return [ obj ];
    }

    // -------------------------- imagesLoaded -------------------------- //

    /**
     * @param {Array, Element, NodeList, String} elem
     * @param {Object or Function} options - if function, use as callback
     * @param {Function} onAlways - callback function
     */
    function ImagesLoaded( elem, options, onAlways ) {
      // coerce ImagesLoaded() without new, to be new ImagesLoaded()
      if ( !( this instanceof ImagesLoaded ) ) {
        return new ImagesLoaded( elem, options, onAlways );
      }
      // use elem as selector string
      var queryElem = elem;
      if ( typeof elem == 'string' ) {
        queryElem = document.querySelectorAll( elem );
      }
      // bail if bad element
      if ( !queryElem ) {
        console.error( 'Bad element for imagesLoaded ' + ( queryElem || elem ) );
        return;
      }

      this.elements = makeArray( queryElem );
      this.options = extend( {}, this.options );
      // shift arguments if no options set
      if ( typeof options == 'function' ) {
        onAlways = options;
      } else {
        extend( this.options, options );
      }

      if ( onAlways ) {
        this.on( 'always', onAlways );
      }

      this.getImages();

      if ( $ ) {
        // add jQuery Deferred object
        this.jqDeferred = new $.Deferred();
      }

      // HACK check async to allow time to bind listeners
      setTimeout( this.check.bind( this ) );
    }

    ImagesLoaded.prototype = Object.create( EvEmitter.prototype );

    ImagesLoaded.prototype.options = {};

    ImagesLoaded.prototype.getImages = function() {
      this.images = [];

      // filter & find items if we have an item selector
      this.elements.forEach( this.addElementImages, this );
    };

    /**
     * @param {Node} element
     */
    ImagesLoaded.prototype.addElementImages = function( elem ) {
      // filter siblings
      if ( elem.nodeName == 'IMG' ) {
        this.addImage( elem );
      }
      // get background image on element
      if ( this.options.background === true ) {
        this.addElementBackgroundImages( elem );
      }

      // find children
      // no non-element nodes, #143
      var nodeType = elem.nodeType;
      if ( !nodeType || !elementNodeTypes[ nodeType ] ) {
        return;
      }
      var childImgs = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( var i=0; i < childImgs.length; i++ ) {
        var img = childImgs[i];
        this.addImage( img );
      }

      // get child background images
      if ( typeof this.options.background == 'string' ) {
        var children = elem.querySelectorAll( this.options.background );
        for ( i=0; i < children.length; i++ ) {
          var child = children[i];
          this.addElementBackgroundImages( child );
        }
      }
    };

    var elementNodeTypes = {
      1: true,
      9: true,
      11: true
    };

    ImagesLoaded.prototype.addElementBackgroundImages = function( elem ) {
      var style = getComputedStyle( elem );
      if ( !style ) {
        // Firefox returns null if in a hidden iframe https://bugzil.la/548397
        return;
      }
      // get url inside url("...")
      var reURL = /url\((['"])?(.*?)\1\)/gi;
      var matches = reURL.exec( style.backgroundImage );
      while ( matches !== null ) {
        var url = matches && matches[2];
        if ( url ) {
          this.addBackground( url, elem );
        }
        matches = reURL.exec( style.backgroundImage );
      }
    };

    /**
     * @param {Image} img
     */
    ImagesLoaded.prototype.addImage = function( img ) {
      var loadingImage = new LoadingImage( img );
      this.images.push( loadingImage );
    };

    ImagesLoaded.prototype.addBackground = function( url, elem ) {
      var background = new Background( url, elem );
      this.images.push( background );
    };

    ImagesLoaded.prototype.check = function() {
      var _this = this;
      this.progressedCount = 0;
      this.hasAnyBroken = false;
      // complete if no images
      if ( !this.images.length ) {
        this.complete();
        return;
      }

      function onProgress( image, elem, message ) {
        // HACK - Chrome triggers event before object properties have changed. #83
        setTimeout( function() {
          _this.progress( image, elem, message );
        });
      }

      this.images.forEach( function( loadingImage ) {
        loadingImage.once( 'progress', onProgress );
        loadingImage.check();
      });
    };

    ImagesLoaded.prototype.progress = function( image, elem, message ) {
      this.progressedCount++;
      this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
      // progress event
      this.emitEvent( 'progress', [ this, image, elem ] );
      if ( this.jqDeferred && this.jqDeferred.notify ) {
        this.jqDeferred.notify( this, image );
      }
      // check if completed
      if ( this.progressedCount == this.images.length ) {
        this.complete();
      }

      if ( this.options.debug && console ) {
        console.log( 'progress: ' + message, image, elem );
      }
    };

    ImagesLoaded.prototype.complete = function() {
      var eventName = this.hasAnyBroken ? 'fail' : 'done';
      this.isComplete = true;
      this.emitEvent( eventName, [ this ] );
      this.emitEvent( 'always', [ this ] );
      if ( this.jqDeferred ) {
        var jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';
        this.jqDeferred[ jqMethod ]( this );
      }
    };

    // --------------------------  -------------------------- //

    function LoadingImage( img ) {
      this.img = img;
    }

    LoadingImage.prototype = Object.create( EvEmitter.prototype );

    LoadingImage.prototype.check = function() {
      // If complete is true and browser supports natural sizes,
      // try to check for image status manually.
      var isComplete = this.getIsImageComplete();
      if ( isComplete ) {
        // report based on naturalWidth
        this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
        return;
      }

      // If none of the checks above matched, simulate loading on detached element.
      this.proxyImage = new Image();
      this.proxyImage.addEventListener( 'load', this );
      this.proxyImage.addEventListener( 'error', this );
      // bind to image as well for Firefox. #191
      this.img.addEventListener( 'load', this );
      this.img.addEventListener( 'error', this );
      this.proxyImage.src = this.img.src;
    };

    LoadingImage.prototype.getIsImageComplete = function() {
      // check for non-zero, non-undefined naturalWidth
      // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671
      return this.img.complete && this.img.naturalWidth;
    };

    LoadingImage.prototype.confirm = function( isLoaded, message ) {
      this.isLoaded = isLoaded;
      this.emitEvent( 'progress', [ this, this.img, message ] );
    };

    // ----- events ----- //

    // trigger specified handler for event type
    LoadingImage.prototype.handleEvent = function( event ) {
      var method = 'on' + event.type;
      if ( this[ method ] ) {
        this[ method ]( event );
      }
    };

    LoadingImage.prototype.onload = function() {
      this.confirm( true, 'onload' );
      this.unbindEvents();
    };

    LoadingImage.prototype.onerror = function() {
      this.confirm( false, 'onerror' );
      this.unbindEvents();
    };

    LoadingImage.prototype.unbindEvents = function() {
      this.proxyImage.removeEventListener( 'load', this );
      this.proxyImage.removeEventListener( 'error', this );
      this.img.removeEventListener( 'load', this );
      this.img.removeEventListener( 'error', this );
    };

    // -------------------------- Background -------------------------- //

    function Background( url, element ) {
      this.url = url;
      this.element = element;
      this.img = new Image();
    }

    // inherit LoadingImage prototype
    Background.prototype = Object.create( LoadingImage.prototype );

    Background.prototype.check = function() {
      this.img.addEventListener( 'load', this );
      this.img.addEventListener( 'error', this );
      this.img.src = this.url;
      // check if image is already complete
      var isComplete = this.getIsImageComplete();
      if ( isComplete ) {
        this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
        this.unbindEvents();
      }
    };

    Background.prototype.unbindEvents = function() {
      this.img.removeEventListener( 'load', this );
      this.img.removeEventListener( 'error', this );
    };

    Background.prototype.confirm = function( isLoaded, message ) {
      this.isLoaded = isLoaded;
      this.emitEvent( 'progress', [ this, this.element, message ] );
    };

    // -------------------------- jQuery -------------------------- //

    ImagesLoaded.makeJQueryPlugin = function( jQuery ) {
      jQuery = jQuery || window.jQuery;
      if ( !jQuery ) {
        return;
      }
      // set local variable
      $ = jQuery;
      // $().imagesLoaded()
      $.fn.imagesLoaded = function( options, callback ) {
        var instance = new ImagesLoaded( this, options, callback );
        return instance.jqDeferred.promise( $(this) );
      };
    };
    // try making plugin
    ImagesLoaded.makeJQueryPlugin();

    // --------------------------  -------------------------- //

    return ImagesLoaded;

    });
    });

    /* src/Components/Ellipse.svelte generated by Svelte v3.35.0 */
    const file$h = "src/Components/Ellipse.svelte";

    function create_fragment$h(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*text*/ ctx[0]);
    			add_location(span, file$h, 29, 0, 498);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const NUMBER_OF_PERIODS = 5;

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Ellipse", slots, []);
    	let text = "";
    	let timer = {};

    	// *** ON MOUNT
    	onMount(async () => {
    		timer = setInterval(
    			() => {
    				$$invalidate(0, text = text.length < NUMBER_OF_PERIODS ? text + "." : "");
    			},
    			500
    		);
    	});

    	// *** ON DESTROY
    	onDestroy(() => {
    		clearInterval(timer);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Ellipse> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		text,
    		timer,
    		NUMBER_OF_PERIODS
    	});

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    		if ("timer" in $$props) timer = $$props.timer;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text];
    }

    class Ellipse extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ellipse",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    var asNavFor = createCommonjsModule(function (module) {
    /*!
     * Flickity asNavFor v2.0.1
     * enable asNavFor for Flickity
     */

    /*jshint browser: true, undef: true, unused: true, strict: true*/

    ( function( window, factory ) {
      // universal module definition
      /*jshint strict: false */ /*globals define, module, require */
      if ( module.exports ) {
        // CommonJS
        module.exports = factory(
          js,
          utils
        );
      } else {
        // browser global
        window.Flickity = factory(
          window.Flickity,
          window.fizzyUIUtils
        );
      }

    }( window, function factory( Flickity, utils ) {

    // -------------------------- asNavFor prototype -------------------------- //

    // Flickity.defaults.asNavFor = null;

    Flickity.createMethods.push('_createAsNavFor');

    var proto = Flickity.prototype;

    proto._createAsNavFor = function() {
      this.on( 'activate', this.activateAsNavFor );
      this.on( 'deactivate', this.deactivateAsNavFor );
      this.on( 'destroy', this.destroyAsNavFor );

      var asNavForOption = this.options.asNavFor;
      if ( !asNavForOption ) {
        return;
      }
      // HACK do async, give time for other flickity to be initalized
      var _this = this;
      setTimeout( function initNavCompanion() {
        _this.setNavCompanion( asNavForOption );
      });
    };

    proto.setNavCompanion = function( elem ) {
      elem = utils.getQueryElement( elem );
      var companion = Flickity.data( elem );
      // stop if no companion or companion is self
      if ( !companion || companion == this ) {
        return;
      }

      this.navCompanion = companion;
      // companion select
      var _this = this;
      this.onNavCompanionSelect = function() {
        _this.navCompanionSelect();
      };
      companion.on( 'select', this.onNavCompanionSelect );
      // click
      this.on( 'staticClick', this.onNavStaticClick );

      this.navCompanionSelect( true );
    };

    proto.navCompanionSelect = function( isInstant ) {
      if ( !this.navCompanion ) {
        return;
      }
      // select slide that matches first cell of slide
      var selectedCell = this.navCompanion.selectedCells[0];
      var firstIndex = this.navCompanion.cells.indexOf( selectedCell );
      var lastIndex = firstIndex + this.navCompanion.selectedCells.length - 1;
      var selectIndex = Math.floor( lerp( firstIndex, lastIndex,
        this.navCompanion.cellAlign ) );
      this.selectCell( selectIndex, false, isInstant );
      // set nav selected class
      this.removeNavSelectedElements();
      // stop if companion has more cells than this one
      if ( selectIndex >= this.cells.length ) {
        return;
      }

      var selectedCells = this.cells.slice( firstIndex, lastIndex + 1 );
      this.navSelectedElements = selectedCells.map( function( cell ) {
        return cell.element;
      });
      this.changeNavSelectedClass('add');
    };

    function lerp( a, b, t ) {
      return ( b - a ) * t + a;
    }

    proto.changeNavSelectedClass = function( method ) {
      this.navSelectedElements.forEach( function( navElem ) {
        navElem.classList[ method ]('is-nav-selected');
      });
    };

    proto.activateAsNavFor = function() {
      this.navCompanionSelect( true );
    };

    proto.removeNavSelectedElements = function() {
      if ( !this.navSelectedElements ) {
        return;
      }
      this.changeNavSelectedClass('remove');
      delete this.navSelectedElements;
    };

    proto.onNavStaticClick = function( event, pointer, cellElement, cellIndex ) {
      if ( typeof cellIndex == 'number' ) {
        this.navCompanion.selectCell( cellIndex );
      }
    };

    proto.deactivateAsNavFor = function() {
      this.removeNavSelectedElements();
    };

    proto.destroyAsNavFor = function() {
      if ( !this.navCompanion ) {
        return;
      }
      this.navCompanion.off( 'select', this.onNavCompanionSelect );
      this.off( 'staticClick', this.onNavStaticClick );
      delete this.navCompanion;
    };

    // -----  ----- //

    return Flickity;

    }));
    });

    /* src/Components/Modules/navShow.svelte generated by Svelte v3.35.0 */

    const file$g = "src/Components/Modules/navShow.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (123:4) {#each imageArray as slide}
    function create_each_block$5(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t = space();
    			attr_dev(img, "alt", "novembre.global");
    			attr_dev(img, "class", "slideshow__slide-image svelte-kpmv3x");
    			if (img.src !== (img_src_value = urlFor(/*slide*/ ctx[6]).height(140).quality(80).auto("format").url())) attr_dev(img, "src", img_src_value);
    			add_location(img, file$g, 124, 8, 2690);
    			attr_dev(div, "class", "carousel-cell slideshow__slide svelte-kpmv3x");
    			add_location(div, file$g, 123, 6, 2637);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img.src !== (img_src_value = urlFor(/*slide*/ ctx[6]).height(140).quality(80).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(123:4) {#each imageArray as slide}",
    		ctx
    	});

    	return block;
    }

    // (137:2) {#if !loaded}
    function create_if_block$b(ctx) {
    	let div;
    	let t;
    	let ellipse;
    	let current;
    	ellipse = new Ellipse({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("LOADING\n      ");
    			create_component(ellipse.$$.fragment);
    			attr_dev(div, "class", "loading svelte-kpmv3x");
    			add_location(div, file$g, 137, 4, 2953);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			mount_component(ellipse, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ellipse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ellipse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(ellipse);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(137:2) {#if !loaded}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let current;
    	let each_value = /*imageArray*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	let if_block = !/*loaded*/ ctx[2] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "carousel slideshow svelte-kpmv3x");
    			toggle_class(div0, "loaded", /*loaded*/ ctx[2]);
    			add_location(div0, file$g, 121, 2, 2529);
    			attr_dev(div1, "class", "container svelte-kpmv3x");
    			add_location(div1, file$g, 120, 0, 2503);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div0_binding*/ ctx[4](div0);
    			append_dev(div1, t);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*urlFor, imageArray*/ 1) {
    				each_value = /*imageArray*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*loaded*/ 4) {
    				toggle_class(div0, "loaded", /*loaded*/ ctx[2]);
    			}

    			if (!/*loaded*/ ctx[2]) {
    				if (if_block) {
    					if (dirty & /*loaded*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			/*div0_binding*/ ctx[4](null);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavShow", slots, []);
    	let { imageArray = [] } = $$props;
    	let { navTarget = {} } = $$props;

    	// *** DOM REFERENCES
    	let slideShowEl = {};

    	// *** VARIABLES
    	let flkty = {};

    	let loaded = false;

    	// *** ON MOUNT
    	onMount(async () => {
    		let options = {
    			prevNextButtons: false,
    			pageDots: false,
    			asNavFor: navTarget,
    			freeScroll: true,
    			freeScrollFriction: 0.03,
    			contain: true
    		};

    		try {
    			flkty = new asNavFor(slideShowEl, options);
    		} catch(err) {
    			Sentry.captureException(err);
    		}

    		imagesloaded(slideShowEl, instance => {
    			try {
    				if (flkty && "resize" in flkty) {
    					flkty.resize();
    				}
    			} catch(err) {
    				Sentry.captureException(err);
    			}

    			$$invalidate(2, loaded = true);
    		});
    	});

    	const writable_props = ["imageArray", "navTarget"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavShow> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			slideShowEl = $$value;
    			$$invalidate(1, slideShowEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("imageArray" in $$props) $$invalidate(0, imageArray = $$props.imageArray);
    		if ("navTarget" in $$props) $$invalidate(3, navTarget = $$props.navTarget);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Flickity: asNavFor,
    		imagesLoaded: imagesloaded,
    		urlFor,
    		Ellipse,
    		imageArray,
    		navTarget,
    		slideShowEl,
    		flkty,
    		loaded
    	});

    	$$self.$inject_state = $$props => {
    		if ("imageArray" in $$props) $$invalidate(0, imageArray = $$props.imageArray);
    		if ("navTarget" in $$props) $$invalidate(3, navTarget = $$props.navTarget);
    		if ("slideShowEl" in $$props) $$invalidate(1, slideShowEl = $$props.slideShowEl);
    		if ("flkty" in $$props) flkty = $$props.flkty;
    		if ("loaded" in $$props) $$invalidate(2, loaded = $$props.loaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [imageArray, slideShowEl, loaded, navTarget, div0_binding];
    }

    class NavShow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { imageArray: 0, navTarget: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavShow",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get imageArray() {
    		throw new Error("<NavShow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageArray(value) {
    		throw new Error("<NavShow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navTarget() {
    		throw new Error("<NavShow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navTarget(value) {
    		throw new Error("<NavShow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Modules/Slideshow.svelte generated by Svelte v3.35.0 */
    const file$f = "src/Components/Modules/Slideshow.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    // (482:36) 
    function create_if_block_8$2(ctx) {
    	let div;

    	function select_block_type_3(ctx, dirty) {
    		if (/*isRelated*/ ctx[1]) return create_if_block_9$2;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "static-related single svelte-15i2c8t");
    			add_location(div, file$f, 482, 4, 12215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(482:36) ",
    		ctx
    	});

    	return block;
    }

    // (434:36) 
    function create_if_block_6$5(ctx) {
    	let div;

    	function select_block_type_2(ctx, dirty) {
    		if (/*isRelated*/ ctx[1]) return create_if_block_7$3;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "static-related double svelte-15i2c8t");
    			add_location(div, file$f, 434, 4, 10595);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$5.name,
    		type: "if",
    		source: "(434:36) ",
    		ctx
    	});

    	return block;
    }

    // (299:2) {#if imageArray.length > 2}
    function create_if_block$a(ctx) {
    	let div3;
    	let t0;
    	let div0;
    	let t1;
    	let div1;
    	let svg0;
    	let polyline0;
    	let t2;
    	let div2;
    	let svg1;
    	let polyline1;
    	let t3;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*loaded*/ ctx[6] && create_if_block_5$6(ctx);
    	let each_value = /*imageArray*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	let if_block1 = !/*isListing*/ ctx[2] && !/*isRelated*/ ctx[1] && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			svg0 = svg_element("svg");
    			polyline0 = svg_element("polyline");
    			t2 = space();
    			div2 = element("div");
    			svg1 = svg_element("svg");
    			polyline1 = svg_element("polyline");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(div0, "class", "carousel slideshow svelte-15i2c8t");
    			toggle_class(div0, "slideshow--related", /*isRelated*/ ctx[1]);
    			toggle_class(div0, "slideshow--preview", /*isListing*/ ctx[2]);
    			toggle_class(div0, "loaded", /*loaded*/ ctx[6]);
    			add_location(div0, file$f, 322, 6, 7270);
    			attr_dev(polyline0, "points", "15 18 9 12 15 6");
    			add_location(polyline0, file$f, 386, 10, 9348);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "80");
    			attr_dev(svg0, "height", "120");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "stroke", "white");
    			attr_dev(svg0, "stroke-width", "0.5");
    			attr_dev(svg0, "class", "feather feather-chevron-left arrow svelte-15i2c8t");
    			add_location(svg0, file$f, 377, 8, 9084);
    			attr_dev(div1, "class", "navigation previous svelte-15i2c8t");
    			attr_dev(div1, "type", "button");
    			attr_dev(div1, "aria-label", "Previous");
    			toggle_class(div1, "hovered", /*hovered*/ ctx[7]);
    			add_location(div1, file$f, 367, 6, 8835);
    			attr_dev(polyline1, "points", "9 18 15 12 9 6");
    			add_location(polyline1, file$f, 409, 10, 9934);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "80");
    			attr_dev(svg1, "height", "120");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "stroke", "white");
    			attr_dev(svg1, "stroke-width", "0.5");
    			attr_dev(svg1, "class", "feather feather-chevron-left arrow svelte-15i2c8t");
    			add_location(svg1, file$f, 400, 8, 9670);
    			attr_dev(div2, "class", "navigation next svelte-15i2c8t");
    			attr_dev(div2, "type", "button");
    			attr_dev(div2, "aria-label", "Previous");
    			toggle_class(div2, "hovered", /*hovered*/ ctx[7]);
    			add_location(div2, file$f, 390, 6, 9421);
    			attr_dev(div3, "class", "container svelte-15i2c8t");
    			add_location(div3, file$f, 299, 4, 6737);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t0);
    			append_dev(div3, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div0_binding*/ ctx[10](div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, svg0);
    			append_dev(svg0, polyline0);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, svg1);
    			append_dev(svg1, polyline1);
    			insert_dev(target, t3, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(links.call(null, div0)),
    					listen_dev(div1, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(div2, "click", /*click_handler_1*/ ctx[12], false, false, false),
    					listen_dev(div3, "mouseenter", /*mouseenter_handler*/ ctx[13], false, false, false),
    					listen_dev(div3, "mouseleave", /*mouseleave_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!/*loaded*/ ctx[6]) {
    				if (if_block0) {
    					if (dirty & /*loaded*/ 64) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div3, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*imageArray, get, urlFor, isRelated*/ 3) {
    				each_value = /*imageArray*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*isRelated*/ 2) {
    				toggle_class(div0, "slideshow--related", /*isRelated*/ ctx[1]);
    			}

    			if (dirty & /*isListing*/ 4) {
    				toggle_class(div0, "slideshow--preview", /*isListing*/ ctx[2]);
    			}

    			if (dirty & /*loaded*/ 64) {
    				toggle_class(div0, "loaded", /*loaded*/ ctx[6]);
    			}

    			if (dirty & /*hovered*/ 128) {
    				toggle_class(div1, "hovered", /*hovered*/ ctx[7]);
    			}

    			if (dirty & /*hovered*/ 128) {
    				toggle_class(div2, "hovered", /*hovered*/ ctx[7]);
    			}

    			if (!/*isListing*/ ctx[2] && !/*isRelated*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isListing, isRelated*/ 6) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			/*div0_binding*/ ctx[10](null);
    			if (detaching) detach_dev(t3);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(299:2) {#if imageArray.length > 2}",
    		ctx
    	});

    	return block;
    }

    // (499:6) {:else}
    function create_else_block_2(ctx) {
    	let img;
    	let img_src_value;
    	let img_alt_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = urlFor(/*imageArray*/ ctx[0][0].mainImage).width(1200).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*imageArray*/ ctx[0][0].title);
    			attr_dev(img, "class", "svelte-15i2c8t");
    			add_location(img, file$f, 499, 8, 12833);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img.src !== (img_src_value = urlFor(/*imageArray*/ ctx[0][0].mainImage).width(1200).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img_alt_value !== (img_alt_value = /*imageArray*/ ctx[0][0].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(499:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (484:6) {#if isRelated}
    function create_if_block_9$2(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t;
    	let div;
    	let raw_value = /*imageArray*/ ctx[0][0].title + "";
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			t = space();
    			div = element("div");
    			if (img.src !== (img_src_value = urlFor(get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.image", /*imageArray*/ ctx[0][0].mainImage)).width(1200).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*imageArray*/ ctx[0][0].title);
    			attr_dev(img, "class", "svelte-15i2c8t");
    			add_location(img, file$f, 485, 10, 12349);
    			attr_dev(div, "class", "slideshow__title svelte-15i2c8t");
    			set_style(div, "color", get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.textColor.hex", "white"));
    			add_location(div, file$f, 492, 10, 12606);
    			attr_dev(a, "href", a_href_value = "/" + /*imageArray*/ ctx[0][0].category + "/" + /*imageArray*/ ctx[0][0].slug);
    			attr_dev(a, "class", "svelte-15i2c8t");
    			add_location(a, file$f, 484, 8, 12281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    			append_dev(a, t);
    			append_dev(a, div);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img.src !== (img_src_value = urlFor(get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.image", /*imageArray*/ ctx[0][0].mainImage)).width(1200).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img_alt_value !== (img_alt_value = /*imageArray*/ ctx[0][0].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*imageArray*/ 1 && raw_value !== (raw_value = /*imageArray*/ ctx[0][0].title + "")) div.innerHTML = raw_value;
    			if (dirty & /*imageArray*/ 1) {
    				set_style(div, "color", get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.textColor.hex", "white"));
    			}

    			if (dirty & /*imageArray*/ 1 && a_href_value !== (a_href_value = "/" + /*imageArray*/ ctx[0][0].category + "/" + /*imageArray*/ ctx[0][0].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(484:6) {#if isRelated}",
    		ctx
    	});

    	return block;
    }

    // (465:6) {:else}
    function create_else_block_1(ctx) {
    	let img0;
    	let img0_src_value;
    	let img0_alt_value;
    	let t;
    	let img1;
    	let img1_src_value;
    	let img1_alt_value;

    	const block = {
    		c: function create() {
    			img0 = element("img");
    			t = space();
    			img1 = element("img");
    			if (img0.src !== (img0_src_value = urlFor(/*imageArray*/ ctx[0][0].mainImage).height(600).quality(90).auto("format").url())) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", img0_alt_value = /*imageArray*/ ctx[0][0].title);
    			attr_dev(img0, "class", "svelte-15i2c8t");
    			add_location(img0, file$f, 465, 8, 11765);
    			if (img1.src !== (img1_src_value = urlFor(/*imageArray*/ ctx[0][1].mainImage).height(600).quality(90).auto("format").url())) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", img1_alt_value = /*imageArray*/ ctx[0][1].title);
    			attr_dev(img1, "class", "svelte-15i2c8t");
    			add_location(img1, file$f, 472, 8, 11962);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img0, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, img1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img0.src !== (img0_src_value = urlFor(/*imageArray*/ ctx[0][0].mainImage).height(600).quality(90).auto("format").url())) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img0_alt_value !== (img0_alt_value = /*imageArray*/ ctx[0][0].title)) {
    				attr_dev(img0, "alt", img0_alt_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img1.src !== (img1_src_value = urlFor(/*imageArray*/ ctx[0][1].mainImage).height(600).quality(90).auto("format").url())) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img1_alt_value !== (img1_alt_value = /*imageArray*/ ctx[0][1].title)) {
    				attr_dev(img1, "alt", img1_alt_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(img1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(465:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (436:6) {#if isRelated}
    function create_if_block_7$3(ctx) {
    	let a0;
    	let img0;
    	let img0_src_value;
    	let img0_alt_value;
    	let t0;
    	let div0;
    	let raw0_value = /*imageArray*/ ctx[0][0].title + "";
    	let a0_href_value;
    	let t1;
    	let a1;
    	let img1;
    	let img1_src_value;
    	let img1_alt_value;
    	let t2;
    	let div1;
    	let raw1_value = /*imageArray*/ ctx[0][1].title + "";
    	let a1_href_value;

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			img0 = element("img");
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			a1 = element("a");
    			img1 = element("img");
    			t2 = space();
    			div1 = element("div");
    			if (img0.src !== (img0_src_value = urlFor(get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.image", /*imageArray*/ ctx[0][0].mainImage)).height(600).quality(80).auto("format").url())) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", img0_alt_value = /*imageArray*/ ctx[0][0].title);
    			attr_dev(img0, "class", "svelte-15i2c8t");
    			add_location(img0, file$f, 437, 10, 10729);
    			attr_dev(div0, "class", "slideshow__title double svelte-15i2c8t");
    			set_style(div0, "color", get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.textColor.hex", "white"));
    			add_location(div0, file$f, 444, 10, 10986);
    			attr_dev(a0, "href", a0_href_value = "/" + /*imageArray*/ ctx[0][0].category + "/" + /*imageArray*/ ctx[0][0].slug);
    			attr_dev(a0, "class", "svelte-15i2c8t");
    			add_location(a0, file$f, 436, 8, 10661);
    			if (img1.src !== (img1_src_value = urlFor(get_1(/*imageArray*/ ctx[0][1], "relatedSlideshow.image", /*imageArray*/ ctx[0][1].mainImage)).height(600).quality(80).auto("format").url())) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", img1_alt_value = /*imageArray*/ ctx[0][1].title);
    			attr_dev(img1, "class", "svelte-15i2c8t");
    			add_location(img1, file$f, 451, 10, 11274);
    			attr_dev(div1, "class", "slideshow__title double svelte-15i2c8t");
    			set_style(div1, "color", get_1(/*imageArray*/ ctx[0][1], "relatedSlideshow.textColor.hex", "white"));
    			add_location(div1, file$f, 458, 10, 11531);
    			attr_dev(a1, "href", a1_href_value = "/" + /*imageArray*/ ctx[0][1].category + "/" + /*imageArray*/ ctx[0][1].slug);
    			attr_dev(a1, "class", "svelte-15i2c8t");
    			add_location(a1, file$f, 450, 8, 11206);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, img0);
    			append_dev(a0, t0);
    			append_dev(a0, div0);
    			div0.innerHTML = raw0_value;
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, img1);
    			append_dev(a1, t2);
    			append_dev(a1, div1);
    			div1.innerHTML = raw1_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img0.src !== (img0_src_value = urlFor(get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.image", /*imageArray*/ ctx[0][0].mainImage)).height(600).quality(80).auto("format").url())) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img0_alt_value !== (img0_alt_value = /*imageArray*/ ctx[0][0].title)) {
    				attr_dev(img0, "alt", img0_alt_value);
    			}

    			if (dirty & /*imageArray*/ 1 && raw0_value !== (raw0_value = /*imageArray*/ ctx[0][0].title + "")) div0.innerHTML = raw0_value;
    			if (dirty & /*imageArray*/ 1) {
    				set_style(div0, "color", get_1(/*imageArray*/ ctx[0][0], "relatedSlideshow.textColor.hex", "white"));
    			}

    			if (dirty & /*imageArray*/ 1 && a0_href_value !== (a0_href_value = "/" + /*imageArray*/ ctx[0][0].category + "/" + /*imageArray*/ ctx[0][0].slug)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img1.src !== (img1_src_value = urlFor(get_1(/*imageArray*/ ctx[0][1], "relatedSlideshow.image", /*imageArray*/ ctx[0][1].mainImage)).height(600).quality(80).auto("format").url())) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img1_alt_value !== (img1_alt_value = /*imageArray*/ ctx[0][1].title)) {
    				attr_dev(img1, "alt", img1_alt_value);
    			}

    			if (dirty & /*imageArray*/ 1 && raw1_value !== (raw1_value = /*imageArray*/ ctx[0][1].title + "")) div1.innerHTML = raw1_value;
    			if (dirty & /*imageArray*/ 1) {
    				set_style(div1, "color", get_1(/*imageArray*/ ctx[0][1], "relatedSlideshow.textColor.hex", "white"));
    			}

    			if (dirty & /*imageArray*/ 1 && a1_href_value !== (a1_href_value = "/" + /*imageArray*/ ctx[0][1].category + "/" + /*imageArray*/ ctx[0][1].slug)) {
    				attr_dev(a1, "href", a1_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(436:6) {#if isRelated}",
    		ctx
    	});

    	return block;
    }

    // (315:6) {#if !loaded}
    function create_if_block_5$6(ctx) {
    	let div;
    	let t;
    	let ellipse;
    	let current;
    	ellipse = new Ellipse({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("LOADING\n          ");
    			create_component(ellipse.$$.fragment);
    			attr_dev(div, "class", "loading svelte-15i2c8t");
    			add_location(div, file$f, 315, 8, 7154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			mount_component(ellipse, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ellipse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ellipse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(ellipse);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$6.name,
    		type: "if",
    		source: "(315:6) {#if !loaded}",
    		ctx
    	});

    	return block;
    }

    // (350:10) {:else}
    function create_else_block$3(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t0;
    	let t1;
    	let if_block = /*slide*/ ctx[20].caption && create_if_block_4$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(img, "class", "slideshow__slide-image svelte-15i2c8t");
    			if (img.src !== (img_src_value = urlFor(/*slide*/ ctx[20]).height(600).quality(80).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*slide*/ ctx[20].caption);
    			add_location(img, file$f, 351, 14, 8386);
    			attr_dev(div, "class", "carousel-cell slideshow__slide svelte-15i2c8t");
    			add_location(div, file$f, 350, 12, 8327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img.src !== (img_src_value = urlFor(/*slide*/ ctx[20]).height(600).quality(80).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img_alt_value !== (img_alt_value = /*slide*/ ctx[20].caption)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (/*slide*/ ctx[20].caption) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$6(ctx);
    					if_block.c();
    					if_block.m(div, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(350:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (331:10) {#if isRelated}
    function create_if_block_3$6(ctx) {
    	let div1;
    	let a;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let t0;
    	let div0;
    	let raw_value = /*slide*/ ctx[20].title + "";
    	let a_href_value;
    	let t1;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			a = element("a");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			attr_dev(img, "class", "slideshow__slide-image slideshow__slide-image--related svelte-15i2c8t");
    			if (img.src !== (img_src_value = urlFor(get_1(/*slide*/ ctx[20], "relatedSlideshow.image", /*slide*/ ctx[20].mainImage)).height(600).quality(80).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", img_alt_value = /*slide*/ ctx[20].title);
    			add_location(img, file$f, 334, 16, 7703);
    			attr_dev(div0, "class", "slideshow__title svelte-15i2c8t");
    			set_style(div0, "color", get_1(/*slide*/ ctx[20], "relatedSlideshow.textColor.hex", "white"));
    			add_location(div0, file$f, 342, 16, 8059);
    			attr_dev(a, "href", a_href_value = "/" + /*slide*/ ctx[20].category + "/" + /*slide*/ ctx[20].slug);
    			attr_dev(a, "class", "svelte-15i2c8t");
    			add_location(a, file$f, 333, 14, 7645);
    			attr_dev(div1, "class", "carousel-cell slideshow__slide slideshow__slide--related svelte-15i2c8t");
    			add_location(div1, file$f, 331, 12, 7546);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a);
    			append_dev(a, img);
    			append_dev(a, t0);
    			append_dev(a, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && img.src !== (img_src_value = urlFor(get_1(/*slide*/ ctx[20], "relatedSlideshow.image", /*slide*/ ctx[20].mainImage)).height(600).quality(80).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*imageArray*/ 1 && img_alt_value !== (img_alt_value = /*slide*/ ctx[20].title)) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*imageArray*/ 1 && raw_value !== (raw_value = /*slide*/ ctx[20].title + "")) div0.innerHTML = raw_value;
    			if (dirty & /*imageArray*/ 1) {
    				set_style(div0, "color", get_1(/*slide*/ ctx[20], "relatedSlideshow.textColor.hex", "white"));
    			}

    			if (dirty & /*imageArray*/ 1 && a_href_value !== (a_href_value = "/" + /*slide*/ ctx[20].category + "/" + /*slide*/ ctx[20].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(331:10) {#if isRelated}",
    		ctx
    	});

    	return block;
    }

    // (360:14) {#if slide.caption}
    function create_if_block_4$6(ctx) {
    	let div;
    	let t_value = /*slide*/ ctx[20].caption + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "slideshow__slide-caption svelte-15i2c8t");
    			add_location(div, file$f, 360, 16, 8684);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageArray*/ 1 && t_value !== (t_value = /*slide*/ ctx[20].caption + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(360:14) {#if slide.caption}",
    		ctx
    	});

    	return block;
    }

    // (330:8) {#each imageArray as slide}
    function create_each_block$4(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isRelated*/ ctx[1]) return create_if_block_3$6;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(330:8) {#each imageArray as slide}",
    		ctx
    	});

    	return block;
    }

    // (414:4) {#if !isListing && !isRelated}
    function create_if_block_1$8(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*loaded*/ ctx[6] && !/*isListing*/ ctx[2] && !/*isRelated*/ ctx[1] && create_if_block_2$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "nav-container svelte-15i2c8t");
    			add_location(div, file$f, 414, 6, 10051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseenter", /*mouseenter_handler_1*/ ctx[15], false, false, false),
    					listen_dev(div, "mouseleave", /*mouseleave_handler_1*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*loaded*/ ctx[6] && !/*isListing*/ ctx[2] && !/*isRelated*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*loaded, isListing, isRelated*/ 70) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(414:4) {#if !isListing && !isRelated}",
    		ctx
    	});

    	return block;
    }

    // (429:8) {#if loaded && !isListing && !isRelated}
    function create_if_block_2$6(ctx) {
    	let navshow;
    	let current;

    	navshow = new NavShow({
    			props: {
    				imageArray: /*imageArray*/ ctx[0],
    				navTarget: /*slideShowEl*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navshow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navshow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navshow_changes = {};
    			if (dirty & /*imageArray*/ 1) navshow_changes.imageArray = /*imageArray*/ ctx[0];
    			if (dirty & /*slideShowEl*/ 16) navshow_changes.navTarget = /*slideShowEl*/ ctx[4];
    			navshow.$set(navshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navshow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(429:8) {#if loaded && !isListing && !isRelated}",
    		ctx
    	});

    	return block;
    }

    // (298:0) <Router>
    function create_default_slot$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_if_block_6$5, create_if_block_8$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*imageArray*/ ctx[0].length > 2) return 0;
    		if (/*imageArray*/ ctx[0].length === 2) return 1;
    		if (/*imageArray*/ ctx[0].length === 1) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(298:0) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, hovered, autoplay, imageArray, slideShowEl, loaded, isListing, isRelated, flkty*/ 8388863) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const tickerSpeed = 0.4;

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Slideshow", slots, []);
    	let { imageArray = [] } = $$props;
    	let { isRelated = false } = $$props;
    	let { isListing = false } = $$props;
    	let { autoplay = false } = $$props;

    	// *** DOM REFERENCES
    	let slideShowEl = {};

    	// *** VARIABLES
    	let flkty = {};

    	let isPaused = true;
    	let loaded = false;
    	let hovered = true;

    	const pauseSlideshow = () => {
    		isPaused = true;
    	};

    	const playSlideshow = () => {
    		if (isPaused) {
    			isPaused = false;
    			window.requestAnimationFrame(update);
    		}
    	};

    	const update = () => {
    		if (isPaused) return;

    		if (flkty.slides) {
    			$$invalidate(5, flkty.x = (flkty.x - tickerSpeed) % flkty.slideableWidth, flkty);
    			$$invalidate(5, flkty.selectedIndex = flkty.dragEndRestingSelect(), flkty);
    			flkty.updateSelectedSlide();
    			flkty.settle(flkty.x);
    		}

    		window.requestAnimationFrame(update);
    	};

    	const startTicker = function () {
    		let options = {
    			wrapAround: true,
    			autoPlay: false,
    			draggable: true,
    			prevNextButtons: false,
    			pageDots: false,
    			imagesLoaded: true,
    			freeScrollFriction: 0.03
    		};

    		try {
    			$$invalidate(5, flkty = new js(slideShowEl, options));
    		} catch(err) {
    			Sentry.captureException(err);
    		}

    		$$invalidate(5, flkty.x = 0, flkty);

    		flkty.on("dragStart", () => {
    			isPaused = true;
    		});

    		playSlideshow();

    		imagesloaded(slideShowEl, instance => {
    			try {
    				if (flkty && "resize" in flkty) {
    					flkty.resize();
    				}
    			} catch(err) {
    				Sentry.captureException(err);
    			}

    			$$invalidate(6, loaded = true);
    		});
    	};

    	// *** ON MOUNT
    	onMount(async () => {
    		if (imageArray.length > 2) {
    			if ((autoplay == true || autoplay == 1) && !isRelated) {
    				startTicker();
    			} else {
    				let options = {
    					wrapAround: true,
    					prevNextButtons: false,
    					pageDots: false,
    					freeScroll: true,
    					imagesLoaded: true,
    					freeScrollFriction: 0.03,
    					lazyLoad: 3
    				};

    				try {
    					$$invalidate(5, flkty = new js(slideShowEl, options));
    				} catch(err) {
    					Sentry.captureException(err);
    				}
    			}
    		}

    		imagesloaded(slideShowEl, instance => {
    			try {
    				if (flkty && "resize" in flkty) {
    					flkty.resize();
    				}
    			} catch(err) {
    				Sentry.captureException(err);
    			}

    			$$invalidate(6, loaded = true);
    		});
    	});

    	const writable_props = ["imageArray", "isRelated", "isListing", "autoplay"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Slideshow> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			slideShowEl = $$value;
    			$$invalidate(4, slideShowEl);
    		});
    	}

    	const click_handler = e => {
    		e.stopPropagation();
    		e.preventDefault();
    		flkty.next(true);
    	};

    	const click_handler_1 = e => {
    		e.stopPropagation();
    		e.preventDefault();
    		flkty.previous(true);
    	};

    	const mouseenter_handler = () => {
    		$$invalidate(7, hovered = true);

    		if ((autoplay == true || autoplay == 1) && !isRelated && !isListing) {
    			pauseSlideshow();
    		}
    	};

    	const mouseleave_handler = () => {
    		$$invalidate(7, hovered = false);

    		if ((autoplay == true || autoplay == 1) && !isRelated && !isListing) {
    			playSlideshow();
    		}
    	};

    	const mouseenter_handler_1 = () => {
    		$$invalidate(7, hovered = true);

    		if (autoplay == true || autoplay == 1) {
    			pauseSlideshow();
    		}
    	};

    	const mouseleave_handler_1 = () => {
    		$$invalidate(7, hovered = false);

    		if (autoplay == true || autoplay == 1) {
    			playSlideshow();
    		}
    	};

    	$$self.$$set = $$props => {
    		if ("imageArray" in $$props) $$invalidate(0, imageArray = $$props.imageArray);
    		if ("isRelated" in $$props) $$invalidate(1, isRelated = $$props.isRelated);
    		if ("isListing" in $$props) $$invalidate(2, isListing = $$props.isListing);
    		if ("autoplay" in $$props) $$invalidate(3, autoplay = $$props.autoplay);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Router,
    		links,
    		Flickity: js,
    		imagesLoaded: imagesloaded,
    		get: get_1,
    		urlFor,
    		Ellipse,
    		NavShow,
    		imageArray,
    		isRelated,
    		isListing,
    		autoplay,
    		slideShowEl,
    		flkty,
    		tickerSpeed,
    		isPaused,
    		loaded,
    		hovered,
    		pauseSlideshow,
    		playSlideshow,
    		update,
    		startTicker
    	});

    	$$self.$inject_state = $$props => {
    		if ("imageArray" in $$props) $$invalidate(0, imageArray = $$props.imageArray);
    		if ("isRelated" in $$props) $$invalidate(1, isRelated = $$props.isRelated);
    		if ("isListing" in $$props) $$invalidate(2, isListing = $$props.isListing);
    		if ("autoplay" in $$props) $$invalidate(3, autoplay = $$props.autoplay);
    		if ("slideShowEl" in $$props) $$invalidate(4, slideShowEl = $$props.slideShowEl);
    		if ("flkty" in $$props) $$invalidate(5, flkty = $$props.flkty);
    		if ("isPaused" in $$props) isPaused = $$props.isPaused;
    		if ("loaded" in $$props) $$invalidate(6, loaded = $$props.loaded);
    		if ("hovered" in $$props) $$invalidate(7, hovered = $$props.hovered);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		imageArray,
    		isRelated,
    		isListing,
    		autoplay,
    		slideShowEl,
    		flkty,
    		loaded,
    		hovered,
    		pauseSlideshow,
    		playSlideshow,
    		div0_binding,
    		click_handler,
    		click_handler_1,
    		mouseenter_handler,
    		mouseleave_handler,
    		mouseenter_handler_1,
    		mouseleave_handler_1
    	];
    }

    class Slideshow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			imageArray: 0,
    			isRelated: 1,
    			isListing: 2,
    			autoplay: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slideshow",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get imageArray() {
    		throw new Error("<Slideshow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageArray(value) {
    		throw new Error("<Slideshow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isRelated() {
    		throw new Error("<Slideshow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isRelated(value) {
    		throw new Error("<Slideshow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListing() {
    		throw new Error("<Slideshow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListing(value) {
    		throw new Error("<Slideshow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get autoplay() {
    		throw new Error("<Slideshow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoplay(value) {
    		throw new Error("<Slideshow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Preview.svelte generated by Svelte v3.35.0 */
    const file$e = "src/Components/Preview.svelte";

    // (149:4) {#if !isHeader}
    function create_if_block_5$5(ctx) {
    	let div;
    	let taxlist;
    	let current;

    	taxlist = new TaxList({
    			props: {
    				taxonomy: /*post*/ ctx[0].taxonomy,
    				date: /*post*/ ctx[0].publicationDate,
    				white: get_1(/*post*/ ctx[0], "previewColors.textColor", "black") === "white"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(taxlist.$$.fragment);
    			attr_dev(div, "class", "preview__tags svelte-5cqofz");
    			toggle_class(div, "bottom-tags", get_1(/*post*/ ctx[0], "preview._type", "") == "imageGroup");
    			add_location(div, file$e, 149, 6, 3925);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(taxlist, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const taxlist_changes = {};
    			if (dirty & /*post*/ 1) taxlist_changes.taxonomy = /*post*/ ctx[0].taxonomy;
    			if (dirty & /*post*/ 1) taxlist_changes.date = /*post*/ ctx[0].publicationDate;
    			if (dirty & /*post*/ 1) taxlist_changes.white = get_1(/*post*/ ctx[0], "previewColors.textColor", "black") === "white";
    			taxlist.$set(taxlist_changes);

    			if (dirty & /*get, post*/ 1) {
    				toggle_class(div, "bottom-tags", get_1(/*post*/ ctx[0], "preview._type", "") == "imageGroup");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taxlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taxlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(taxlist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(149:4) {#if !isHeader}",
    		ctx
    	});

    	return block;
    }

    // (160:4) {#if get(post, 'preview._type', '') === 'singleImage'}
    function create_if_block_4$5(ctx) {
    	let a;
    	let image;
    	let a_href_value;
    	let current;

    	image = new Image$1({
    			props: {
    				fullwidth: true,
    				isListing: true,
    				imageObject: /*post*/ ctx[0].preview.image
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(image.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug);
    			attr_dev(a, "class", "svelte-5cqofz");
    			add_location(a, file$e, 160, 6, 4294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(image, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const image_changes = {};
    			if (dirty & /*post*/ 1) image_changes.imageObject = /*post*/ ctx[0].preview.image;
    			image.$set(image_changes);

    			if (!current || dirty & /*post*/ 1 && a_href_value !== (a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(image);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(160:4) {#if get(post, 'preview._type', '') === 'singleImage'}",
    		ctx
    	});

    	return block;
    }

    // (169:4) {#if get(post, 'preview._type', '') === 'imageGroup'}
    function create_if_block_3$5(ctx) {
    	let a;
    	let imagegroup;
    	let a_href_value;
    	let current;

    	imagegroup = new ImageGroup({
    			props: {
    				isListing: true,
    				isHeader: /*isHeader*/ ctx[1],
    				imageArray: /*post*/ ctx[0].preview.images
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(imagegroup.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug);
    			attr_dev(a, "class", "svelte-5cqofz");
    			add_location(a, file$e, 169, 6, 4544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(imagegroup, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagegroup_changes = {};
    			if (dirty & /*isHeader*/ 2) imagegroup_changes.isHeader = /*isHeader*/ ctx[1];
    			if (dirty & /*post*/ 1) imagegroup_changes.imageArray = /*post*/ ctx[0].preview.images;
    			imagegroup.$set(imagegroup_changes);

    			if (!current || dirty & /*post*/ 1 && a_href_value !== (a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagegroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagegroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(imagegroup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(169:4) {#if get(post, 'preview._type', '') === 'imageGroup'}",
    		ctx
    	});

    	return block;
    }

    // (178:4) {#if get(post, 'preview._type', '') === 'slideshow'}
    function create_if_block_2$5(ctx) {
    	let a;
    	let slideshow;
    	let a_href_value;
    	let current;

    	slideshow = new Slideshow({
    			props: {
    				autoplay: /*post*/ ctx[0].preview.autoplay,
    				isListing: true,
    				imageArray: /*post*/ ctx[0].preview.images
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(slideshow.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug);
    			attr_dev(a, "class", "svelte-5cqofz");
    			add_location(a, file$e, 178, 6, 4792);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(slideshow, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slideshow_changes = {};
    			if (dirty & /*post*/ 1) slideshow_changes.autoplay = /*post*/ ctx[0].preview.autoplay;
    			if (dirty & /*post*/ 1) slideshow_changes.imageArray = /*post*/ ctx[0].preview.images;
    			slideshow.$set(slideshow_changes);

    			if (!current || dirty & /*post*/ 1 && a_href_value !== (a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slideshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slideshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(slideshow);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(178:4) {#if get(post, 'preview._type', '') === 'slideshow'}",
    		ctx
    	});

    	return block;
    }

    // (187:4) {#if get(post, 'preview._type', '') === 'videoLoop'}
    function create_if_block_1$7(ctx) {
    	let a;
    	let videoloop;
    	let a_href_value;
    	let current;

    	videoloop = new Video({
    			props: {
    				isListing: true,
    				fullwidth: true,
    				url: /*post*/ ctx[0].previewVideoUrl,
    				posterImage: get_1(/*post*/ ctx[0], "preview.posterImage", /*post*/ ctx[0].mainImage)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(videoloop.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug);
    			attr_dev(a, "class", "svelte-5cqofz");
    			add_location(a, file$e, 187, 6, 5061);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(videoloop, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoloop_changes = {};
    			if (dirty & /*post*/ 1) videoloop_changes.url = /*post*/ ctx[0].previewVideoUrl;
    			if (dirty & /*post*/ 1) videoloop_changes.posterImage = get_1(/*post*/ ctx[0], "preview.posterImage", /*post*/ ctx[0].mainImage);
    			videoloop.$set(videoloop_changes);

    			if (!current || dirty & /*post*/ 1 && a_href_value !== (a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoloop.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoloop.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(videoloop);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(187:4) {#if get(post, 'preview._type', '') === 'videoLoop'}",
    		ctx
    	});

    	return block;
    }

    // (197:4) {#if !isHeader}
    function create_if_block$9(ctx) {
    	let a;
    	let div;
    	let raw_value = /*post*/ ctx[0].title + "";
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			div = element("div");
    			attr_dev(div, "class", "preview__title preview__title--free svelte-5cqofz");
    			toggle_class(div, "preview__title--free", get_1(/*post*/ ctx[0], "preview._type", "") == "imageGroup");
    			add_location(div, file$e, 198, 8, 5401);
    			attr_dev(a, "href", a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug);
    			attr_dev(a, "class", "svelte-5cqofz");
    			add_location(a, file$e, 197, 6, 5344);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*post*/ 1 && raw_value !== (raw_value = /*post*/ ctx[0].title + "")) div.innerHTML = raw_value;
    			if (dirty & /*get, post*/ 1) {
    				toggle_class(div, "preview__title--free", get_1(/*post*/ ctx[0], "preview._type", "") == "imageGroup");
    			}

    			if (dirty & /*post*/ 1 && a_href_value !== (a_href_value = "/" + /*post*/ ctx[0].taxonomy.category + "/" + /*post*/ ctx[0].slug)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(197:4) {#if !isHeader}",
    		ctx
    	});

    	return block;
    }

    // (137:0) <Router>
    function create_default_slot$2(ctx) {
    	let div;
    	let t0;
    	let show_if_3 = get_1(/*post*/ ctx[0], "preview._type", "") === "singleImage";
    	let t1;
    	let show_if_2 = get_1(/*post*/ ctx[0], "preview._type", "") === "imageGroup";
    	let t2;
    	let show_if_1 = get_1(/*post*/ ctx[0], "preview._type", "") === "slideshow";
    	let t3;
    	let show_if = get_1(/*post*/ ctx[0], "preview._type", "") === "videoLoop";
    	let t4;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*isHeader*/ ctx[1] && create_if_block_5$5(ctx);
    	let if_block1 = show_if_3 && create_if_block_4$5(ctx);
    	let if_block2 = show_if_2 && create_if_block_3$5(ctx);
    	let if_block3 = show_if_1 && create_if_block_2$5(ctx);
    	let if_block4 = show_if && create_if_block_1$7(ctx);
    	let if_block5 = !/*isHeader*/ ctx[1] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div, "class", div_class_value = "preview " + kebabCase_1(get_1(/*post*/ ctx[0], "preview._type", "")) + " svelte-5cqofz");
    			attr_dev(div, "style", /*elementStyles*/ ctx[4]);
    			toggle_class(div, "loaded", /*loaded*/ ctx[3]);
    			toggle_class(div, "first", /*isFirst*/ ctx[2]);
    			toggle_class(div, "white", get_1(/*post*/ ctx[0], "previewColors.textColor", "black") == "white");
    			toggle_class(div, "header", /*isHeader*/ ctx[1]);
    			add_location(div, file$e, 138, 2, 3624);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(links.call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!/*isHeader*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*isHeader*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*post*/ 1) show_if_3 = get_1(/*post*/ ctx[0], "preview._type", "") === "singleImage";

    			if (show_if_3) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*post*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*post*/ 1) show_if_2 = get_1(/*post*/ ctx[0], "preview._type", "") === "imageGroup";

    			if (show_if_2) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*post*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$5(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*post*/ 1) show_if_1 = get_1(/*post*/ ctx[0], "preview._type", "") === "slideshow";

    			if (show_if_1) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*post*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*post*/ 1) show_if = get_1(/*post*/ ctx[0], "preview._type", "") === "videoLoop";

    			if (show_if) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*post*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$7(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!/*isHeader*/ ctx[1]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block$9(ctx);
    					if_block5.c();
    					if_block5.m(div, null);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (!current || dirty & /*post*/ 1 && div_class_value !== (div_class_value = "preview " + kebabCase_1(get_1(/*post*/ ctx[0], "preview._type", "")) + " svelte-5cqofz")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (dirty & /*post, loaded*/ 9) {
    				toggle_class(div, "loaded", /*loaded*/ ctx[3]);
    			}

    			if (dirty & /*post, isFirst*/ 5) {
    				toggle_class(div, "first", /*isFirst*/ ctx[2]);
    			}

    			if (dirty & /*post, get, post*/ 1) {
    				toggle_class(div, "white", get_1(/*post*/ ctx[0], "previewColors.textColor", "black") == "white");
    			}

    			if (dirty & /*post, isHeader*/ 3) {
    				toggle_class(div, "header", /*isHeader*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(137:0) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};

    			if (dirty & /*$$scope, post, isFirst, isHeader*/ 263) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Preview", slots, []);
    	let { post = {} } = $$props;
    	let { isHeader = false } = $$props;
    	let { isFirst = false } = $$props;

    	// *** VARIABLES
    	let active = true;

    	let loaded = true;

    	const backgroundColor = has_1(post, "previewColors.backgroundColor")
    	? "background-color:" + post.previewColors.backgroundColor.hex + ";"
    	: "";

    	const customTextColor = has_1(post, "previewColors.customTextColor")
    	? "color:" + post.previewColors.customTextColor.hex + ";"
    	: "";

    	const elementStyles = backgroundColor + " " + customTextColor;
    	const writable_props = ["post", "isHeader", "isFirst"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Preview> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("post" in $$props) $$invalidate(0, post = $$props.post);
    		if ("isHeader" in $$props) $$invalidate(1, isHeader = $$props.isHeader);
    		if ("isFirst" in $$props) $$invalidate(2, isFirst = $$props.isFirst);
    	};

    	$$self.$capture_state = () => ({
    		Router,
    		links,
    		MediaQuery,
    		has: has_1,
    		get: get_1,
    		kebabCase: kebabCase_1,
    		TaxList,
    		VideoLoop: Video,
    		Image: Image$1,
    		ImageGroup,
    		Slideshow,
    		post,
    		isHeader,
    		isFirst,
    		active,
    		loaded,
    		backgroundColor,
    		customTextColor,
    		elementStyles
    	});

    	$$self.$inject_state = $$props => {
    		if ("post" in $$props) $$invalidate(0, post = $$props.post);
    		if ("isHeader" in $$props) $$invalidate(1, isHeader = $$props.isHeader);
    		if ("isFirst" in $$props) $$invalidate(2, isFirst = $$props.isFirst);
    		if ("active" in $$props) active = $$props.active;
    		if ("loaded" in $$props) $$invalidate(3, loaded = $$props.loaded);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [post, isHeader, isFirst, loaded, elementStyles];
    }

    class Preview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { post: 0, isHeader: 1, isFirst: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Preview",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get post() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set post(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isHeader() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isHeader(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFirst() {
    		throw new Error("<Preview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFirst(value) {
    		throw new Error("<Preview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Footer.svelte generated by Svelte v3.35.0 */
    const file$d = "src/Components/Footer.svelte";

    // (135:4) {:else}
    function create_else_block$2(ctx) {
    	let div;
    	let logo;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new Logo({ props: { black: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(logo.$$.fragment);
    			attr_dev(div, "class", "footer__logo svelte-2h180e");
    			add_location(div, file$d, 135, 6, 3513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(logo, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler_1*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(logo);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(135:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (113:4) {#if matches}
    function create_if_block$8(ctx) {
    	let a;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div4;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div5;
    	let logo;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new Logo({ props: { black: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			a = element("a");
    			div0 = element("div");
    			div0.textContent = "INSTAGRAM";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "INSTAGRAM";
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			div2.textContent = "BACK TO TOP";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "BACK TO TOP";
    			t7 = space();
    			div5 = element("div");
    			create_component(logo.$$.fragment);
    			attr_dev(div0, "class", "footer__link--normal svelte-2h180e");
    			add_location(div0, file$d, 118, 8, 3016);
    			attr_dev(div1, "class", "footer__link--hover left svelte-2h180e");
    			add_location(div1, file$d, 119, 8, 3074);
    			attr_dev(a, "href", "https://www.instagram.com/novembremagazine/");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "footer__link footer__link--left svelte-2h180e");
    			attr_dev(a, "target", "_blank");
    			add_location(a, file$d, 113, 6, 2848);
    			attr_dev(div2, "class", "footer__link--normal svelte-2h180e");
    			add_location(div2, file$d, 123, 8, 3219);
    			attr_dev(div3, "class", "footer__link--hover right svelte-2h180e");
    			add_location(div3, file$d, 124, 8, 3279);
    			attr_dev(div4, "class", "footer__link footer__link--right svelte-2h180e");
    			add_location(div4, file$d, 122, 6, 3146);
    			attr_dev(div5, "class", "footer__logo svelte-2h180e");
    			add_location(div5, file$d, 127, 6, 3356);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div0);
    			append_dev(a, t1);
    			append_dev(a, div1);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div5, anchor);
    			mount_component(logo, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div4, "click", /*scroll*/ ctx[1], false, false, false),
    					listen_dev(div5, "click", /*click_handler*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div4);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div5);
    			destroy_component(logo);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(113:4) {#if matches}",
    		ctx
    	});

    	return block;
    }

    // (112:2) <MediaQuery query="(min-width: 800px)" let:matches>
    function create_default_slot$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*matches*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(112:2) <MediaQuery query=\\\"(min-width: 800px)\\\" let:matches>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let footer;
    	let mediaquery;
    	let current;

    	mediaquery = new MediaQuery({
    			props: {
    				query: "(min-width: 800px)",
    				$$slots: {
    					default: [
    						create_default_slot$1,
    						({ matches }) => ({ 4: matches }),
    						({ matches }) => matches ? 16 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			create_component(mediaquery.$$.fragment);
    			attr_dev(footer, "class", "footer svelte-2h180e");
    			toggle_class(footer, "active", /*active*/ ctx[0]);
    			add_location(footer, file$d, 109, 0, 2732);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			mount_component(mediaquery, footer, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const mediaquery_changes = {};

    			if (dirty & /*$$scope, matches*/ 48) {
    				mediaquery_changes.$$scope = { dirty, ctx };
    			}

    			mediaquery.$set(mediaquery_changes);

    			if (dirty & /*active*/ 1) {
    				toggle_class(footer, "active", /*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mediaquery.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mediaquery.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			destroy_component(mediaquery);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Footer", slots, []);
    	let { active = false } = $$props;

    	const scroll = () => {
    		if (document.body.clientHeight > 6000) {
    			window.scrollTo(0, 0);
    		} else {
    			window.scrollTo({ top: 0, behavior: "smooth" });
    		}
    	};

    	const writable_props = ["active"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		navigate("/");
    	};

    	const click_handler_1 = e => {
    		navigate("/");
    	};

    	$$self.$$set = $$props => {
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    	};

    	$$self.$capture_state = () => ({
    		Logo,
    		MediaQuery,
    		navigate,
    		active,
    		scroll
    	});

    	$$self.$inject_state = $$props => {
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [active, scroll, click_handler, click_handler_1];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { active: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get active() {
    		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/SplashText.svelte generated by Svelte v3.35.0 */
    const file$c = "src/Components/SplashText.svelte";

    function create_fragment$c(ctx) {
    	let div1;
    	let div0;
    	let raw_value = renderBlockText(/*content*/ ctx[2]) + "";
    	let div1_class_value;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "svelte-5n0h1h");
    			add_location(div0, file$c, 68, 2, 1671);
    			attr_dev(div1, "class", div1_class_value = "splash-text " + /*section*/ ctx[0] + " svelte-5n0h1h");
    			set_style(div1, "background", /*backgroundColor*/ ctx[1]);
    			add_location(div1, file$c, 67, 0, 1594);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content*/ 4 && raw_value !== (raw_value = renderBlockText(/*content*/ ctx[2]) + "")) div0.innerHTML = raw_value;
    			if (dirty & /*section*/ 1 && div1_class_value !== (div1_class_value = "splash-text " + /*section*/ ctx[0] + " svelte-5n0h1h")) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (dirty & /*backgroundColor*/ 2) {
    				set_style(div1, "background", /*backgroundColor*/ ctx[1]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $pages;
    	validate_store(pages, "pages");
    	component_subscribe($$self, pages, $$value => $$invalidate(3, $pages = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SplashText", slots, []);
    	let { section = "landing" } = $$props;

    	// *** VARIABLES
    	let backgroundColor = "";

    	let content = [];

    	$pages.then(pages => {
    		if (section === "landing") {
    			$$invalidate(1, backgroundColor = get_1(pages, "feedColor.hex", ""));
    			$$invalidate(2, content = get_1(pages, "feed.content", []));
    		}

    		if (section === "magazine") {
    			$$invalidate(1, backgroundColor = get_1(pages, "magazineColor.hex", ""));
    			$$invalidate(2, content = get_1(pages, "magazine.content", []));
    		}

    		if (section === "bureau") {
    			$$invalidate(1, backgroundColor = get_1(pages, "bureauColor.hex", ""));
    			$$invalidate(2, content = get_1(pages, "bureau.content", []));
    		}
    	});

    	const writable_props = ["section"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SplashText> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("section" in $$props) $$invalidate(0, section = $$props.section);
    	};

    	$$self.$capture_state = () => ({
    		pages,
    		renderBlockText,
    		get: get_1,
    		section,
    		backgroundColor,
    		content,
    		$pages
    	});

    	$$self.$inject_state = $$props => {
    		if ("section" in $$props) $$invalidate(0, section = $$props.section);
    		if ("backgroundColor" in $$props) $$invalidate(1, backgroundColor = $$props.backgroundColor);
    		if ("content" in $$props) $$invalidate(2, content = $$props.content);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [section, backgroundColor, content];
    }

    class SplashText extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { section: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplashText",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get section() {
    		throw new Error("<SplashText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set section(value) {
    		throw new Error("<SplashText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice = baseSlice;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : _baseSlice(array, start, end);
    }

    var _castSlice = castSlice;

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
        rsVarRange$2 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$2 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2  + rsComboRange$2 + rsVarRange$2 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    var _hasUnicode = hasUnicode;

    /** `Object#toString` result references. */
    var regexpTag = '[object RegExp]';

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == regexpTag;
    }

    var _baseIsRegExp = baseIsRegExp;

    /* Node.js helper references. */
    var nodeIsRegExp = _nodeUtil && _nodeUtil.isRegExp;

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? _baseUnary(nodeIsRegExp) : _baseIsRegExp;

    var isRegExp_1 = isRegExp;

    /**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    var asciiSize = _baseProperty('length');

    var _asciiSize = asciiSize;

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral$1 = '[' + rsAstralRange$1 + ']',
        rsCombo$1 = '[' + rsComboRange$1 + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ$1 = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$1 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsSymbol$1 = '(?:' + [rsNonAstral$1 + rsCombo$1 + '?', rsCombo$1, rsRegional$1, rsSurrPair$1, rsAstral$1].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode$1 = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol$1 + rsSeq$1, 'g');

    /**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */
    function unicodeSize(string) {
      var result = reUnicode$1.lastIndex = 0;
      while (reUnicode$1.test(string)) {
        ++result;
      }
      return result;
    }

    var _unicodeSize = unicodeSize;

    /**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */
    function stringSize(string) {
      return _hasUnicode(string)
        ? _unicodeSize(string)
        : _asciiSize(string);
    }

    var _stringSize = stringSize;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    var _asciiToArray = asciiToArray;

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsVarRange = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }

    var _unicodeToArray = unicodeToArray;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return _hasUnicode(string)
        ? _unicodeToArray(string)
        : _asciiToArray(string);
    }

    var _stringToArray = stringToArray;

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    var _trimmedEndIndex = trimmedEndIndex;

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    var _baseTrim = baseTrim;

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol_1(value)) {
        return NAN;
      }
      if (isObject_1$1(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject_1$1(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = _baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    var toNumber_1 = toNumber;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0,
        MAX_INTEGER = 1.7976931348623157e+308;

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber_1(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    var toFinite_1 = toFinite;

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite_1(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    var toInteger_1 = toInteger;

    /** Used as default options for `_.truncate`. */
    var DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject_1$1(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger_1(options.length) : length;
        omission = 'omission' in options ? _baseToString(options.omission) : omission;
      }
      string = toString_1(string);

      var strLength = string.length;
      if (_hasUnicode(string)) {
        var strSymbols = _stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - _stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? _castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp_1(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString_1(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(_baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    var truncate_1 = truncate;

    /* src/Components/MetaData.svelte generated by Svelte v3.35.0 */

    const { document: document_1 } = globals;

    const file$b = "src/Components/MetaData.svelte";

    function create_fragment$b(ctx) {
    	let title_value;
    	let meta0;
    	let meta1;
    	let meta2;
    	let meta3;
    	let meta4;
    	let meta5;
    	let meta6;
    	let meta7;
    	let meta8;
    	let meta9;
    	document_1.title = title_value = /*title*/ ctx[0];

    	const block = {
    		c: function create() {
    			meta0 = element("meta");
    			meta1 = element("meta");
    			meta2 = element("meta");
    			meta3 = element("meta");
    			meta4 = element("meta");
    			meta5 = element("meta");
    			meta6 = element("meta");
    			meta7 = element("meta");
    			meta8 = element("meta");
    			meta9 = element("meta");
    			attr_dev(meta0, "property", "og:title");
    			attr_dev(meta0, "content", /*title*/ ctx[0]);
    			add_location(meta0, file$b, 53, 2, 1335);
    			attr_dev(meta1, "property", "twitter:title");
    			attr_dev(meta1, "content", /*title*/ ctx[0]);
    			add_location(meta1, file$b, 54, 2, 1382);
    			attr_dev(meta2, "name", "twitter:card");
    			attr_dev(meta2, "content", "summary_large_image");
    			add_location(meta2, file$b, 55, 2, 1434);
    			attr_dev(meta3, "property", "description");
    			attr_dev(meta3, "content", /*description*/ ctx[1]);
    			add_location(meta3, file$b, 56, 2, 1495);
    			attr_dev(meta4, "property", "og:description");
    			attr_dev(meta4, "content", /*description*/ ctx[1]);
    			add_location(meta4, file$b, 57, 2, 1551);
    			attr_dev(meta5, "property", "twitter:description");
    			attr_dev(meta5, "content", /*description*/ ctx[1]);
    			add_location(meta5, file$b, 58, 2, 1610);
    			attr_dev(meta6, "property", "image");
    			attr_dev(meta6, "content", /*image*/ ctx[2]);
    			add_location(meta6, file$b, 59, 2, 1674);
    			attr_dev(meta7, "property", "og:type");
    			attr_dev(meta7, "content", "website");
    			add_location(meta7, file$b, 60, 2, 1718);
    			attr_dev(meta8, "property", "og:image");
    			attr_dev(meta8, "content", /*image*/ ctx[2]);
    			add_location(meta8, file$b, 61, 2, 1766);
    			attr_dev(meta9, "property", "twitter:image");
    			attr_dev(meta9, "content", /*image*/ ctx[2]);
    			add_location(meta9, file$b, 62, 2, 1813);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, meta0);
    			append_dev(document_1.head, meta1);
    			append_dev(document_1.head, meta2);
    			append_dev(document_1.head, meta3);
    			append_dev(document_1.head, meta4);
    			append_dev(document_1.head, meta5);
    			append_dev(document_1.head, meta6);
    			append_dev(document_1.head, meta7);
    			append_dev(document_1.head, meta8);
    			append_dev(document_1.head, meta9);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*title*/ 1 && title_value !== (title_value = /*title*/ ctx[0])) {
    				document_1.title = title_value;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			detach_dev(meta0);
    			detach_dev(meta1);
    			detach_dev(meta2);
    			detach_dev(meta3);
    			detach_dev(meta4);
    			detach_dev(meta5);
    			detach_dev(meta6);
    			detach_dev(meta7);
    			detach_dev(meta8);
    			detach_dev(meta9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const defaultDescription = "Novembre Global is a platform for expression, guiding individuals and professionals in search of inspiration, new styles and emergent cultural trends.";

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MetaData", slots, []);
    	let { post = {} } = $$props;

    	const stripHtml = html => {
    		let tmp = document.createElement("DIV");
    		tmp.innerHTML = html;
    		return tmp.textContent || tmp.innerText || "";
    	};

    	const title = (has_1(post, "title") && !isEmpty_1(post.title)
    	? stripHtml(post.title) + " / "
    	: "") + "NOVEMBRE GLOBAL";

    	const description = has_1(post, "content") && isArray_1(post.content) && !isEmpty_1(post.content)
    	? truncate_1(toPlainText(post.content), { length: 160, separator: /.? +/ })
    	: defaultDescription;

    	const image = has_1(post, "mainImage")
    	? urlFor(post.mainImage).quality(80).height(1200).width(1200).url()
    	: "https://novembre.global/logo.png";

    	const writable_props = ["post"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MetaData> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("post" in $$props) $$invalidate(3, post = $$props.post);
    	};

    	$$self.$capture_state = () => ({
    		has: has_1,
    		isArray: isArray_1,
    		isEmpty: isEmpty_1,
    		truncate: truncate_1,
    		toPlainText,
    		urlFor,
    		post,
    		stripHtml,
    		defaultDescription,
    		title,
    		description,
    		image
    	});

    	$$self.$inject_state = $$props => {
    		if ("post" in $$props) $$invalidate(3, post = $$props.post);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, description, image, post];
    }

    class MetaData extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { post: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MetaData",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get post() {
    		throw new Error("<MetaData>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set post(value) {
    		throw new Error("<MetaData>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/TagBar.svelte generated by Svelte v3.35.0 */

    const file$a = "src/Components/TagBar.svelte";

    function create_fragment$a(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t = text(/*text*/ ctx[0]);
    			attr_dev(div0, "class", "item svelte-186vuqw");
    			add_location(div0, file$a, 68, 4, 1390);
    			attr_dev(div1, "class", "inner svelte-186vuqw");
    			add_location(div1, file$a, 67, 2, 1366);
    			attr_dev(div2, "class", "tagbar svelte-186vuqw");
    			add_location(div2, file$a, 66, 0, 1343);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TagBar", slots, []);
    	let { text = "" } = $$props;
    	const writable_props = ["text"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TagBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({ text });

    	$$self.$inject_state = $$props => {
    		if ("text" in $$props) $$invalidate(0, text = $$props.text);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [text];
    }

    class TagBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { text: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagBar",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get text() {
    		throw new Error("<TagBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<TagBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Routes/Listing.svelte generated by Svelte v3.35.0 */

    const { console: console_1$4 } = globals;

    const file$9 = "src/Routes/Listing.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	child_ctx[31] = i;
    	return child_ctx;
    }

    // (265:0) {#if title === 'Tag' || title === 'Search'}
    function create_if_block_7$2(ctx) {
    	let tagbar;
    	let current;

    	tagbar = new TagBar({
    			props: { text: /*$activeQuery*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tagbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tagbar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tagbar_changes = {};
    			if (dirty[0] & /*$activeQuery*/ 64) tagbar_changes.text = /*$activeQuery*/ ctx[6];
    			tagbar.$set(tagbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tagbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(265:0) {#if title === 'Tag' || title === 'Search'}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  LISTING   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_catch_block$5(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$5.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  LISTING   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (269:38)     {#if isArray(postsArray)}
    function create_then_block$5(ctx) {
    	let show_if = isArray_1(/*postsArray*/ ctx[4]);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*postsArray*/ 16) show_if = isArray_1(/*postsArray*/ ctx[4]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*postsArray*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$5.name,
    		type: "then",
    		source: "(269:38)     {#if isArray(postsArray)}",
    		ctx
    	});

    	return block;
    }

    // (271:2) {#if isArray(postsArray)}
    function create_if_block$7(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let footer;
    	let current;
    	let if_block0 = /*query*/ ctx[1] && /*postsArray*/ ctx[4].length === 0 && create_if_block_6$4(ctx);
    	let each_value = /*postsArray*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block1 = !/*loadingCompleted*/ ctx[5] && create_if_block_1$6(ctx);
    	footer = new Footer({ props: { active: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div0, "class", "listing__posts");
    			add_location(div0, file$9, 273, 6, 9638);
    			attr_dev(div1, "class", "listing svelte-l3hbwi");
    			toggle_class(div1, "landing", /*title*/ ctx[0] === "Landing");
    			add_location(div1, file$9, 271, 4, 9573);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			/*div0_binding*/ ctx[19](div0);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			insert_dev(target, t2, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*query*/ ctx[1] && /*postsArray*/ ctx[4].length === 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$4(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*postsArray, $feedBanners, title*/ 145) {
    				each_value = /*postsArray*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!/*loadingCompleted*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*loadingCompleted*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*title*/ 1) {
    				toggle_class(div1, "landing", /*title*/ ctx[0] === "Landing");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block1);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block1);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			/*div0_binding*/ ctx[19](null);
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t2);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(271:2) {#if isArray(postsArray)}",
    		ctx
    	});

    	return block;
    }

    // (276:8) {#if query && postsArray.length === 0}
    function create_if_block_6$4(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("No results for “");
    			t1 = text(/*query*/ ctx[1]);
    			t2 = text("”");
    			attr_dev(div, "class", "no-results svelte-l3hbwi");
    			add_location(div, file$9, 276, 10, 9754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*query*/ 2) set_data_dev(t1, /*query*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(276:8) {#if query && postsArray.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (281:10) {#if i === 0 && (title === 'Magazine' || title === 'Bureau' || title === 'Landing')}
    function create_if_block_5$4(ctx) {
    	let splashtext;
    	let current;

    	splashtext = new SplashText({
    			props: { section: /*title*/ ctx[0].toLowerCase() },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(splashtext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(splashtext, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const splashtext_changes = {};
    			if (dirty[0] & /*title*/ 1) splashtext_changes.section = /*title*/ ctx[0].toLowerCase();
    			splashtext.$set(splashtext_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(splashtext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(splashtext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(splashtext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(281:10) {#if i === 0 && (title === 'Magazine' || title === 'Bureau' || title === 'Landing')}",
    		ctx
    	});

    	return block;
    }

    // (285:10) {#if !isEmpty(feedBanners) && feedBanners.find(b => b.positionInFeed == i)}
    function create_if_block_2$4(ctx) {
    	let a;
    	let show_if_1 = /*feedBanners*/ ctx[28].find(func_2)[0] && /*feedBanners*/ ctx[28].find(func_3)[0].video && /*feedBanners*/ ctx[28].find(func_4)[0].video.asset && /*feedBanners*/ ctx[28].find(func_5)[0].video.asset._ref;
    	let t;
    	let show_if = /*feedBanners*/ ctx[28].find(func_1).image;
    	let a_href_value;

    	function func_1(...args) {
    		return /*func_1*/ ctx[11](/*i*/ ctx[31], ...args);
    	}

    	function func_2(...args) {
    		return /*func_2*/ ctx[12](/*i*/ ctx[31], ...args);
    	}

    	function func_3(...args) {
    		return /*func_3*/ ctx[13](/*i*/ ctx[31], ...args);
    	}

    	function func_4(...args) {
    		return /*func_4*/ ctx[14](/*i*/ ctx[31], ...args);
    	}

    	function func_5(...args) {
    		return /*func_5*/ ctx[15](/*i*/ ctx[31], ...args);
    	}

    	let if_block0 = show_if_1 && create_if_block_4$4(ctx);
    	let if_block1 = show_if && create_if_block_3$4(ctx);

    	function func_8(...args) {
    		return /*func_8*/ ctx[18](/*i*/ ctx[31], ...args);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(a, "href", a_href_value = /*feedBanners*/ ctx[28].find(func_8).link);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "feed-banner svelte-l3hbwi");
    			add_location(a, file$9, 285, 12, 10129);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t);
    			if (if_block1) if_block1.m(a, null);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*$feedBanners*/ 128) show_if_1 = /*feedBanners*/ ctx[28].find(func_2)[0] && /*feedBanners*/ ctx[28].find(func_3)[0].video && /*feedBanners*/ ctx[28].find(func_4)[0].video.asset && /*feedBanners*/ ctx[28].find(func_5)[0].video.asset._ref;

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$4(ctx);
    					if_block0.c();
    					if_block0.m(a, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*$feedBanners*/ 128) show_if = /*feedBanners*/ ctx[28].find(func_1).image;

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					if_block1.m(a, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$feedBanners*/ 128 && a_href_value !== (a_href_value = /*feedBanners*/ ctx[28].find(func_8).link)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(285:10) {#if !isEmpty(feedBanners) && feedBanners.find(b => b.positionInFeed == i)}",
    		ctx
    	});

    	return block;
    }

    // (292:14) {#if feedBanners.find(b => b.positionInFeed == i)[0] && feedBanners.find(b => b.positionInFeed == i)[0].video && feedBanners.find(b => b.positionInFeed == i)[0].video.asset && feedBanners.find(b => b.positionInFeed == i)[0].video.asset._ref}
    function create_if_block_4$4(ctx) {
    	let video;
    	let video_src_value;

    	function func_6(...args) {
    		return /*func_6*/ ctx[16](/*i*/ ctx[31], ...args);
    	}

    	const block = {
    		c: function create() {
    			video = element("video");
    			video.playsInline = "playsinline";
    			if (video.src !== (video_src_value = "https://cdn.sanity.io/files/gj963qwj/production/" + /*feedBanners*/ ctx[28].find(func_6).video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"))) attr_dev(video, "src", video_src_value);
    			video.autoplay = true;
    			video.muted = true;
    			video.loop = true;
    			attr_dev(video, "class", "svelte-l3hbwi");
    			add_location(video, file$9, 292, 16, 10572);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$feedBanners*/ 128 && video.src !== (video_src_value = "https://cdn.sanity.io/files/gj963qwj/production/" + /*feedBanners*/ ctx[28].find(func_6).video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"))) {
    				attr_dev(video, "src", video_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(292:14) {#if feedBanners.find(b => b.positionInFeed == i)[0] && feedBanners.find(b => b.positionInFeed == i)[0].video && feedBanners.find(b => b.positionInFeed == i)[0].video.asset && feedBanners.find(b => b.positionInFeed == i)[0].video.asset._ref}",
    		ctx
    	});

    	return block;
    }

    // (304:14) {#if feedBanners.find(b => b.positionInFeed == i).image}
    function create_if_block_3$4(ctx) {
    	let img;
    	let img_src_value;

    	function func_7(...args) {
    		return /*func_7*/ ctx[17](/*i*/ ctx[31], ...args);
    	}

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "novembre.global");
    			if (img.src !== (img_src_value = urlFor(/*feedBanners*/ ctx[28].find(func_7).image).width(1400).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "svelte-l3hbwi");
    			add_location(img, file$9, 304, 16, 11061);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$feedBanners*/ 128 && img.src !== (img_src_value = urlFor(/*feedBanners*/ ctx[28].find(func_7).image).width(1400).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(304:14) {#if feedBanners.find(b => b.positionInFeed == i).image}",
    		ctx
    	});

    	return block;
    }

    // (280:8) {#each postsArray as post, i}
    function create_each_block$3(ctx) {
    	let t0;
    	let show_if = !isEmpty_1(/*feedBanners*/ ctx[28]) && /*feedBanners*/ ctx[28].find(func);
    	let t1;
    	let preview;
    	let current;

    	function func(...args) {
    		return /*func*/ ctx[10](/*i*/ ctx[31], ...args);
    	}

    	let if_block0 = /*i*/ ctx[31] === 0 && (/*title*/ ctx[0] === "Magazine" || /*title*/ ctx[0] === "Bureau" || /*title*/ ctx[0] === "Landing") && create_if_block_5$4(ctx);
    	let if_block1 = show_if && create_if_block_2$4(ctx);

    	preview = new Preview({
    			props: {
    				post: /*post*/ ctx[29],
    				isFirst: /*i*/ ctx[31] === 0 ? true : false
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(preview.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(preview, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*i*/ ctx[31] === 0 && (/*title*/ ctx[0] === "Magazine" || /*title*/ ctx[0] === "Bureau" || /*title*/ ctx[0] === "Landing")) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*title*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*$feedBanners*/ 128) show_if = !isEmpty_1(/*feedBanners*/ ctx[28]) && /*feedBanners*/ ctx[28].find(func);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$4(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const preview_changes = {};
    			if (dirty[0] & /*postsArray*/ 16) preview_changes.post = /*post*/ ctx[29];
    			preview.$set(preview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(preview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(preview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(preview, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(280:8) {#each postsArray as post, i}",
    		ctx
    	});

    	return block;
    }

    // (320:6) {#if !loadingCompleted}
    function create_if_block_1$6(ctx) {
    	let div;
    	let t;
    	let ellipse;
    	let current;
    	ellipse = new Ellipse({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("LOADING\n          ");
    			create_component(ellipse.$$.fragment);
    			attr_dev(div, "class", "sentinel svelte-l3hbwi");
    			add_location(div, file$9, 320, 8, 11505);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			mount_component(ellipse, div, null);
    			/*div_binding*/ ctx[20](div);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ellipse.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ellipse.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(ellipse);
    			/*div_binding*/ ctx[20](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(320:6) {#if !loadingCompleted}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  LISTING   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_pending_block$5(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$5.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  LISTING   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let metadata;
    	let t0;
    	let t1;
    	let await_block_anchor;
    	let promise;
    	let current;
    	metadata = new MetaData({ $$inline: true });
    	let if_block = (/*title*/ ctx[0] === "Tag" || /*title*/ ctx[0] === "Search") && create_if_block_7$2(ctx);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$5,
    		then: create_then_block$5,
    		catch: create_catch_block$5,
    		value: 28,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*$feedBanners*/ ctx[7], info);

    	const block = {
    		c: function create() {
    			create_component(metadata.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(metadata, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*title*/ ctx[0] === "Tag" || /*title*/ ctx[0] === "Search") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*title*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_7$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			info.ctx = ctx;

    			if (dirty[0] & /*$feedBanners*/ 128 && promise !== (promise = /*$feedBanners*/ ctx[7]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[28] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(metadata.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(metadata.$$.fragment, local);
    			transition_out(if_block);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(metadata, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BATCH_SIZE = 5;

    function instance$9($$self, $$props, $$invalidate) {
    	let $activeQuery;
    	let $feedBanners;
    	validate_store(activeQuery, "activeQuery");
    	component_subscribe($$self, activeQuery, $$value => $$invalidate(6, $activeQuery = $$value));
    	validate_store(feedBanners, "feedBanners");
    	component_subscribe($$self, feedBanners, $$value => $$invalidate(7, $feedBanners = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Listing", slots, []);
    	let { title = "" } = $$props;
    	let { query = false } = $$props;
    	let { location = {} } = $$props;

    	// *** DOM REFERENCES
    	let sentinel = {};

    	let postsContainerEl = {};

    	// *** VARIABLES
    	let index = 0;

    	let currentQuery = query;
    	let sanityQuery = "";
    	let sanityParams = {};
    	let postsArray = [];
    	let loadingCompleted = false;

    	const logSitemap = posts => {
    		posts.forEach(p => {
    			console.log("https://novembre.global/" + p.taxonomy.category + "/" + p.slug);
    		});
    	};

    	const doLoad = () => {
    		const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    		console.log(tz);

    		// Get current time as UTC
    		const currentTime = zonedTimeToUtc(new Date()).toISOString();

    		console.log("currentTime", currentTime);

    		if (title === "Landing") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else if (title === "Magazine") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"magazine\" && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"magazine\" && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else if (title === "Bureau") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"bureau\" && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"bureau\" && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else if (title === "Tag") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && $tag in taxonomy.tags && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && $tag in taxonomy.tags && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				tag: query,
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else if (title === "Search") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && title match $term || $term in taxonomy.tags && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && title match $term || $term in taxonomy.tags && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				term: query,
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else if (title === "magsub") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"magazine\" && taxonomy.subCategory == $subcat && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"magazine\" && taxonomy.subCategory == $subcat && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				subcat: query,
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else if (title === "bursub") {
    			sanityQuery = "*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"bureau\" && taxonomy.subCategory == $subcat && $currentTime > publicationDate] | order(publicationDate desc){publicationDate, \"totalPosts\": count(*[_type == \"article\" && editorialState == \"live\" && taxonomy.category == \"bureau\" && taxonomy.subCategory == $subcat && $currentTime > publicationDate]), title, \"slug\": slug.current, taxonomy, \"preview\": preview[0], \"previewVideoUrl\": preview[0].video.asset->url, previewColors}[$start...$end]";

    			sanityParams = {
    				subcat: query,
    				start: index * BATCH_SIZE,
    				end: (index + 1) * BATCH_SIZE,
    				currentTime
    			};
    		} else {
    			navigate("/404");
    		}

    		loadFeed(sanityQuery, sanityParams).then(posts => {
    			$$invalidate(4, postsArray = [...postsArray, ...posts]);

    			setTimeout(
    				() => {
    					if (index === 0) {
    						window.scrollTo(0, 0);
    						console.log("Connecting observer");
    						observer.observe(sentinel);
    					}

    					console.log(get_1(postsArray, "[0].totalPosts", 100));
    					console.log((index + 1) * BATCH_SIZE);

    					if ((index + 1) * BATCH_SIZE >= get_1(postsArray, "[0].totalPosts", 100)) {
    						console.log("Disconnecting observer");
    						$$invalidate(5, loadingCompleted = true);
    						observer.disconnect();
    					}
    				},
    				100
    			);
    		});
    	};

    	navigationColor.set("white");

    	const observer = new IntersectionObserver(entries => {
    			entries.forEach(entry => {
    				if (entry.intersectionRatio > 0) {
    					console.log("SENTINEL HIT");
    					index += 1;
    					doLoad();
    				}
    			});
    		},
    	{ threshold: 0.5 });

    	const repositionSentinel = () => {
    		if (postsContainerEl && sentinel) {
    			let fourthElementFromEnd = postsContainerEl.querySelector(".preview:nth-last-child(4)");
    			if (fourthElementFromEnd) postsContainerEl.insertBefore(sentinel, fourthElementFromEnd);
    		}
    	};

    	// *** ON MOUNT
    	onMount(async () => {
    		window.scrollTo(0, 0);
    		doLoad();
    	});

    	const writable_props = ["title", "query", "location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<Listing> was created with unknown prop '${key}'`);
    	});

    	const func = (i, b) => b.positionInFeed == i;
    	const func_1 = (i, b) => b.positionInFeed == i;
    	const func_2 = (i, b) => b.positionInFeed == i;
    	const func_3 = (i, b) => b.positionInFeed == i;
    	const func_4 = (i, b) => b.positionInFeed == i;
    	const func_5 = (i, b) => b.positionInFeed == i;
    	const func_6 = (i, b) => b.positionInFeed == i;
    	const func_7 = (i, b) => b.positionInFeed == i;
    	const func_8 = (i, b) => b.positionInFeed == i;

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			postsContainerEl = $$value;
    			$$invalidate(3, postsContainerEl);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			sentinel = $$value;
    			$$invalidate(2, sentinel);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("query" in $$props) $$invalidate(1, query = $$props.query);
    		if ("location" in $$props) $$invalidate(8, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		navigate,
    		isEmpty: isEmpty_1,
    		isArray: isArray_1,
    		get: get_1,
    		urlFor,
    		loadFeed,
    		zonedTimeToUtc,
    		Preview,
    		Footer,
    		SplashText,
    		MetaData,
    		TagBar,
    		Ellipse,
    		feedBanners,
    		navigationColor,
    		activeQuery,
    		activeCategory,
    		scrollListActive,
    		title,
    		query,
    		location,
    		sentinel,
    		postsContainerEl,
    		BATCH_SIZE,
    		index,
    		currentQuery,
    		sanityQuery,
    		sanityParams,
    		postsArray,
    		loadingCompleted,
    		logSitemap,
    		doLoad,
    		observer,
    		repositionSentinel,
    		$activeQuery,
    		$feedBanners
    	});

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("query" in $$props) $$invalidate(1, query = $$props.query);
    		if ("location" in $$props) $$invalidate(8, location = $$props.location);
    		if ("sentinel" in $$props) $$invalidate(2, sentinel = $$props.sentinel);
    		if ("postsContainerEl" in $$props) $$invalidate(3, postsContainerEl = $$props.postsContainerEl);
    		if ("index" in $$props) index = $$props.index;
    		if ("currentQuery" in $$props) $$invalidate(9, currentQuery = $$props.currentQuery);
    		if ("sanityQuery" in $$props) sanityQuery = $$props.sanityQuery;
    		if ("sanityParams" in $$props) sanityParams = $$props.sanityParams;
    		if ("postsArray" in $$props) $$invalidate(4, postsArray = $$props.postsArray);
    		if ("loadingCompleted" in $$props) $$invalidate(5, loadingCompleted = $$props.loadingCompleted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*query, currentQuery*/ 514) {
    			// Re-load if query changes
    			{
    				if (query !== currentQuery) {
    					$$invalidate(9, currentQuery = query);
    					$$invalidate(4, postsArray = []);
    					index = 0;
    					doLoad();
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*title*/ 1) {
    			// Enable scroll list for selected listings
    			title === "bursub" || title === "magsub" || title === "Magazine" || title === "Bureau"
    			? scrollListActive.set(true)
    			: scrollListActive.set(false);
    		}

    		if ($$self.$$.dirty[0] & /*query*/ 2) {
    			activeQuery.set(query);
    		}

    		if ($$self.$$.dirty[0] & /*title*/ 1) {
    			title === "bursub" || title === "Bureau"
    			? activeCategory.set("bureau")
    			: activeCategory.set("magazine");
    		}
    	};

    	return [
    		title,
    		query,
    		sentinel,
    		postsContainerEl,
    		postsArray,
    		loadingCompleted,
    		$activeQuery,
    		$feedBanners,
    		location,
    		currentQuery,
    		func,
    		func_1,
    		func_2,
    		func_3,
    		func_4,
    		func_5,
    		func_6,
    		func_7,
    		func_8,
    		div0_binding,
    		div_binding
    	];
    }

    class Listing extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { title: 0, query: 1, location: 8 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Listing",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get title() {
    		throw new Error("<Listing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Listing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get query() {
    		throw new Error("<Listing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set query(value) {
    		throw new Error("<Listing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<Listing>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<Listing>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var getSrc = function (input) {
    	if (typeof input !== 'string') {
    		throw new TypeError('get-src expected a string');
    	}
    	var re = /src="(.*?)"/gm;
    	var url = re.exec(input);

    	if (url && url.length >= 2) {
    		return url[1];
    	}
    };

    /**
     * Strip away any parameters following `?` or `/` or '&'
     * @param str
     * @returns {String}
     */
    function stripParameters(str) {
      // Split parameters or split folder separator
      if (str.indexOf('?') > -1) {
        return str.split('?')[0];
      }

      if (str.indexOf('/') > -1) {
        return str.split('/')[0];
      }

      if (str.indexOf('&') > -1) {
        return str.split('&')[0];
      }

      return str;
    }

    /**
     * Get the Youtube Video id.
     * @param {string} youtubeStr - the url from which you want to extract the id
     * @returns {string|undefined}
     */

    function youtube(youtubeStr) {
      var str = youtubeStr; // remove time hash at the end of the string

      str = str.replace(/#t=.*$/, ''); // shortcode

      var shortcode = /youtube:\/\/|https?:\/\/youtu\.be\/|http:\/\/y2u\.be\//g;

      if (shortcode.test(str)) {
        var shortcodeid = str.split(shortcode)[1];
        return stripParameters(shortcodeid);
      } // /v/ or /vi/


      var inlinev = /\/v\/|\/vi\//g;

      if (inlinev.test(str)) {
        var inlineid = str.split(inlinev)[1];
        return stripParameters(inlineid);
      } // v= or vi=


      var parameterv = /v=|vi=/g;

      if (parameterv.test(str)) {
        var arr = str.split(parameterv);
        return stripParameters(arr[1].split('&')[0]);
      } // v= or vi=


      var parameterwebp = /\/an_webp\//g;

      if (parameterwebp.test(str)) {
        var webp = str.split(parameterwebp)[1];
        return stripParameters(webp);
      } // embed


      var embedreg = /\/embed\//g;

      if (embedreg.test(str)) {
        var embedid = str.split(embedreg)[1];
        return stripParameters(embedid);
      } // ignore /user/username pattern


      var usernamereg = /\/user\/([a-zA-Z0-9]*)$/g;

      if (usernamereg.test(str)) {
        return undefined;
      } // user


      var userreg = /\/user\/(?!.*videos)/g;

      if (userreg.test(str)) {
        var elements = str.split('/');
        return stripParameters(elements.pop());
      } // attribution_link


      var attrreg = /\/attribution_link\?.*v%3D([^%&]*)(%26|&|$)/;

      if (attrreg.test(str)) {
        return stripParameters(str.match(attrreg)[1]);
      }

      return undefined;
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    /**
     * Get the vimeo id.
     * @param {string} vimeoStr - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function vimeo(vimeoStr) {
      var str = vimeoStr;

      if (str.indexOf('#') > -1) {
        var _str$split = str.split('#');

        var _str$split2 = _slicedToArray(_str$split, 1);

        str = _str$split2[0];
      }

      if (str.indexOf('?') > -1 && str.indexOf('clip_id=') === -1) {
        var _str$split3 = str.split('?');

        var _str$split4 = _slicedToArray(_str$split3, 1);

        str = _str$split4[0];
      }

      var id;
      var arr;
      var primary = /https?:\/\/vimeo\.com\/([0-9]+)/;
      var matches = primary.exec(str);

      if (matches && matches[1]) {
        return matches[1];
      }

      var vimeoPipe = ['https?://player.vimeo.com/video/[0-9]+$', 'https?://vimeo.com/channels', 'groups', 'album'].join('|');
      var vimeoRegex = new RegExp(vimeoPipe, 'gim');

      if (vimeoRegex.test(str)) {
        arr = str.split('/');

        if (arr && arr.length) {
          id = arr.pop();
        }
      } else if (/clip_id=/gim.test(str)) {
        arr = str.split('clip_id=');

        if (arr && arr.length) {
          var _arr$1$split = arr[1].split('&');

          var _arr$1$split2 = _slicedToArray(_arr$1$split, 1);

          id = _arr$1$split2[0];
        }
      }

      return id;
    }

    /**
     * Get the vine id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function vine(str) {
      var regex = /https:\/\/vine\.co\/v\/([a-zA-Z0-9]*)\/?/;
      var matches = regex.exec(str);
      return matches && matches[1];
    }

    /**
     * Get the VideoPress id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function videopress(str) {
      var idRegex;

      if (str.indexOf('embed') > -1) {
        idRegex = /embed\/(\w{8})/;
        return str.match(idRegex)[1];
      }

      idRegex = /\/v\/(\w{8})/;
      var match = str.match(idRegex);

      if (match && match.length > 0) {
        return str.match(idRegex)[1];
      }

      return undefined;
    }

    /**
     * Get the Microsoft Stream id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function microsoftStream(str) {
      var regex = str.indexOf('embed') > -1 ? /https:\/\/web\.microsoftstream\.com\/embed\/video\/([a-zA-Z0-9-]*)\/?/ : /https:\/\/web\.microsoftstream\.com\/video\/([a-zA-Z0-9-]*)\/?/;
      var matches = regex.exec(str);
      return matches && matches[1];
    }

    /**
     * Get the id and service from a video url.
     * @param {String} videoStr - the url from which you want to extract the id
     * @returns {Object}
     */

    function getVideoId(videoStr) {
      if (typeof videoStr !== 'string') {
        throw new TypeError('get-video-id expects a string');
      }

      var str = videoStr;

      if (/<iframe/gi.test(str)) {
        str = getSrc(str);
      } // remove surrounding whitespaces or linefeeds


      str = str.trim(); // remove the '-nocookie' flag from youtube urls

      str = str.replace('-nocookie', ''); // remove any leading `www.`

      str = str.replace('/www.', '/');
      var metadata = {
        id: null,
        service: null
      }; // Try to handle google redirection uri

      if (/\/\/google/.test(str)) {
        // Find the redirection uri
        var matches = str.match(/url=([^&]+)&/); // Decode the found uri and replace current url string - continue with final link

        if (matches) {
          // JavaScript can get encoded URI
          str = decodeURIComponent(matches[1]);
        }
      }

      if (/youtube|youtu\.be|y2u\.be|i.ytimg\./.test(str)) {
        metadata = {
          id: youtube(str),
          service: 'youtube'
        };
      } else if (/vimeo/.test(str)) {
        metadata = {
          id: vimeo(str),
          service: 'vimeo'
        };
      } else if (/vine/.test(str)) {
        metadata = {
          id: vine(str),
          service: 'vine'
        };
      } else if (/videopress/.test(str)) {
        metadata = {
          id: videopress(str),
          service: 'videopress'
        };
      } else if (/microsoftstream/.test(str)) {
        metadata = {
          id: microsoftStream(str),
          service: 'microsoftstream'
        };
      }

      return metadata;
    }

    /* src/Components/Modules/VideoEmbed.svelte generated by Svelte v3.35.0 */
    const file$8 = "src/Components/Modules/VideoEmbed.svelte";

    // (44:4) {#if url.includes('youtube')}
    function create_if_block_1$5(ctx) {
    	let iframe;
    	let iframe_src_value;

    	const block = {
    		c: function create() {
    			iframe = element("iframe");
    			attr_dev(iframe, "width", "720");
    			attr_dev(iframe, "height", "480");
    			attr_dev(iframe, "title", /*caption*/ ctx[1]);
    			if (iframe.src !== (iframe_src_value = "https://www.youtube.com/embed/" + getVideoId(/*url*/ ctx[0]).id)) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "frameborder", "0");
    			attr_dev(iframe, "allow", "accelerometer; autoplay; encrypted-media; gyroscope;\n        picture-in-picture");
    			iframe.allowFullscreen = true;
    			attr_dev(iframe, "class", "svelte-1w0gs4n");
    			add_location(iframe, file$8, 44, 6, 882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, iframe, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*caption*/ 2) {
    				attr_dev(iframe, "title", /*caption*/ ctx[1]);
    			}

    			if (dirty & /*url*/ 1 && iframe.src !== (iframe_src_value = "https://www.youtube.com/embed/" + getVideoId(/*url*/ ctx[0]).id)) {
    				attr_dev(iframe, "src", iframe_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(iframe);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(44:4) {#if url.includes('youtube')}",
    		ctx
    	});

    	return block;
    }

    // (55:4) {#if url.includes('vimeo')}
    function create_if_block$6(ctx) {
    	let iframe;
    	let iframe_src_value;

    	const block = {
    		c: function create() {
    			iframe = element("iframe");
    			attr_dev(iframe, "width", "720");
    			attr_dev(iframe, "height", "480");
    			attr_dev(iframe, "title", /*caption*/ ctx[1]);
    			if (iframe.src !== (iframe_src_value = "https://player.vimeo.com/video/" + getVideoId(/*url*/ ctx[0]).id)) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "frameborder", "0");
    			attr_dev(iframe, "byline", "false");
    			attr_dev(iframe, "color", "#ffffff");
    			attr_dev(iframe, "allow", "autoplay; fullscreen");
    			iframe.allowFullscreen = true;
    			attr_dev(iframe, "class", "svelte-1w0gs4n");
    			add_location(iframe, file$8, 55, 6, 1215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, iframe, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*caption*/ 2) {
    				attr_dev(iframe, "title", /*caption*/ ctx[1]);
    			}

    			if (dirty & /*url*/ 1 && iframe.src !== (iframe_src_value = "https://player.vimeo.com/video/" + getVideoId(/*url*/ ctx[0]).id)) {
    				attr_dev(iframe, "src", iframe_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(iframe);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(55:4) {#if url.includes('vimeo')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div1;
    	let div0;
    	let show_if_1 = /*url*/ ctx[0].includes("youtube");
    	let t;
    	let show_if = /*url*/ ctx[0].includes("vimeo");
    	let if_block0 = show_if_1 && create_if_block_1$5(ctx);
    	let if_block1 = show_if && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "inner svelte-1w0gs4n");
    			add_location(div0, file$8, 42, 2, 822);
    			attr_dev(div1, "class", "embed svelte-1w0gs4n");
    			set_style(div1, "background-color", /*backgroundColor*/ ctx[2].hex);
    			toggle_class(div1, "fullscreen", /*backgroundColor*/ ctx[2]);
    			add_location(div1, file$8, 37, 0, 710);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t);
    			if (if_block1) if_block1.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*url*/ 1) show_if_1 = /*url*/ ctx[0].includes("youtube");

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					if_block0.m(div0, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*url*/ 1) show_if = /*url*/ ctx[0].includes("vimeo");

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*backgroundColor*/ 4) {
    				set_style(div1, "background-color", /*backgroundColor*/ ctx[2].hex);
    			}

    			if (dirty & /*backgroundColor*/ 4) {
    				toggle_class(div1, "fullscreen", /*backgroundColor*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("VideoEmbed", slots, []);
    	let { url = false } = $$props;
    	let { caption = "" } = $$props;
    	let { backgroundColor = false } = $$props;
    	const writable_props = ["url", "caption", "backgroundColor"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VideoEmbed> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("caption" in $$props) $$invalidate(1, caption = $$props.caption);
    		if ("backgroundColor" in $$props) $$invalidate(2, backgroundColor = $$props.backgroundColor);
    	};

    	$$self.$capture_state = () => ({
    		getVideoId,
    		url,
    		caption,
    		backgroundColor
    	});

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("caption" in $$props) $$invalidate(1, caption = $$props.caption);
    		if ("backgroundColor" in $$props) $$invalidate(2, backgroundColor = $$props.backgroundColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [url, caption, backgroundColor];
    }

    class VideoEmbed extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { url: 0, caption: 1, backgroundColor: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoEmbed",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get url() {
    		throw new Error("<VideoEmbed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<VideoEmbed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caption() {
    		throw new Error("<VideoEmbed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caption(value) {
    		throw new Error("<VideoEmbed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundColor() {
    		throw new Error("<VideoEmbed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundColor(value) {
    		throw new Error("<VideoEmbed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Modules/Audio.svelte generated by Svelte v3.35.0 */

    const { isNaN: isNaN_1 } = globals;
    const file$7 = "src/Components/Modules/Audio.svelte";

    // (176:4) {#if posterImage}
    function create_if_block_1$4(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = urlFor(/*posterImage*/ ctx[5]).width(500).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "poster-image svelte-iwtz3w");
    			attr_dev(img, "alt", /*title*/ ctx[1]);
    			add_location(img, file$7, 176, 6, 3736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*posterImage*/ 32 && img.src !== (img_src_value = urlFor(/*posterImage*/ ctx[5]).width(500).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*title*/ 2) {
    				attr_dev(img, "alt", /*title*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(176:4) {#if posterImage}",
    		ctx
    	});

    	return block;
    }

    // (196:6) {:else}
    function create_else_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*title*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 2) set_data_dev(t, /*title*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(196:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (194:6) {#if link}
    function create_if_block$5(ctx) {
    	let a;
    	let t;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(/*title*/ ctx[1]);
    			attr_dev(a, "href", /*link*/ ctx[2]);
    			attr_dev(a, "target", "_blank2");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "svelte-iwtz3w");
    			add_location(a, file$7, 194, 8, 4152);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 2) set_data_dev(t, /*title*/ ctx[1]);

    			if (dirty & /*link*/ 4) {
    				attr_dev(a, "href", /*link*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(194:6) {#if link}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div5;
    	let audio;
    	let audio_src_value;
    	let audio_updating = false;
    	let audio_animationframe;
    	let audio_is_paused = true;
    	let t0;
    	let div4;
    	let t1;
    	let div0;
    	let t2_value = (/*paused*/ ctx[8] ? "PLAY" : "PAUSE") + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*format*/ ctx[12](/*time*/ ctx[6]) + "";
    	let t4;
    	let t5;
    	let div2;
    	let t6_value = /*format*/ ctx[12](/*duration*/ ctx[7]) + "";
    	let t6;
    	let t7;
    	let div3;
    	let t8;
    	let progress;
    	let progress_value_value;
    	let mounted;
    	let dispose;

    	function audio_timeupdate_handler() {
    		cancelAnimationFrame(audio_animationframe);

    		if (!audio.paused) {
    			audio_animationframe = raf(audio_timeupdate_handler);
    			audio_updating = true;
    		}

    		/*audio_timeupdate_handler*/ ctx[14].call(audio);
    	}

    	let if_block0 = /*posterImage*/ ctx[5] && create_if_block_1$4(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*link*/ ctx[2]) return create_if_block$5;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			audio = element("audio");
    			t0 = space();
    			div4 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			if_block1.c();
    			t8 = space();
    			progress = element("progress");
    			attr_dev(audio, "class", "audio-player");
    			attr_dev(audio, "preload", "auto");
    			if (audio.src !== (audio_src_value = /*url*/ ctx[0])) attr_dev(audio, "src", audio_src_value);
    			if (/*duration*/ ctx[7] === void 0) add_render_callback(() => /*audio_durationchange_handler*/ ctx[15].call(audio));
    			add_location(audio, file$7, 164, 2, 3527);
    			attr_dev(div0, "class", "audio-toggle svelte-iwtz3w");
    			add_location(div0, file$7, 186, 4, 3930);
    			attr_dev(div1, "class", "current-time svelte-iwtz3w");
    			add_location(div1, file$7, 188, 4, 3995);
    			attr_dev(div2, "class", "total-time svelte-iwtz3w");
    			add_location(div2, file$7, 190, 4, 4047);
    			attr_dev(div3, "class", "audio-title svelte-iwtz3w");
    			add_location(div3, file$7, 192, 4, 4101);
    			progress.value = progress_value_value = /*time*/ ctx[6] / /*duration*/ ctx[7] || 0;
    			attr_dev(progress, "class", "svelte-iwtz3w");
    			add_location(progress, file$7, 198, 4, 4255);
    			attr_dev(div4, "class", "controls");
    			add_location(div4, file$7, 173, 2, 3684);
    			attr_dev(div5, "class", "audio svelte-iwtz3w");
    			set_style(div5, "background-color", /*backgroundColor*/ ctx[4]);
    			toggle_class(div5, "audio--full", /*size*/ ctx[3] == true || /*size*/ ctx[3] == "fullWidth");
    			toggle_class(div5, "audio--inline", /*size*/ ctx[3] == "proportional");
    			add_location(div5, file$7, 156, 0, 3286);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, audio);
    			/*audio_binding*/ ctx[17](audio);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			if (if_block0) if_block0.m(div4, null);
    			append_dev(div4, t1);
    			append_dev(div4, div0);
    			append_dev(div0, t2);
    			append_dev(div4, t3);
    			append_dev(div4, div1);
    			append_dev(div1, t4);
    			append_dev(div4, t5);
    			append_dev(div4, div2);
    			append_dev(div2, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			if_block1.m(div3, null);
    			append_dev(div4, t8);
    			append_dev(div4, progress);

    			if (!mounted) {
    				dispose = [
    					listen_dev(audio, "timeupdate", audio_timeupdate_handler),
    					listen_dev(audio, "durationchange", /*audio_durationchange_handler*/ ctx[15]),
    					listen_dev(audio, "play", /*audio_play_pause_handler*/ ctx[16]),
    					listen_dev(audio, "pause", /*audio_play_pause_handler*/ ctx[16]),
    					listen_dev(div5, "mousemove", /*handleMousemove*/ ctx[10], false, false, false),
    					listen_dev(div5, "mousedown", /*handleMousedown*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*url*/ 1 && audio.src !== (audio_src_value = /*url*/ ctx[0])) {
    				attr_dev(audio, "src", audio_src_value);
    			}

    			if (!audio_updating && dirty & /*time*/ 64 && !isNaN_1(/*time*/ ctx[6])) {
    				audio.currentTime = /*time*/ ctx[6];
    			}

    			audio_updating = false;

    			if (dirty & /*paused*/ 256 && audio_is_paused !== (audio_is_paused = /*paused*/ ctx[8])) {
    				audio[audio_is_paused ? "pause" : "play"]();
    			}

    			if (/*posterImage*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					if_block0.m(div4, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*paused*/ 256 && t2_value !== (t2_value = (/*paused*/ ctx[8] ? "PLAY" : "PAUSE") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*time*/ 64 && t4_value !== (t4_value = /*format*/ ctx[12](/*time*/ ctx[6]) + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*duration*/ 128 && t6_value !== (t6_value = /*format*/ ctx[12](/*duration*/ ctx[7]) + "")) set_data_dev(t6, t6_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div3, null);
    				}
    			}

    			if (dirty & /*time, duration*/ 192 && progress_value_value !== (progress_value_value = /*time*/ ctx[6] / /*duration*/ ctx[7] || 0)) {
    				prop_dev(progress, "value", progress_value_value);
    			}

    			if (dirty & /*backgroundColor*/ 16) {
    				set_style(div5, "background-color", /*backgroundColor*/ ctx[4]);
    			}

    			if (dirty & /*size*/ 8) {
    				toggle_class(div5, "audio--full", /*size*/ ctx[3] == true || /*size*/ ctx[3] == "fullWidth");
    			}

    			if (dirty & /*size*/ 8) {
    				toggle_class(div5, "audio--inline", /*size*/ ctx[3] == "proportional");
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			/*audio_binding*/ ctx[17](null);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const controlsTimeoutDuration = 2500;

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Audio", slots, []);
    	let { url = "" } = $$props;
    	let { title = "" } = $$props;
    	let { link = "" } = $$props;
    	let { size = true } = $$props;
    	let { backgroundColor = false } = $$props;
    	let { foregroundColor = false } = $$props;
    	let { posterImage = false } = $$props;

    	// *** VARIABLES
    	let time = 0;

    	let duration = 0;
    	let paused = true;

    	// *** DOM REFERENCES
    	let audioEl = {};

    	// *** FUNCTIONS
    	const handleMousemove = e => {
    		if (e.which !== 1) return; // mouse not down
    		if (!duration) return; // audio not loaded yet
    		const { left, right } = this.getBoundingClientRect();
    		$$invalidate(6, time = duration * (e.clientX - left) / (right - left));
    	};

    	const handleMousedown = e => {
    		const handleMouseup = () => {
    			if (paused) audioEl.play(); else audioEl.pause();
    			cancel();
    		};

    		const cancel = () => {
    			e.target.removeEventListener("mouseup", handleMouseup);
    		};

    		e.target.addEventListener("mouseup", handleMouseup);
    		setTimeout(cancel, 200);
    	};

    	const format = seconds => {
    		if (isNaN(seconds)) return "...";
    		const minutes = Math.floor(seconds / 60);
    		seconds = Math.floor(seconds % 60);
    		if (seconds < 10) seconds = "0" + seconds;
    		return `${minutes}:${seconds}`;
    	};

    	const writable_props = [
    		"url",
    		"title",
    		"link",
    		"size",
    		"backgroundColor",
    		"foregroundColor",
    		"posterImage"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Audio> was created with unknown prop '${key}'`);
    	});

    	function audio_timeupdate_handler() {
    		time = this.currentTime;
    		$$invalidate(6, time);
    	}

    	function audio_durationchange_handler() {
    		duration = this.duration;
    		$$invalidate(7, duration);
    	}

    	function audio_play_pause_handler() {
    		paused = this.paused;
    		$$invalidate(8, paused);
    	}

    	function audio_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			audioEl = $$value;
    			$$invalidate(9, audioEl);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("link" in $$props) $$invalidate(2, link = $$props.link);
    		if ("size" in $$props) $$invalidate(3, size = $$props.size);
    		if ("backgroundColor" in $$props) $$invalidate(4, backgroundColor = $$props.backgroundColor);
    		if ("foregroundColor" in $$props) $$invalidate(13, foregroundColor = $$props.foregroundColor);
    		if ("posterImage" in $$props) $$invalidate(5, posterImage = $$props.posterImage);
    	};

    	$$self.$capture_state = () => ({
    		urlFor,
    		url,
    		title,
    		link,
    		size,
    		backgroundColor,
    		foregroundColor,
    		posterImage,
    		time,
    		duration,
    		paused,
    		controlsTimeoutDuration,
    		audioEl,
    		handleMousemove,
    		handleMousedown,
    		format
    	});

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("link" in $$props) $$invalidate(2, link = $$props.link);
    		if ("size" in $$props) $$invalidate(3, size = $$props.size);
    		if ("backgroundColor" in $$props) $$invalidate(4, backgroundColor = $$props.backgroundColor);
    		if ("foregroundColor" in $$props) $$invalidate(13, foregroundColor = $$props.foregroundColor);
    		if ("posterImage" in $$props) $$invalidate(5, posterImage = $$props.posterImage);
    		if ("time" in $$props) $$invalidate(6, time = $$props.time);
    		if ("duration" in $$props) $$invalidate(7, duration = $$props.duration);
    		if ("paused" in $$props) $$invalidate(8, paused = $$props.paused);
    		if ("audioEl" in $$props) $$invalidate(9, audioEl = $$props.audioEl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		url,
    		title,
    		link,
    		size,
    		backgroundColor,
    		posterImage,
    		time,
    		duration,
    		paused,
    		audioEl,
    		handleMousemove,
    		handleMousedown,
    		format,
    		foregroundColor,
    		audio_timeupdate_handler,
    		audio_durationchange_handler,
    		audio_play_pause_handler,
    		audio_binding
    	];
    }

    class Audio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			url: 0,
    			title: 1,
    			link: 2,
    			size: 3,
    			backgroundColor: 4,
    			foregroundColor: 13,
    			posterImage: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Audio",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get url() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get link() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set link(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get backgroundColor() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set backgroundColor(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get foregroundColor() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set foregroundColor(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get posterImage() {
    		throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set posterImage(value) {
    		throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Components/Modules/ArbitraryEmbed.svelte generated by Svelte v3.35.0 */

    const file$6 = "src/Components/Modules/ArbitraryEmbed.svelte";

    function create_fragment$6(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "inner svelte-1w0gs4n");
    			add_location(div0, file$6, 37, 4, 765);
    			attr_dev(div1, "class", "embed svelte-1w0gs4n");
    			add_location(div1, file$6, 36, 2, 741);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = /*code*/ ctx[0];
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*code*/ 1) div0.innerHTML = /*code*/ ctx[0];		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ArbitraryEmbed", slots, []);
    	let { code = "" } = $$props;
    	const writable_props = ["code"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ArbitraryEmbed> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("code" in $$props) $$invalidate(0, code = $$props.code);
    	};

    	$$self.$capture_state = () => ({ code });

    	$$self.$inject_state = $$props => {
    		if ("code" in $$props) $$invalidate(0, code = $$props.code);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [code];
    }

    class ArbitraryEmbed extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { code: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArbitraryEmbed",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get code() {
    		throw new Error("<ArbitraryEmbed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set code(value) {
    		throw new Error("<ArbitraryEmbed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Routes/Article.svelte generated by Svelte v3.35.0 */

    const { console: console_1$3 } = globals;
    const file$5 = "src/Routes/Article.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  ARTICLE   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_catch_block$4(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$4.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  ARTICLE   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (157:23)    <MetaData {post}
    function create_then_block$4(ctx) {
    	let metadata;
    	let t0;
    	let t1;
    	let article;
    	let div0;
    	let preview;
    	let t2;
    	let div1;
    	let taxlist;
    	let t3;
    	let h1;
    	let raw_value = /*post*/ ctx[1].title + "";
    	let t4;
    	let t5;
    	let div2;
    	let t6;
    	let show_if;
    	let current_block_type_index;
    	let if_block2;
    	let t7;
    	let footer;
    	let current;

    	metadata = new MetaData({
    			props: { post: /*post*/ ctx[1] },
    			$$inline: true
    		});

    	let if_block0 = /*post*/ ctx[1].banner && /*bannerActive*/ ctx[0] && create_if_block_10$1(ctx);

    	preview = new Preview({
    			props: { post: /*post*/ ctx[1], isHeader: true },
    			$$inline: true
    		});

    	taxlist = new TaxList({
    			props: {
    				taxonomy: /*post*/ ctx[1].taxonomy,
    				white: false,
    				isArticle: true,
    				date: /*post*/ ctx[1].publicationDate
    			},
    			$$inline: true
    		});

    	let if_block1 = /*post*/ ctx[1].adTag && create_if_block_9$1(ctx);
    	let each_value = /*post*/ ctx[1].content;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const if_block_creators = [create_if_block$4, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*post*/ 2) show_if = !!(/*post*/ ctx[1].related && !isEmpty_1(/*post*/ ctx[1].related));
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	footer = new Footer({ props: { active: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(metadata.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			article = element("article");
    			div0 = element("div");
    			create_component(preview.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(taxlist.$$.fragment);
    			t3 = space();
    			h1 = element("h1");
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			if_block2.c();
    			t7 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div0, "class", "article__header");
    			add_location(div0, file$5, 178, 4, 4464);
    			attr_dev(div1, "class", "article__tags svelte-9xc9wy");
    			add_location(div1, file$5, 183, 4, 4576);
    			attr_dev(h1, "class", "article__title svelte-9xc9wy");
    			add_location(h1, file$5, 192, 4, 4773);
    			attr_dev(div2, "class", "content");
    			add_location(div2, file$5, 202, 4, 4944);
    			attr_dev(article, "class", "article svelte-9xc9wy");
    			add_location(article, file$5, 176, 2, 4408);
    		},
    		m: function mount(target, anchor) {
    			mount_component(metadata, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, article, anchor);
    			append_dev(article, div0);
    			mount_component(preview, div0, null);
    			append_dev(article, t2);
    			append_dev(article, div1);
    			mount_component(taxlist, div1, null);
    			append_dev(article, t3);
    			append_dev(article, h1);
    			h1.innerHTML = raw_value;
    			append_dev(article, t4);
    			if (if_block1) if_block1.m(article, null);
    			append_dev(article, t5);
    			append_dev(article, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(article, t6);
    			if_blocks[current_block_type_index].m(article, null);
    			insert_dev(target, t7, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const metadata_changes = {};
    			if (dirty & /*post*/ 2) metadata_changes.post = /*post*/ ctx[1];
    			metadata.$set(metadata_changes);

    			if (/*post*/ ctx[1].banner && /*bannerActive*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*post, bannerActive*/ 3) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_10$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const preview_changes = {};
    			if (dirty & /*post*/ 2) preview_changes.post = /*post*/ ctx[1];
    			preview.$set(preview_changes);
    			const taxlist_changes = {};
    			if (dirty & /*post*/ 2) taxlist_changes.taxonomy = /*post*/ ctx[1].taxonomy;
    			if (dirty & /*post*/ 2) taxlist_changes.date = /*post*/ ctx[1].publicationDate;
    			taxlist.$set(taxlist_changes);
    			if ((!current || dirty & /*post*/ 2) && raw_value !== (raw_value = /*post*/ ctx[1].title + "")) h1.innerHTML = raw_value;
    			if (/*post*/ ctx[1].adTag) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$1(ctx);
    					if_block1.c();
    					if_block1.m(article, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*post, get, renderBlockText*/ 2) {
    				each_value = /*post*/ ctx[1].content;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(article, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(metadata.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(preview.$$.fragment, local);
    			transition_in(taxlist.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block2);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(metadata.$$.fragment, local);
    			transition_out(preview.$$.fragment, local);
    			transition_out(taxlist.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block2);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(metadata, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(article);
    			destroy_component(preview);
    			destroy_component(taxlist);
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t7);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$4.name,
    		type: "then",
    		source: "(157:23)    <MetaData {post}",
    		ctx
    	});

    	return block;
    }

    // (160:2) {#if post.banner && bannerActive}
    function create_if_block_10$1(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let a_href_value;
    	let a_intro;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			attr_dev(img, "alt", "novembre.global");
    			if (img.src !== (img_src_value = urlFor(/*post*/ ctx[1].banner.image).width(500).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "svelte-9xc9wy");
    			add_location(img, file$5, 166, 6, 4222);
    			attr_dev(a, "href", a_href_value = /*post*/ ctx[1].banner.link);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "sidebar-banner svelte-9xc9wy");
    			add_location(a, file$5, 160, 4, 4094);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*post*/ 2 && img.src !== (img_src_value = urlFor(/*post*/ ctx[1].banner.image).width(500).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*post*/ 2 && a_href_value !== (a_href_value = /*post*/ ctx[1].banner.link)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (!a_intro) {
    				add_render_callback(() => {
    					a_intro = create_in_transition(a, fade, {});
    					a_intro.start();
    				});
    			}
    		},
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(160:2) {#if post.banner && bannerActive}",
    		ctx
    	});

    	return block;
    }

    // (198:4) {#if post.adTag}
    function create_if_block_9$1(ctx) {
    	let html_tag;
    	let raw_value = /*post*/ ctx[1].adTag + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*post*/ 2 && raw_value !== (raw_value = /*post*/ ctx[1].adTag + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(198:4) {#if post.adTag}",
    		ctx
    	});

    	return block;
    }

    // (205:8) {#if c._type == 'block'}
    function create_if_block_8$1(ctx) {
    	let html_tag;
    	let raw_value = renderBlockText(/*c*/ ctx[5]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*post*/ 2 && raw_value !== (raw_value = renderBlockText(/*c*/ ctx[5]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(205:8) {#if c._type == 'block'}",
    		ctx
    	});

    	return block;
    }

    // (208:8) {#if c._type == 'singleImage'}
    function create_if_block_7$1(ctx) {
    	let image;
    	let current;

    	image = new Image$1({
    			props: {
    				imageObject: /*c*/ ctx[5].image,
    				linkUrl: /*c*/ ctx[5].linkUrl,
    				inlineDisplay: /*c*/ ctx[5].noBottomMargin ? false : true,
    				maxHeight: get_1(/*c*/ ctx[5], "maxHeight", false),
    				backgroundColor: get_1(/*c*/ ctx[5], "backgroundColor", false),
    				caption: get_1(/*c*/ ctx[5], "caption", false),
    				alignment: get_1(/*c*/ ctx[5], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[5], "fullwidth", "")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(image.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(image, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const image_changes = {};
    			if (dirty & /*post*/ 2) image_changes.imageObject = /*c*/ ctx[5].image;
    			if (dirty & /*post*/ 2) image_changes.linkUrl = /*c*/ ctx[5].linkUrl;
    			if (dirty & /*post*/ 2) image_changes.inlineDisplay = /*c*/ ctx[5].noBottomMargin ? false : true;
    			if (dirty & /*post*/ 2) image_changes.maxHeight = get_1(/*c*/ ctx[5], "maxHeight", false);
    			if (dirty & /*post*/ 2) image_changes.backgroundColor = get_1(/*c*/ ctx[5], "backgroundColor", false);
    			if (dirty & /*post*/ 2) image_changes.caption = get_1(/*c*/ ctx[5], "caption", false);
    			if (dirty & /*post*/ 2) image_changes.alignment = get_1(/*c*/ ctx[5], "alignment", "");
    			if (dirty & /*post*/ 2) image_changes.fullwidth = get_1(/*c*/ ctx[5], "fullwidth", "");
    			image.$set(image_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(image, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(208:8) {#if c._type == 'singleImage'}",
    		ctx
    	});

    	return block;
    }

    // (219:8) {#if c._type == 'imageGroup'}
    function create_if_block_6$3(ctx) {
    	let imagegroup;
    	let current;

    	imagegroup = new ImageGroup({
    			props: {
    				imageArray: /*c*/ ctx[5].images,
    				linkUrl: /*c*/ ctx[5].linkUrl,
    				inlineDisplay: /*c*/ ctx[5].noBottomMargin ? false : true,
    				maxHeight: get_1(/*c*/ ctx[5], "maxHeight", false),
    				backgroundColor: get_1(/*c*/ ctx[5], "backgroundColor", false),
    				alignment: get_1(/*c*/ ctx[5], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[5], "fullwidth", ""),
    				caption: get_1(/*c*/ ctx[5], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(imagegroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(imagegroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagegroup_changes = {};
    			if (dirty & /*post*/ 2) imagegroup_changes.imageArray = /*c*/ ctx[5].images;
    			if (dirty & /*post*/ 2) imagegroup_changes.linkUrl = /*c*/ ctx[5].linkUrl;
    			if (dirty & /*post*/ 2) imagegroup_changes.inlineDisplay = /*c*/ ctx[5].noBottomMargin ? false : true;
    			if (dirty & /*post*/ 2) imagegroup_changes.maxHeight = get_1(/*c*/ ctx[5], "maxHeight", false);
    			if (dirty & /*post*/ 2) imagegroup_changes.backgroundColor = get_1(/*c*/ ctx[5], "backgroundColor", false);
    			if (dirty & /*post*/ 2) imagegroup_changes.alignment = get_1(/*c*/ ctx[5], "alignment", "");
    			if (dirty & /*post*/ 2) imagegroup_changes.fullwidth = get_1(/*c*/ ctx[5], "fullwidth", "");
    			if (dirty & /*post*/ 2) imagegroup_changes.caption = get_1(/*c*/ ctx[5], "caption", false);
    			imagegroup.$set(imagegroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagegroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagegroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(imagegroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(219:8) {#if c._type == 'imageGroup'}",
    		ctx
    	});

    	return block;
    }

    // (230:8) {#if c._type == 'videoLoop'}
    function create_if_block_5$3(ctx) {
    	let videoloop;
    	let current;

    	videoloop = new Video({
    			props: {
    				url: "https://cdn.sanity.io/files/gj963qwj/production/" + /*c*/ ctx[5].video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"),
    				inlineDisplay: /*c*/ ctx[5].noBottomMargin ? false : true,
    				posterImage: get_1(/*c*/ ctx[5], "preview.posterImage", ""),
    				autoplay: get_1(/*c*/ ctx[5], "autoplay", false),
    				maxHeight: get_1(/*c*/ ctx[5], "maxHeight", false),
    				backgroundColor: get_1(/*c*/ ctx[5], "backgroundColor", false),
    				caption: get_1(/*c*/ ctx[5], "caption", false),
    				alignment: get_1(/*c*/ ctx[5], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[5], "fullwidth", "")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(videoloop.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoloop, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoloop_changes = {};
    			if (dirty & /*post*/ 2) videoloop_changes.url = "https://cdn.sanity.io/files/gj963qwj/production/" + /*c*/ ctx[5].video.asset._ref.replace("file-", "").replace("-mp4", ".mp4");
    			if (dirty & /*post*/ 2) videoloop_changes.inlineDisplay = /*c*/ ctx[5].noBottomMargin ? false : true;
    			if (dirty & /*post*/ 2) videoloop_changes.posterImage = get_1(/*c*/ ctx[5], "preview.posterImage", "");
    			if (dirty & /*post*/ 2) videoloop_changes.autoplay = get_1(/*c*/ ctx[5], "autoplay", false);
    			if (dirty & /*post*/ 2) videoloop_changes.maxHeight = get_1(/*c*/ ctx[5], "maxHeight", false);
    			if (dirty & /*post*/ 2) videoloop_changes.backgroundColor = get_1(/*c*/ ctx[5], "backgroundColor", false);
    			if (dirty & /*post*/ 2) videoloop_changes.caption = get_1(/*c*/ ctx[5], "caption", false);
    			if (dirty & /*post*/ 2) videoloop_changes.alignment = get_1(/*c*/ ctx[5], "alignment", "");
    			if (dirty & /*post*/ 2) videoloop_changes.fullwidth = get_1(/*c*/ ctx[5], "fullwidth", "");
    			videoloop.$set(videoloop_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoloop.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoloop.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoloop, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(230:8) {#if c._type == 'videoLoop'}",
    		ctx
    	});

    	return block;
    }

    // (244:8) {#if c._type == 'video'}
    function create_if_block_4$3(ctx) {
    	let videoembed;
    	let current;

    	videoembed = new VideoEmbed({
    			props: {
    				url: /*c*/ ctx[5].video,
    				backgroundColor: get_1(/*c*/ ctx[5], "backgroundColor", false),
    				caption: get_1(/*c*/ ctx[5], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(videoembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoembed, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoembed_changes = {};
    			if (dirty & /*post*/ 2) videoembed_changes.url = /*c*/ ctx[5].video;
    			if (dirty & /*post*/ 2) videoembed_changes.backgroundColor = get_1(/*c*/ ctx[5], "backgroundColor", false);
    			if (dirty & /*post*/ 2) videoembed_changes.caption = get_1(/*c*/ ctx[5], "caption", false);
    			videoembed.$set(videoembed_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(244:8) {#if c._type == 'video'}",
    		ctx
    	});

    	return block;
    }

    // (250:8) {#if c._type == 'slideshow'}
    function create_if_block_3$3(ctx) {
    	let slideshow;
    	let current;

    	slideshow = new Slideshow({
    			props: {
    				autoplay: /*c*/ ctx[5].autoplay,
    				imageArray: /*c*/ ctx[5].images
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slideshow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slideshow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slideshow_changes = {};
    			if (dirty & /*post*/ 2) slideshow_changes.autoplay = /*c*/ ctx[5].autoplay;
    			if (dirty & /*post*/ 2) slideshow_changes.imageArray = /*c*/ ctx[5].images;
    			slideshow.$set(slideshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slideshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slideshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slideshow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(250:8) {#if c._type == 'slideshow'}",
    		ctx
    	});

    	return block;
    }

    // (253:8) {#if c._type == 'audio'}
    function create_if_block_2$3(ctx) {
    	let audio;
    	let current;

    	audio = new Audio({
    			props: {
    				url: "https://cdn.sanity.io/files/gj963qwj/production/" + /*c*/ ctx[5].audio.asset._ref.replace("file-", "").replace("-mp3", ".mp3"),
    				title: get_1(/*c*/ ctx[5], "title", ""),
    				link: get_1(/*c*/ ctx[5], "link", false),
    				posterImage: get_1(/*c*/ ctx[5], "image", false),
    				backgroundColor: get_1(/*c*/ ctx[5], "backgroundColor.hex", false),
    				foregroundColor: get_1(/*c*/ ctx[5], "foregroundColor.hex", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(audio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const audio_changes = {};
    			if (dirty & /*post*/ 2) audio_changes.url = "https://cdn.sanity.io/files/gj963qwj/production/" + /*c*/ ctx[5].audio.asset._ref.replace("file-", "").replace("-mp3", ".mp3");
    			if (dirty & /*post*/ 2) audio_changes.title = get_1(/*c*/ ctx[5], "title", "");
    			if (dirty & /*post*/ 2) audio_changes.link = get_1(/*c*/ ctx[5], "link", false);
    			if (dirty & /*post*/ 2) audio_changes.posterImage = get_1(/*c*/ ctx[5], "image", false);
    			if (dirty & /*post*/ 2) audio_changes.backgroundColor = get_1(/*c*/ ctx[5], "backgroundColor.hex", false);
    			if (dirty & /*post*/ 2) audio_changes.foregroundColor = get_1(/*c*/ ctx[5], "foregroundColor.hex", false);
    			audio.$set(audio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(253:8) {#if c._type == 'audio'}",
    		ctx
    	});

    	return block;
    }

    // (264:8) {#if c._type == 'arbitraryEmbed'}
    function create_if_block_1$3(ctx) {
    	let arbitraryembed;
    	let current;

    	arbitraryembed = new ArbitraryEmbed({
    			props: { code: /*c*/ ctx[5].embedCode },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(arbitraryembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(arbitraryembed, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const arbitraryembed_changes = {};
    			if (dirty & /*post*/ 2) arbitraryembed_changes.code = /*c*/ ctx[5].embedCode;
    			arbitraryembed.$set(arbitraryembed_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arbitraryembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arbitraryembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(arbitraryembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(264:8) {#if c._type == 'arbitraryEmbed'}",
    		ctx
    	});

    	return block;
    }

    // (204:6) {#each post.content as c}
    function create_each_block$2(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let if_block7_anchor;
    	let current;
    	let if_block0 = /*c*/ ctx[5]._type == "block" && create_if_block_8$1(ctx);
    	let if_block1 = /*c*/ ctx[5]._type == "singleImage" && create_if_block_7$1(ctx);
    	let if_block2 = /*c*/ ctx[5]._type == "imageGroup" && create_if_block_6$3(ctx);
    	let if_block3 = /*c*/ ctx[5]._type == "videoLoop" && create_if_block_5$3(ctx);
    	let if_block4 = /*c*/ ctx[5]._type == "video" && create_if_block_4$3(ctx);
    	let if_block5 = /*c*/ ctx[5]._type == "slideshow" && create_if_block_3$3(ctx);
    	let if_block6 = /*c*/ ctx[5]._type == "audio" && create_if_block_2$3(ctx);
    	let if_block7 = /*c*/ ctx[5]._type == "arbitraryEmbed" && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			t6 = space();
    			if (if_block7) if_block7.c();
    			if_block7_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, t6, anchor);
    			if (if_block7) if_block7.m(target, anchor);
    			insert_dev(target, if_block7_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*c*/ ctx[5]._type == "block") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_8$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*c*/ ctx[5]._type == "singleImage") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_7$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[5]._type == "imageGroup") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_6$3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[5]._type == "videoLoop") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_5$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[5]._type == "video") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_4$3(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t4.parentNode, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[5]._type == "slideshow") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_3$3(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t5.parentNode, t5);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[5]._type == "audio") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_2$3(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(t6.parentNode, t6);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[5]._type == "arbitraryEmbed") {
    				if (if_block7) {
    					if_block7.p(ctx, dirty);

    					if (dirty & /*post*/ 2) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_1$3(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(if_block7_anchor.parentNode, if_block7_anchor);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (if_block7) if_block7.d(detaching);
    			if (detaching) detach_dev(if_block7_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(204:6) {#each post.content as c}",
    		ctx
    	});

    	return block;
    }

    // (275:4) {:else}
    function create_else_block(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "bottom-space svelte-9xc9wy");
    			add_location(div, file$5, 275, 6, 7845);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(275:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (272:4) {#if post.related && !isEmpty(post.related)}
    function create_if_block$4(ctx) {
    	let div;
    	let t1;
    	let slideshow;
    	let current;

    	slideshow = new Slideshow({
    			props: {
    				imageArray: /*post*/ ctx[1].related,
    				isRelated: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "RELATED ARTICLES";
    			t1 = space();
    			create_component(slideshow.$$.fragment);
    			attr_dev(div, "class", "related-header svelte-9xc9wy");
    			add_location(div, file$5, 272, 6, 7713);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(slideshow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slideshow_changes = {};
    			if (dirty & /*post*/ 2) slideshow_changes.imageArray = /*post*/ ctx[1].related;
    			slideshow.$set(slideshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slideshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slideshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			destroy_component(slideshow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(272:4) {#if post.related && !isEmpty(post.related)}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  ARTICLE   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_pending_block$4(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$4.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  ARTICLE   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$4,
    		then: create_then_block$4,
    		catch: create_catch_block$4,
    		value: 1,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*post*/ ctx[1], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*post*/ 2 && promise !== (promise = /*post*/ ctx[1]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[1] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const query$1 = "*[slug.current == $slug]{..., 'previewVideoUrl': preview[0].video.asset->url, related[]->{title, 'slug': slug.current, mainImage, relatedSlideshow, 'category': taxonomy.category}}[0]";

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Article", slots, []);
    	let { slug = "" } = $$props;
    	let { location = {} } = $$props;

    	// *** VARIABLES
    	let currentSlug = slug;

    	let bannerActive = false;
    	navigationColor.set("black");
    	scrollListActive.set(false);
    	let post = loadArticle(query$1, { slug });

    	post.then(p => {
    		console.log("post", p);
    	});

    	// *** ON MOUNT
    	onMount(async () => {
    		window.scrollTo(0, 0);

    		setTimeout(
    			() => {
    				$$invalidate(0, bannerActive = true);
    			},
    			3000
    		);
    	});

    	const writable_props = ["slug", "location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Article> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("slug" in $$props) $$invalidate(2, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(3, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		fade,
    		get: get_1,
    		isEmpty: isEmpty_1,
    		urlFor,
    		loadArticle,
    		renderBlockText,
    		TaxList,
    		Footer,
    		Preview,
    		MetaData,
    		navigationColor,
    		scrollListActive,
    		Image: Image$1,
    		ImageGroup,
    		VideoEmbed,
    		Audio,
    		ArbitraryEmbed,
    		Slideshow,
    		VideoLoop: Video,
    		slug,
    		location,
    		query: query$1,
    		currentSlug,
    		bannerActive,
    		post
    	});

    	$$self.$inject_state = $$props => {
    		if ("slug" in $$props) $$invalidate(2, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(3, location = $$props.location);
    		if ("currentSlug" in $$props) $$invalidate(4, currentSlug = $$props.currentSlug);
    		if ("bannerActive" in $$props) $$invalidate(0, bannerActive = $$props.bannerActive);
    		if ("post" in $$props) $$invalidate(1, post = $$props.post);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*slug, currentSlug*/ 20) {
    			// *** REACTIVE
    			{
    				if (slug !== currentSlug) {
    					$$invalidate(1, post = loadArticle(query$1, { slug }));
    					$$invalidate(4, currentSlug = slug);
    				}
    			}
    		}
    	};

    	return [bannerActive, post, slug, location, currentSlug];
    }

    class Article extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { slug: 2, location: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Article",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get slug() {
    		throw new Error("<Article>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slug(value) {
    		throw new Error("<Article>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<Article>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<Article>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Routes/About.svelte generated by Svelte v3.35.0 */

    const { console: console_1$2 } = globals;
    const file$4 = "src/Routes/About.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  ABOUT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_catch_block$3(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$3.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  ABOUT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (90:26)    <article class="about">      <div class="about-text">       {#each pages.about.content as c}
    function create_then_block$3(ctx) {
    	let article;
    	let div0;
    	let t0;
    	let div4;
    	let div1;
    	let raw0_value = renderBlockText(get_1(/*pages*/ ctx[3], "credits.columnOne.content", [])) + "";
    	let t1;
    	let div2;
    	let raw1_value = renderBlockText(get_1(/*pages*/ ctx[3], "credits.columnTwo.content", [])) + "";
    	let t2;
    	let div3;
    	let raw2_value = renderBlockText(get_1(/*pages*/ ctx[3], "credits.columnThree.content", [])) + "";
    	let t3;
    	let footer;
    	let current;
    	let each_value = /*pages*/ ctx[3].about.content;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	footer = new Footer({ props: { active: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			article = element("article");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div4 = element("div");
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			t3 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div0, "class", "about-text svelte-8lzld0");
    			add_location(div0, file$4, 92, 4, 2314);
    			attr_dev(div1, "class", "about-credits-column svelte-8lzld0");
    			add_location(div1, file$4, 138, 6, 3845);
    			attr_dev(div2, "class", "about-credits-column svelte-8lzld0");
    			add_location(div2, file$4, 142, 6, 3977);
    			attr_dev(div3, "class", "about-credits-column svelte-8lzld0");
    			add_location(div3, file$4, 146, 6, 4109);
    			attr_dev(div4, "class", "about-credits svelte-8lzld0");
    			add_location(div4, file$4, 136, 4, 3810);
    			attr_dev(article, "class", "about svelte-8lzld0");
    			add_location(article, file$4, 90, 2, 2285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article, anchor);
    			append_dev(article, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(article, t0);
    			append_dev(article, div4);
    			append_dev(div4, div1);
    			div1.innerHTML = raw0_value;
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			div2.innerHTML = raw1_value;
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			div3.innerHTML = raw2_value;
    			insert_dev(target, t3, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*console, $pages, get, renderBlockText*/ 1) {
    				each_value = /*pages*/ ctx[3].about.content;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if ((!current || dirty & /*$pages*/ 1) && raw0_value !== (raw0_value = renderBlockText(get_1(/*pages*/ ctx[3], "credits.columnOne.content", [])) + "")) div1.innerHTML = raw0_value;			if ((!current || dirty & /*$pages*/ 1) && raw1_value !== (raw1_value = renderBlockText(get_1(/*pages*/ ctx[3], "credits.columnTwo.content", [])) + "")) div2.innerHTML = raw1_value;			if ((!current || dirty & /*$pages*/ 1) && raw2_value !== (raw2_value = renderBlockText(get_1(/*pages*/ ctx[3], "credits.columnThree.content", [])) + "")) div3.innerHTML = raw2_value;		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$3.name,
    		type: "then",
    		source: "(90:26)    <article class=\\\"about\\\">      <div class=\\\"about-text\\\">       {#each pages.about.content as c}",
    		ctx
    	});

    	return block;
    }

    // (95:8) {#if c._type == 'block'}
    function create_if_block_6$2(ctx) {
    	let html_tag;
    	let raw_value = renderBlockText(/*c*/ ctx[4]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$pages*/ 1 && raw_value !== (raw_value = renderBlockText(/*c*/ ctx[4]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(95:8) {#if c._type == 'block'}",
    		ctx
    	});

    	return block;
    }

    // (98:8) {#if c._type == 'singleImage'}
    function create_if_block_5$2(ctx) {
    	let image;
    	let current;

    	image = new Image$1({
    			props: {
    				imageObject: /*c*/ ctx[4].image,
    				inlineDisplay: true,
    				maxHeight: get_1(/*c*/ ctx[4], "maxHeight", false),
    				backgroundColor: get_1(/*c*/ ctx[4], "backgroundColor", false),
    				caption: get_1(/*c*/ ctx[4], "caption", false),
    				alignment: get_1(/*c*/ ctx[4], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[4], "fullwidth", "")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(image.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(image, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const image_changes = {};
    			if (dirty & /*$pages*/ 1) image_changes.imageObject = /*c*/ ctx[4].image;
    			if (dirty & /*$pages*/ 1) image_changes.maxHeight = get_1(/*c*/ ctx[4], "maxHeight", false);
    			if (dirty & /*$pages*/ 1) image_changes.backgroundColor = get_1(/*c*/ ctx[4], "backgroundColor", false);
    			if (dirty & /*$pages*/ 1) image_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			if (dirty & /*$pages*/ 1) image_changes.alignment = get_1(/*c*/ ctx[4], "alignment", "");
    			if (dirty & /*$pages*/ 1) image_changes.fullwidth = get_1(/*c*/ ctx[4], "fullwidth", "");
    			image.$set(image_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(image, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(98:8) {#if c._type == 'singleImage'}",
    		ctx
    	});

    	return block;
    }

    // (108:8) {#if c._type == 'imageGroup'}
    function create_if_block_4$2(ctx) {
    	let imagegroup;
    	let current;

    	imagegroup = new ImageGroup({
    			props: {
    				imageArray: /*c*/ ctx[4].images,
    				inlineDisplay: true,
    				maxHeight: get_1(/*c*/ ctx[4], "maxHeight", false),
    				backgroundColor: get_1(/*c*/ ctx[4], "backgroundColor", false),
    				alignment: get_1(/*c*/ ctx[4], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[4], "fullwidth", ""),
    				caption: get_1(/*c*/ ctx[4], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(imagegroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(imagegroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagegroup_changes = {};
    			if (dirty & /*$pages*/ 1) imagegroup_changes.imageArray = /*c*/ ctx[4].images;
    			if (dirty & /*$pages*/ 1) imagegroup_changes.maxHeight = get_1(/*c*/ ctx[4], "maxHeight", false);
    			if (dirty & /*$pages*/ 1) imagegroup_changes.backgroundColor = get_1(/*c*/ ctx[4], "backgroundColor", false);
    			if (dirty & /*$pages*/ 1) imagegroup_changes.alignment = get_1(/*c*/ ctx[4], "alignment", "");
    			if (dirty & /*$pages*/ 1) imagegroup_changes.fullwidth = get_1(/*c*/ ctx[4], "fullwidth", "");
    			if (dirty & /*$pages*/ 1) imagegroup_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			imagegroup.$set(imagegroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagegroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagegroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(imagegroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(108:8) {#if c._type == 'imageGroup'}",
    		ctx
    	});

    	return block;
    }

    // (118:8) {#if c._type == 'video'}
    function create_if_block_3$2(ctx) {
    	let videoembed;
    	let current;

    	videoembed = new VideoEmbed({
    			props: {
    				url: /*c*/ ctx[4].video,
    				backgroundColor: get_1(/*c*/ ctx[4], "backgroundColor", false),
    				caption: get_1(/*c*/ ctx[4], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(videoembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoembed, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoembed_changes = {};
    			if (dirty & /*$pages*/ 1) videoembed_changes.url = /*c*/ ctx[4].video;
    			if (dirty & /*$pages*/ 1) videoembed_changes.backgroundColor = get_1(/*c*/ ctx[4], "backgroundColor", false);
    			if (dirty & /*$pages*/ 1) videoembed_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			videoembed.$set(videoembed_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(118:8) {#if c._type == 'video'}",
    		ctx
    	});

    	return block;
    }

    // (124:8) {#if c._type == 'slideshow'}
    function create_if_block_2$2(ctx) {
    	let slideshow;
    	let current;

    	slideshow = new Slideshow({
    			props: { imageArray: /*c*/ ctx[4].images },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slideshow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slideshow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slideshow_changes = {};
    			if (dirty & /*$pages*/ 1) slideshow_changes.imageArray = /*c*/ ctx[4].images;
    			slideshow.$set(slideshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slideshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slideshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slideshow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(124:8) {#if c._type == 'slideshow'}",
    		ctx
    	});

    	return block;
    }

    // (127:8) {#if c._type == 'audio'}
    function create_if_block_1$2(ctx) {
    	let audio;
    	let current;

    	audio = new Audio({
    			props: { fileObject: /*c*/ ctx[4].audio },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(audio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const audio_changes = {};
    			if (dirty & /*$pages*/ 1) audio_changes.fileObject = /*c*/ ctx[4].audio;
    			audio.$set(audio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(127:8) {#if c._type == 'audio'}",
    		ctx
    	});

    	return block;
    }

    // (130:8) {#if c._type == 'arbitraryEmbed'}
    function create_if_block$3(ctx) {
    	let arbitraryembed;
    	let current;

    	arbitraryembed = new ArbitraryEmbed({
    			props: { code: console.arbitraryEmbed },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(arbitraryembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(arbitraryembed, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arbitraryembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arbitraryembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(arbitraryembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(130:8) {#if c._type == 'arbitraryEmbed'}",
    		ctx
    	});

    	return block;
    }

    // (94:6) {#each pages.about.content as c}
    function create_each_block$1(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*c*/ ctx[4]._type == "block" && create_if_block_6$2(ctx);
    	let if_block1 = /*c*/ ctx[4]._type == "singleImage" && create_if_block_5$2(ctx);
    	let if_block2 = /*c*/ ctx[4]._type == "imageGroup" && create_if_block_4$2(ctx);
    	let if_block3 = /*c*/ ctx[4]._type == "video" && create_if_block_3$2(ctx);
    	let if_block4 = /*c*/ ctx[4]._type == "slideshow" && create_if_block_2$2(ctx);
    	let if_block5 = /*c*/ ctx[4]._type == "audio" && create_if_block_1$2(ctx);
    	let if_block6 = /*c*/ ctx[4]._type == "arbitraryEmbed" && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*c*/ ctx[4]._type == "block") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*c*/ ctx[4]._type == "singleImage") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "imageGroup") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_4$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "video") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_3$2(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "slideshow") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_2$2(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t4.parentNode, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "audio") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_1$2(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t5.parentNode, t5);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "arbitraryEmbed") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block$3(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(94:6) {#each pages.about.content as c}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  ABOUT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_pending_block$3(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$3.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  ABOUT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let metadata;
    	let t;
    	let await_block_anchor;
    	let promise;
    	let current;

    	metadata = new MetaData({
    			props: { post: { title: "About" } },
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$3,
    		then: create_then_block$3,
    		catch: create_catch_block$3,
    		value: 3,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*$pages*/ ctx[0], info);

    	const block = {
    		c: function create() {
    			create_component(metadata.$$.fragment);
    			t = space();
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(metadata, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$pages*/ 1 && promise !== (promise = /*$pages*/ ctx[0]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[3] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(metadata.$$.fragment, local);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(metadata.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(metadata, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $pages;
    	validate_store(pages, "pages");
    	component_subscribe($$self, pages, $$value => $$invalidate(0, $pages = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("About", slots, []);
    	let { slug = "" } = $$props;
    	let { location = {} } = $$props;
    	navigationColor.set("black");
    	scrollListActive.set(false);

    	// *** ON MOUNT
    	onMount(async () => {
    		window.scrollTo(0, 0);
    	});

    	const writable_props = ["slug", "location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<About> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("slug" in $$props) $$invalidate(1, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(2, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		renderBlockText,
    		get: get_1,
    		navigationColor,
    		pages,
    		scrollListActive,
    		Image: Image$1,
    		ImageGroup,
    		VideoEmbed,
    		ArbitraryEmbed,
    		Audio,
    		Slideshow,
    		Footer,
    		MetaData,
    		slug,
    		location,
    		$pages
    	});

    	$$self.$inject_state = $$props => {
    		if ("slug" in $$props) $$invalidate(1, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(2, location = $$props.location);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$pages, slug, location];
    }

    class About extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { slug: 1, location: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "About",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get slug() {
    		throw new Error("<About>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slug(value) {
    		throw new Error("<About>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<About>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<About>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Routes/Contact.svelte generated by Svelte v3.35.0 */

    const { console: console_1$1 } = globals;
    const file$3 = "src/Routes/Contact.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  CONTACT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_catch_block$2(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$2.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  CONTACT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (82:26)    <article class="contact">      <div class="contact-section">       {#if has(pages, 'contact.content') && Array.isArray(pages.contact.content)}
    function create_then_block$2(ctx) {
    	let article;
    	let div0;
    	let show_if_1 = has_1(/*pages*/ ctx[3], "contact.content") && Array.isArray(/*pages*/ ctx[3].contact.content);
    	let t0;
    	let div1;
    	let newslettersignup;
    	let t1;
    	let div2;
    	let show_if = has_1(/*pages*/ ctx[3], "socialMedia.content") && Array.isArray(/*pages*/ ctx[3].socialMedia.content);
    	let t2;
    	let footer;
    	let current;
    	let if_block0 = show_if_1 && create_if_block_7(ctx);
    	newslettersignup = new NewsletterSignUp({ $$inline: true });
    	let if_block1 = show_if && create_if_block$2(ctx);
    	footer = new Footer({ props: { active: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			article = element("article");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			create_component(newslettersignup.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			create_component(footer.$$.fragment);
    			attr_dev(div0, "class", "contact-section svelte-78c4uq");
    			add_location(div0, file$3, 84, 4, 2407);
    			attr_dev(div1, "class", "contact-section mail svelte-78c4uq");
    			add_location(div1, file$3, 119, 4, 3587);
    			attr_dev(div2, "class", "contact-section svelte-78c4uq");
    			add_location(div2, file$3, 123, 4, 3665);
    			attr_dev(article, "class", "contact svelte-78c4uq");
    			add_location(article, file$3, 82, 2, 2376);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article, anchor);
    			append_dev(article, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(article, t0);
    			append_dev(article, div1);
    			mount_component(newslettersignup, div1, null);
    			append_dev(article, t1);
    			append_dev(article, div2);
    			if (if_block1) if_block1.m(div2, null);
    			insert_dev(target, t2, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$pages*/ 1) show_if_1 = has_1(/*pages*/ ctx[3], "contact.content") && Array.isArray(/*pages*/ ctx[3].contact.content);

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*$pages*/ 1) show_if = has_1(/*pages*/ ctx[3], "socialMedia.content") && Array.isArray(/*pages*/ ctx[3].socialMedia.content);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(newslettersignup.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(newslettersignup.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			if (if_block0) if_block0.d();
    			destroy_component(newslettersignup);
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t2);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$2.name,
    		type: "then",
    		source: "(82:26)    <article class=\\\"contact\\\">      <div class=\\\"contact-section\\\">       {#if has(pages, 'contact.content') && Array.isArray(pages.contact.content)}",
    		ctx
    	});

    	return block;
    }

    // (86:6) {#if has(pages, 'contact.content') && Array.isArray(pages.contact.content)}
    function create_if_block_7(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*pages*/ ctx[3].contact.content;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*console, $pages, get, renderBlockText*/ 1) {
    				each_value_1 = /*pages*/ ctx[3].contact.content;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(86:6) {#if has(pages, 'contact.content') && Array.isArray(pages.contact.content)}",
    		ctx
    	});

    	return block;
    }

    // (88:10) {#if c._type == 'block'}
    function create_if_block_14(ctx) {
    	let html_tag;
    	let raw_value = renderBlockText(/*c*/ ctx[4]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$pages*/ 1 && raw_value !== (raw_value = renderBlockText(/*c*/ ctx[4]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(88:10) {#if c._type == 'block'}",
    		ctx
    	});

    	return block;
    }

    // (91:10) {#if c._type == 'singleImage'}
    function create_if_block_13(ctx) {
    	let image;
    	let current;

    	image = new Image$1({
    			props: {
    				imageObject: /*c*/ ctx[4].image,
    				caption: get_1(/*c*/ ctx[4], "caption", false),
    				alignment: get_1(/*c*/ ctx[4], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[4], "fullwidth", "")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(image.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(image, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const image_changes = {};
    			if (dirty & /*$pages*/ 1) image_changes.imageObject = /*c*/ ctx[4].image;
    			if (dirty & /*$pages*/ 1) image_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			if (dirty & /*$pages*/ 1) image_changes.alignment = get_1(/*c*/ ctx[4], "alignment", "");
    			if (dirty & /*$pages*/ 1) image_changes.fullwidth = get_1(/*c*/ ctx[4], "fullwidth", "");
    			image.$set(image_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(image, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(91:10) {#if c._type == 'singleImage'}",
    		ctx
    	});

    	return block;
    }

    // (98:10) {#if c._type == 'imageGroup'}
    function create_if_block_12(ctx) {
    	let imagegroup;
    	let current;

    	imagegroup = new ImageGroup({
    			props: {
    				imageArray: /*c*/ ctx[4].images,
    				caption: get_1(/*c*/ ctx[4], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(imagegroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(imagegroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagegroup_changes = {};
    			if (dirty & /*$pages*/ 1) imagegroup_changes.imageArray = /*c*/ ctx[4].images;
    			if (dirty & /*$pages*/ 1) imagegroup_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			imagegroup.$set(imagegroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagegroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagegroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(imagegroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(98:10) {#if c._type == 'imageGroup'}",
    		ctx
    	});

    	return block;
    }

    // (103:10) {#if c._type == 'video'}
    function create_if_block_11(ctx) {
    	let videoembed;
    	let current;

    	videoembed = new VideoEmbed({
    			props: {
    				url: /*c*/ ctx[4].video,
    				caption: get_1(/*c*/ ctx[4], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(videoembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoembed, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoembed_changes = {};
    			if (dirty & /*$pages*/ 1) videoembed_changes.url = /*c*/ ctx[4].video;
    			if (dirty & /*$pages*/ 1) videoembed_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			videoembed.$set(videoembed_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(103:10) {#if c._type == 'video'}",
    		ctx
    	});

    	return block;
    }

    // (106:10) {#if c._type == 'slideshow'}
    function create_if_block_10(ctx) {
    	let slideshow;
    	let current;

    	slideshow = new Slideshow({
    			props: { imageArray: /*c*/ ctx[4].images },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slideshow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slideshow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slideshow_changes = {};
    			if (dirty & /*$pages*/ 1) slideshow_changes.imageArray = /*c*/ ctx[4].images;
    			slideshow.$set(slideshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slideshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slideshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slideshow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(106:10) {#if c._type == 'slideshow'}",
    		ctx
    	});

    	return block;
    }

    // (109:10) {#if c._type == 'audio'}
    function create_if_block_9(ctx) {
    	let audio;
    	let current;

    	audio = new Audio({
    			props: { fileObject: /*c*/ ctx[4].audio },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(audio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const audio_changes = {};
    			if (dirty & /*$pages*/ 1) audio_changes.fileObject = /*c*/ ctx[4].audio;
    			audio.$set(audio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(109:10) {#if c._type == 'audio'}",
    		ctx
    	});

    	return block;
    }

    // (112:10) {#if c._type == 'arbitraryEmbed'}
    function create_if_block_8(ctx) {
    	let arbitraryembed;
    	let current;

    	arbitraryembed = new ArbitraryEmbed({
    			props: { code: console.arbitraryEmbed },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(arbitraryembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(arbitraryembed, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(arbitraryembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(arbitraryembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(arbitraryembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(112:10) {#if c._type == 'arbitraryEmbed'}",
    		ctx
    	});

    	return block;
    }

    // (87:8) {#each pages.contact.content as c}
    function create_each_block_1(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let if_block6_anchor;
    	let current;
    	let if_block0 = /*c*/ ctx[4]._type == "block" && create_if_block_14(ctx);
    	let if_block1 = /*c*/ ctx[4]._type == "singleImage" && create_if_block_13(ctx);
    	let if_block2 = /*c*/ ctx[4]._type == "imageGroup" && create_if_block_12(ctx);
    	let if_block3 = /*c*/ ctx[4]._type == "video" && create_if_block_11(ctx);
    	let if_block4 = /*c*/ ctx[4]._type == "slideshow" && create_if_block_10(ctx);
    	let if_block5 = /*c*/ ctx[4]._type == "audio" && create_if_block_9(ctx);
    	let if_block6 = /*c*/ ctx[4]._type == "arbitraryEmbed" && create_if_block_8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*c*/ ctx[4]._type == "block") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_14(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*c*/ ctx[4]._type == "singleImage") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_13(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "imageGroup") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_12(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "video") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_11(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "slideshow") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_10(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t4.parentNode, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "audio") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_9(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t5.parentNode, t5);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "arbitraryEmbed") {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_8(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(87:8) {#each pages.contact.content as c}",
    		ctx
    	});

    	return block;
    }

    // (125:6) {#if has(pages, 'socialMedia.content') && Array.isArray(pages.socialMedia.content)}
    function create_if_block$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*pages*/ ctx[3].socialMedia.content;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$pages, get, renderBlockText*/ 1) {
    				each_value = /*pages*/ ctx[3].socialMedia.content;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(125:6) {#if has(pages, 'socialMedia.content') && Array.isArray(pages.socialMedia.content)}",
    		ctx
    	});

    	return block;
    }

    // (127:10) {#if c._type == 'block'}
    function create_if_block_6$1(ctx) {
    	let html_tag;
    	let raw_value = renderBlockText(/*c*/ ctx[4]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$pages*/ 1 && raw_value !== (raw_value = renderBlockText(/*c*/ ctx[4]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(127:10) {#if c._type == 'block'}",
    		ctx
    	});

    	return block;
    }

    // (130:10) {#if c._type == 'singleImage'}
    function create_if_block_5$1(ctx) {
    	let image;
    	let current;

    	image = new Image$1({
    			props: {
    				imageObject: /*c*/ ctx[4].image,
    				caption: get_1(/*c*/ ctx[4], "caption", false),
    				alignment: get_1(/*c*/ ctx[4], "alignment", ""),
    				fullwidth: get_1(/*c*/ ctx[4], "fullwidth", "")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(image.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(image, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const image_changes = {};
    			if (dirty & /*$pages*/ 1) image_changes.imageObject = /*c*/ ctx[4].image;
    			if (dirty & /*$pages*/ 1) image_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			if (dirty & /*$pages*/ 1) image_changes.alignment = get_1(/*c*/ ctx[4], "alignment", "");
    			if (dirty & /*$pages*/ 1) image_changes.fullwidth = get_1(/*c*/ ctx[4], "fullwidth", "");
    			image.$set(image_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(image.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(image.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(image, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(130:10) {#if c._type == 'singleImage'}",
    		ctx
    	});

    	return block;
    }

    // (137:10) {#if c._type == 'imageGroup'}
    function create_if_block_4$1(ctx) {
    	let imagegroup;
    	let current;

    	imagegroup = new ImageGroup({
    			props: {
    				imageArray: /*c*/ ctx[4].images,
    				caption: get_1(/*c*/ ctx[4], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(imagegroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(imagegroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagegroup_changes = {};
    			if (dirty & /*$pages*/ 1) imagegroup_changes.imageArray = /*c*/ ctx[4].images;
    			if (dirty & /*$pages*/ 1) imagegroup_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			imagegroup.$set(imagegroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagegroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagegroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(imagegroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(137:10) {#if c._type == 'imageGroup'}",
    		ctx
    	});

    	return block;
    }

    // (142:10) {#if c._type == 'video'}
    function create_if_block_3$1(ctx) {
    	let videoembed;
    	let current;

    	videoembed = new VideoEmbed({
    			props: {
    				url: /*c*/ ctx[4].video,
    				caption: get_1(/*c*/ ctx[4], "caption", false)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(videoembed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoembed, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoembed_changes = {};
    			if (dirty & /*$pages*/ 1) videoembed_changes.url = /*c*/ ctx[4].video;
    			if (dirty & /*$pages*/ 1) videoembed_changes.caption = get_1(/*c*/ ctx[4], "caption", false);
    			videoembed.$set(videoembed_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoembed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoembed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoembed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(142:10) {#if c._type == 'video'}",
    		ctx
    	});

    	return block;
    }

    // (145:10) {#if c._type == 'slideshow'}
    function create_if_block_2$1(ctx) {
    	let slideshow;
    	let current;

    	slideshow = new Slideshow({
    			props: { imageArray: /*c*/ ctx[4].images },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slideshow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slideshow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slideshow_changes = {};
    			if (dirty & /*$pages*/ 1) slideshow_changes.imageArray = /*c*/ ctx[4].images;
    			slideshow.$set(slideshow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slideshow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slideshow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slideshow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(145:10) {#if c._type == 'slideshow'}",
    		ctx
    	});

    	return block;
    }

    // (148:10) {#if c._type == 'audio'}
    function create_if_block_1$1(ctx) {
    	let audio;
    	let current;

    	audio = new Audio({
    			props: { fileObject: /*c*/ ctx[4].audio },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(audio.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audio, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const audio_changes = {};
    			if (dirty & /*$pages*/ 1) audio_changes.fileObject = /*c*/ ctx[4].audio;
    			audio.$set(audio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audio, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(148:10) {#if c._type == 'audio'}",
    		ctx
    	});

    	return block;
    }

    // (126:8) {#each pages.socialMedia.content as c}
    function create_each_block(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let if_block5_anchor;
    	let current;
    	let if_block0 = /*c*/ ctx[4]._type == "block" && create_if_block_6$1(ctx);
    	let if_block1 = /*c*/ ctx[4]._type == "singleImage" && create_if_block_5$1(ctx);
    	let if_block2 = /*c*/ ctx[4]._type == "imageGroup" && create_if_block_4$1(ctx);
    	let if_block3 = /*c*/ ctx[4]._type == "video" && create_if_block_3$1(ctx);
    	let if_block4 = /*c*/ ctx[4]._type == "slideshow" && create_if_block_2$1(ctx);
    	let if_block5 = /*c*/ ctx[4]._type == "audio" && create_if_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			if_block5_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*c*/ ctx[4]._type == "block") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*c*/ ctx[4]._type == "singleImage") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "imageGroup") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_4$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "video") {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_3$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "slideshow") {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_2$1(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t4.parentNode, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*c*/ ctx[4]._type == "audio") {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*$pages*/ 1) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_1$1(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(126:8) {#each pages.socialMedia.content as c}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  CONTACT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }
    function create_pending_block$2(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$2.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  CONTACT   //   // # # # # # # # # # # # # #    // *** IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let metadata;
    	let t;
    	let await_block_anchor;
    	let promise;
    	let current;

    	metadata = new MetaData({
    			props: { post: { title: "Contact" } },
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		value: 3,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*$pages*/ ctx[0], info);

    	const block = {
    		c: function create() {
    			create_component(metadata.$$.fragment);
    			t = space();
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(metadata, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$pages*/ 1 && promise !== (promise = /*$pages*/ ctx[0]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[3] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(metadata.$$.fragment, local);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(metadata.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(metadata, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $pages;
    	validate_store(pages, "pages");
    	component_subscribe($$self, pages, $$value => $$invalidate(0, $pages = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Contact", slots, []);
    	let { slug = "" } = $$props;
    	let { location = {} } = $$props;

    	// LOGIC
    	navigationColor.set("black");

    	scrollListActive.set(false);

    	// *** ON MOUNT
    	onMount(async () => {
    		window.scrollTo(0, 0);
    	});

    	const writable_props = ["slug", "location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Contact> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("slug" in $$props) $$invalidate(1, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(2, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		navigationColor,
    		pages,
    		scrollListActive,
    		renderBlockText,
    		get: get_1,
    		has: has_1,
    		Footer,
    		NewsletterSignUp,
    		MetaData,
    		Image: Image$1,
    		ImageGroup,
    		VideoEmbed,
    		ArbitraryEmbed,
    		Audio,
    		Slideshow,
    		slug,
    		location,
    		$pages
    	});

    	$$self.$inject_state = $$props => {
    		if ("slug" in $$props) $$invalidate(1, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(2, location = $$props.location);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$pages, slug, location];
    }

    class Contact extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { slug: 1, location: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Contact",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get slug() {
    		throw new Error("<Contact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slug(value) {
    		throw new Error("<Contact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<Contact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<Contact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Routes/Satellite.svelte generated by Svelte v3.35.0 */

    const { console: console_1 } = globals;

    const file$2 = "src/Routes/Satellite.svelte";

    // (1:0) <script>     // # # # # # # # # # # # # #     //     //  SATELLITE SITE TEMPLATE     //     // # # # # # # # # # # # # #        // *** IMPORTS     import { onMount, onDestroy }
    function create_catch_block$1(ctx) {
    	const block = { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block$1.name,
    		type: "catch",
    		source: "(1:0) <script>     // # # # # # # # # # # # # #     //     //  SATELLITE SITE TEMPLATE     //     // # # # # # # # # # # # # #        // *** IMPORTS     import { onMount, onDestroy }",
    		ctx
    	});

    	return block;
    }

    // (71:33)      <!-- <MetaData {post}
    function create_then_block$1(ctx) {
    	let div2;
    	let div1;
    	let t0;
    	let div0;
    	let t1_value = /*siteData*/ ctx[0].title + "";
    	let t1;
    	let if_block = /*siteData*/ ctx[0].mainImage && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			add_location(div0, file$2, 83, 12, 2497);
    			add_location(div1, file$2, 73, 8, 2161);
    			attr_dev(div2, "class", "satellite svelte-aa46jn");
    			add_location(div2, file$2, 72, 4, 2129);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (/*siteData*/ ctx[0].mainImage) if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block$1.name,
    		type: "then",
    		source: "(71:33)      <!-- <MetaData {post}",
    		ctx
    	});

    	return block;
    }

    // (75:12) {#if siteData.mainImage}
    function create_if_block$1(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", /*siteData*/ ctx[0].title);
    			if (img.src !== (img_src_value = urlFor(/*siteData*/ ctx[0].mainImage).height(600).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			add_location(img, file$2, 75, 16, 2220);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(75:12) {#if siteData.mainImage}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>     // # # # # # # # # # # # # #     //     //  SATELLITE SITE TEMPLATE     //     // # # # # # # # # # # # # #        // *** IMPORTS     import { onMount, onDestroy }
    function create_pending_block$1(ctx) {
    	const block = { c: noop$1, m: noop$1, p: noop$1, d: noop$1 };

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block$1.name,
    		type: "pending",
    		source: "(1:0) <script>     // # # # # # # # # # # # # #     //     //  SATELLITE SITE TEMPLATE     //     // # # # # # # # # # # # # #        // *** IMPORTS     import { onMount, onDestroy }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let await_block_anchor;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 0
    	};

    	handle_promise(/*siteData*/ ctx[0], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				child_ctx[0] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const query = "*[_type == 'satelliteSite' && slug.current == $slug]{...}[0]";

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Satellite", slots, []);
    	let { slug = "" } = $$props;
    	let { location = {} } = $$props;
    	satelliteSiteActive.set(true);
    	console.log("slug", slug);
    	let siteData = loadSatelliteSite(query, { slug });

    	siteData.then(s => {
    		console.log("siteData", s);
    	});

    	// *** ON MOUNT
    	onDestroy(async () => {
    		satelliteSiteActive.set(false);
    	});

    	const writable_props = ["slug", "location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Satellite> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("slug" in $$props) $$invalidate(1, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(2, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		fade,
    		get: get_1,
    		isEmpty: isEmpty_1,
    		urlFor,
    		loadSatelliteSite,
    		renderBlockText,
    		satelliteSiteActive,
    		slug,
    		location,
    		query,
    		siteData
    	});

    	$$self.$inject_state = $$props => {
    		if ("slug" in $$props) $$invalidate(1, slug = $$props.slug);
    		if ("location" in $$props) $$invalidate(2, location = $$props.location);
    		if ("siteData" in $$props) $$invalidate(0, siteData = $$props.siteData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [siteData, slug, location];
    }

    class Satellite extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { slug: 1, location: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Satellite",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get slug() {
    		throw new Error("<Satellite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slug(value) {
    		throw new Error("<Satellite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<Satellite>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<Satellite>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Routes/Error404.svelte generated by Svelte v3.35.0 */
    const file$1 = "src/Routes/Error404.svelte";

    function create_fragment$1(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let br;
    	let t2;
    	let t3;
    	let footer;
    	let current;
    	footer = new Footer({ props: { active: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			t0 = space();
    			div = element("div");
    			t1 = text("404\n  ");
    			br = element("br");
    			t2 = text("\n  Page not found");
    			t3 = space();
    			create_component(footer.$$.fragment);
    			document.title = "404 / NOVEMBRE";
    			add_location(br, file$1, 38, 2, 740);
    			attr_dev(div, "class", "placeholder svelte-e1lz7v");
    			add_location(div, file$1, 36, 0, 706);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    			append_dev(div, br);
    			append_dev(div, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Error404", slots, []);
    	let { title } = $$props;
    	let { location = {} } = $$props;

    	onMount(async () => {
    		window.scrollTo(0, 0);
    	});

    	const writable_props = ["title", "location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Error404> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("location" in $$props) $$invalidate(1, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({ Footer, onMount, title, location });

    	$$self.$inject_state = $$props => {
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    		if ("location" in $$props) $$invalidate(1, location = $$props.location);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, location];
    }

    class Error404 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { title: 0, location: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Error404",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
    			console.warn("<Error404> was created without expected prop 'title'");
    		}
    	}

    	get title() {
    		throw new Error("<Error404>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Error404>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<Error404>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<Error404>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.35.0 */
    const file = "src/App.svelte";

    // (384:0) {#if !$satelliteSiteActive}
    function create_if_block(ctx) {
    	let navigation;
    	let t0;
    	let promise;
    	let t1;
    	let t2;
    	let if_block1_anchor;
    	let current;
    	navigation = new Navigation({ $$inline: true });

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block_1,
    		value: 14,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*$pages*/ ctx[3], info);
    	let if_block0 = /*$scrollListActive*/ ctx[5] && /*$activeCategory*/ ctx[6] === "magazine" && create_if_block_2(ctx);
    	let if_block1 = /*$scrollListActive*/ ctx[5] && /*$activeCategory*/ ctx[6] === "bureau" && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			create_component(navigation.$$.fragment);
    			t0 = space();
    			info.block.c();
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(navigation, target, anchor);
    			insert_dev(target, t0, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => t1.parentNode;
    			info.anchor = t1;
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			info.ctx = ctx;

    			if (dirty & /*$pages*/ 8 && promise !== (promise = /*$pages*/ ctx[3]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[14] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			if (/*$scrollListActive*/ ctx[5] && /*$activeCategory*/ ctx[6] === "magazine") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$scrollListActive, $activeCategory*/ 96) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$scrollListActive*/ ctx[5] && /*$activeCategory*/ ctx[6] === "bureau") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$scrollListActive, $activeCategory*/ 96) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navigation.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navigation.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navigation, detaching);
    			if (detaching) detach_dev(t0);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(384:0) {#if !$satelliteSiteActive}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import "intersection-observer";   import { Router, Route }
    function create_catch_block_1(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import \\\"intersection-observer\\\";   import { Router, Route }",
    		ctx
    	});

    	return block;
    }

    // (389:28)      {#if pages.showMailingListOverlay && mailingListOverlayActive}
    function create_then_block(ctx) {
    	let t;
    	let await_block_anchor;
    	let promise;
    	let current;
    	let if_block = /*pages*/ ctx[14].showMailingListOverlay && /*mailingListOverlayActive*/ ctx[1] && create_if_block_6(ctx);

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block,
    		value: 15
    	};

    	handle_promise(promise = /*$overlayBanners*/ ctx[4], info);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*pages*/ ctx[14].showMailingListOverlay && /*mailingListOverlayActive*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$pages, mailingListOverlayActive*/ 10) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			info.ctx = ctx;

    			if (dirty & /*$overlayBanners*/ 16 && promise !== (promise = /*$overlayBanners*/ ctx[4]) && handle_promise(promise, info)) ; else {
    				const child_ctx = ctx.slice();
    				child_ctx[15] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(389:28)      {#if pages.showMailingListOverlay && mailingListOverlayActive}",
    		ctx
    	});

    	return block;
    }

    // (390:4) {#if pages.showMailingListOverlay && mailingListOverlayActive}
    function create_if_block_6(ctx) {
    	let div1;
    	let div0;
    	let newslettersignup;
    	let t;
    	let svg;
    	let g;
    	let path;
    	let div1_intro;
    	let current;
    	let mounted;
    	let dispose;
    	newslettersignup = new NewsletterSignUp({ props: { compact: true }, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(newslettersignup.$$.fragment);
    			t = space();
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path = svg_element("path");
    			attr_dev(div0, "class", "inner");
    			add_location(div0, file, 397, 8, 10733);
    			attr_dev(path, "d", "M146.3,4961c-27.2-27.2-46.3-73.5-46.3-103.5c0-32.7,876.6-928.3,2346.6-2398.3L4795.8,110L2446.6-2239.3C840.4-3845.4,100-4604.9,100-4643c0-68.1,81.7-147,152.4-147c32.7,0,928.3,876.6,2398.3,2346.6L5000-94.2l2349.3-2349.3C8955.4-4049.6,9714.9-4790,9753-4790c68.1,0,147,81.7,147,152.4c0,32.7-876.6,928.3-2346.6,2398.3L5204.2,110l2349.3,2349.3C9159.5,4065.4,9900,4824.9,9900,4863c0,68.1-81.7,147-152.4,147c-32.7,0-928.3-876.6-2398.3-2346.6L5000,314.2L2650.7,2663.4C1044.6,4269.6,285.1,5010,247,5010C214.3,5010,170.8,4988.2,146.3,4961z");
    			add_location(path, file, 414, 12, 11304);
    			attr_dev(g, "transform", "translate(0.000000,511.000000) scale(0.100000,-0.100000)");
    			add_location(g, file, 413, 10, 11219);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "class", "close");
    			attr_dev(svg, "viewBox", "0 0 1000 1000");
    			attr_dev(svg, "enable-background", "new 0 0 1000 1000");
    			attr_dev(svg, "xml:space", "preserve");
    			add_location(svg, file, 400, 8, 10822);
    			attr_dev(div1, "id", "mailing-list-overlay");
    			attr_dev(div1, "class", "overlay-banner mailing-list");
    			add_location(div1, file, 390, 6, 10501);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(newslettersignup, div0, null);
    			append_dev(div1, t);
    			append_dev(div1, svg);
    			append_dev(svg, g);
    			append_dev(g, path);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[10], false, false, false),
    					listen_dev(div1, "click", /*click_handler_1*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newslettersignup.$$.fragment, local);

    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, fade, {});
    					div1_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newslettersignup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(newslettersignup);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(390:4) {#if pages.showMailingListOverlay && mailingListOverlayActive}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import "intersection-observer";   import { Router, Route }
    function create_catch_block(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import \\\"intersection-observer\\\";   import { Router, Route }",
    		ctx
    	});

    	return block;
    }

    // (422:48)        {#if !isEmpty(overlayBanners) && overlayActive}
    function create_then_block_1(ctx) {
    	let show_if = !isEmpty_1(/*overlayBanners*/ ctx[15]) && /*overlayActive*/ ctx[0];
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$overlayBanners, overlayActive*/ 17) show_if = !isEmpty_1(/*overlayBanners*/ ctx[15]) && /*overlayActive*/ ctx[0];

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$overlayBanners, overlayActive*/ 17) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			transition_in(if_block);
    		},
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(422:48)        {#if !isEmpty(overlayBanners) && overlayActive}",
    		ctx
    	});

    	return block;
    }

    // (423:6) {#if !isEmpty(overlayBanners) && overlayActive}
    function create_if_block_3(ctx) {
    	let div;
    	let a;
    	let t0;
    	let a_href_value;
    	let t1;
    	let svg;
    	let g;
    	let path;
    	let div_intro;
    	let mounted;
    	let dispose;
    	let if_block0 = /*overlayBanners*/ ctx[15][0].video && /*overlayBanners*/ ctx[15][0].video.asset && /*overlayBanners*/ ctx[15][0].video.asset._ref && create_if_block_5(ctx);
    	let if_block1 = /*overlayBanners*/ ctx[15][0].image && create_if_block_4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path = svg_element("path");
    			attr_dev(a, "href", a_href_value = /*overlayBanners*/ ctx[15][0].link);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer");
    			attr_dev(a, "class", "inner");
    			add_location(a, file, 429, 10, 12167);
    			attr_dev(path, "d", "M146.3,4961c-27.2-27.2-46.3-73.5-46.3-103.5c0-32.7,876.6-928.3,2346.6-2398.3L4795.8,110L2446.6-2239.3C840.4-3845.4,100-4604.9,100-4643c0-68.1,81.7-147,152.4-147c32.7,0,928.3,876.6,2398.3,2346.6L5000-94.2l2349.3-2349.3C8955.4-4049.6,9714.9-4790,9753-4790c68.1,0,147,81.7,147,152.4c0,32.7-876.6,928.3-2346.6,2398.3L5204.2,110l2349.3,2349.3C9159.5,4065.4,9900,4824.9,9900,4863c0,68.1-81.7,147-152.4,147c-32.7,0-928.3-876.6-2398.3-2346.6L5000,314.2L2650.7,2663.4C1044.6,4269.6,285.1,5010,247,5010C214.3,5010,170.8,4988.2,146.3,4961z");
    			add_location(path, file, 470, 14, 13592);
    			attr_dev(g, "transform", "translate(0.000000,511.000000) scale(0.100000,-0.100000)");
    			add_location(g, file, 468, 12, 13491);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "class", "close");
    			attr_dev(svg, "viewBox", "0 0 1000 1000");
    			attr_dev(svg, "enable-background", "new 0 0 1000 1000");
    			attr_dev(svg, "xml:space", "preserve");
    			add_location(svg, file, 455, 10, 13079);
    			attr_dev(div, "class", "overlay-banner");
    			add_location(div, file, 423, 8, 12025);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, a);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);
    			if (if_block1) if_block1.m(a, null);
    			append_dev(div, t1);
    			append_dev(div, svg);
    			append_dev(svg, g);
    			append_dev(g, path);

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler_2*/ ctx[12], false, false, false),
    					listen_dev(div, "click", /*click_handler_3*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*overlayBanners*/ ctx[15][0].video && /*overlayBanners*/ ctx[15][0].video.asset && /*overlayBanners*/ ctx[15][0].video.asset._ref) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*overlayBanners*/ ctx[15][0].image) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(a, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$overlayBanners*/ 16 && a_href_value !== (a_href_value = /*overlayBanners*/ ctx[15][0].link)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fade, {});
    					div_intro.start();
    				});
    			}
    		},
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(423:6) {#if !isEmpty(overlayBanners) && overlayActive}",
    		ctx
    	});

    	return block;
    }

    // (435:12) {#if overlayBanners[0].video && overlayBanners[0].video.asset && overlayBanners[0].video.asset._ref}
    function create_if_block_5(ctx) {
    	let video;
    	let video_src_value;

    	const block = {
    		c: function create() {
    			video = element("video");
    			video.playsInline = "playsinline";
    			if (video.src !== (video_src_value = "https://cdn.sanity.io/files/gj963qwj/production/" + /*overlayBanners*/ ctx[15][0].video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"))) attr_dev(video, "src", video_src_value);
    			video.autoplay = true;
    			video.muted = true;
    			video.loop = true;
    			add_location(video, file, 435, 14, 12423);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$overlayBanners*/ 16 && video.src !== (video_src_value = "https://cdn.sanity.io/files/gj963qwj/production/" + /*overlayBanners*/ ctx[15][0].video.asset._ref.replace("file-", "").replace("-mp4", ".mp4"))) {
    				attr_dev(video, "src", video_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(435:12) {#if overlayBanners[0].video && overlayBanners[0].video.asset && overlayBanners[0].video.asset._ref}",
    		ctx
    	});

    	return block;
    }

    // (445:12) {#if overlayBanners[0].image}
    function create_if_block_4(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "alt", "novembre.global");
    			if (img.src !== (img_src_value = urlFor(/*overlayBanners*/ ctx[15][0].image).width(1000).quality(90).auto("format").url())) attr_dev(img, "src", img_src_value);
    			add_location(img, file, 445, 14, 12814);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$overlayBanners*/ 16 && img.src !== (img_src_value = urlFor(/*overlayBanners*/ ctx[15][0].image).width(1000).quality(90).auto("format").url())) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(445:12) {#if overlayBanners[0].image}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import "intersection-observer";   import { Router, Route }
    function create_pending_block_1(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import \\\"intersection-observer\\\";   import { Router, Route }",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import "intersection-observer";   import { Router, Route }
    function create_pending_block(ctx) {
    	const block = {
    		c: noop$1,
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  NOVEMBRE.GLOBAL   //   // # # # # # # # # # # # # #    // IMPORTS   import \\\"intersection-observer\\\";   import { Router, Route }",
    		ctx
    	});

    	return block;
    }

    // (480:2) {#if $scrollListActive && $activeCategory === 'magazine'}
    function create_if_block_2(ctx) {
    	let scrolllist;
    	let current;

    	scrolllist = new ScrollList({
    			props: { tagArray: /*magazineTags*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(scrolllist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(scrolllist, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrolllist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrolllist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scrolllist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(480:2) {#if $scrollListActive && $activeCategory === 'magazine'}",
    		ctx
    	});

    	return block;
    }

    // (484:2) {#if $scrollListActive && $activeCategory === 'bureau'}
    function create_if_block_1(ctx) {
    	let scrolllist;
    	let current;

    	scrolllist = new ScrollList({
    			props: { tagArray: /*bureauTags*/ ctx[9] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(scrolllist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(scrolllist, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(scrolllist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(scrolllist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(scrolllist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(484:2) {#if $scrollListActive && $activeCategory === 'bureau'}",
    		ctx
    	});

    	return block;
    }

    // (489:0) <Router>
    function create_default_slot(ctx) {
    	let route0;
    	let t0;
    	let route1;
    	let t1;
    	let route2;
    	let t2;
    	let route3;
    	let t3;
    	let route4;
    	let t4;
    	let route5;
    	let t5;
    	let route6;
    	let t6;
    	let route7;
    	let t7;
    	let route8;
    	let t8;
    	let route9;
    	let t9;
    	let route10;
    	let t10;
    	let route11;
    	let t11;
    	let route12;
    	let t12;
    	let route13;
    	let t13;
    	let route14;
    	let t14;
    	let route15;
    	let current;
    	const route0_spread_levels = [{ path: "/" }, { component: Listing }, /*listingRouteParams*/ ctx[7].landing];
    	let route0_props = {};

    	for (let i = 0; i < route0_spread_levels.length; i += 1) {
    		route0_props = assign$2(route0_props, route0_spread_levels[i]);
    	}

    	route0 = new Route({ props: route0_props, $$inline: true });

    	route1 = new Route({
    			props: {
    				path: "site/:slug",
    				component: Satellite
    			},
    			$$inline: true
    		});

    	const route2_spread_levels = [
    		{ path: "magazine/" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].magazine
    	];

    	let route2_props = {};

    	for (let i = 0; i < route2_spread_levels.length; i += 1) {
    		route2_props = assign$2(route2_props, route2_spread_levels[i]);
    	}

    	route2 = new Route({ props: route2_props, $$inline: true });

    	const route3_spread_levels = [
    		{ path: "bureau" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].bureau
    	];

    	let route3_props = {};

    	for (let i = 0; i < route3_spread_levels.length; i += 1) {
    		route3_props = assign$2(route3_props, route3_spread_levels[i]);
    	}

    	route3 = new Route({ props: route3_props, $$inline: true });

    	const route4_spread_levels = [
    		{ path: "magazine/category/:query" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].magazineSub
    	];

    	let route4_props = {};

    	for (let i = 0; i < route4_spread_levels.length; i += 1) {
    		route4_props = assign$2(route4_props, route4_spread_levels[i]);
    	}

    	route4 = new Route({ props: route4_props, $$inline: true });

    	const route5_spread_levels = [
    		{ path: "bureau/category/:query" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].bureauSub
    	];

    	let route5_props = {};

    	for (let i = 0; i < route5_spread_levels.length; i += 1) {
    		route5_props = assign$2(route5_props, route5_spread_levels[i]);
    	}

    	route5 = new Route({ props: route5_props, $$inline: true });

    	const route6_spread_levels = [
    		{ path: "taxonomy/:query" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].taxonomy
    	];

    	let route6_props = {};

    	for (let i = 0; i < route6_spread_levels.length; i += 1) {
    		route6_props = assign$2(route6_props, route6_spread_levels[i]);
    	}

    	route6 = new Route({ props: route6_props, $$inline: true });

    	const route7_spread_levels = [
    		{ path: "taxonomy/" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].taxonomy
    	];

    	let route7_props = {};

    	for (let i = 0; i < route7_spread_levels.length; i += 1) {
    		route7_props = assign$2(route7_props, route7_spread_levels[i]);
    	}

    	route7 = new Route({ props: route7_props, $$inline: true });

    	const route8_spread_levels = [
    		{ path: "search/:query" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].search
    	];

    	let route8_props = {};

    	for (let i = 0; i < route8_spread_levels.length; i += 1) {
    		route8_props = assign$2(route8_props, route8_spread_levels[i]);
    	}

    	route8 = new Route({ props: route8_props, $$inline: true });

    	const route9_spread_levels = [
    		{ path: "search/" },
    		{ component: Listing },
    		/*listingRouteParams*/ ctx[7].search
    	];

    	let route9_props = {};

    	for (let i = 0; i < route9_spread_levels.length; i += 1) {
    		route9_props = assign$2(route9_props, route9_spread_levels[i]);
    	}

    	route9 = new Route({ props: route9_props, $$inline: true });

    	route10 = new Route({
    			props: {
    				path: "magazine/:slug",
    				component: Article
    			},
    			$$inline: true
    		});

    	route11 = new Route({
    			props: { path: "bureau/:slug", component: Article },
    			$$inline: true
    		});

    	route12 = new Route({
    			props: { path: "about", component: About },
    			$$inline: true
    		});

    	route13 = new Route({
    			props: { path: "contact", component: Contact },
    			$$inline: true
    		});

    	route14 = new Route({
    			props: {
    				path: "404",
    				component: Error404,
    				title: "404"
    			},
    			$$inline: true
    		});

    	route15 = new Route({
    			props: { component: Error404, title: "404" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route0.$$.fragment);
    			t0 = space();
    			create_component(route1.$$.fragment);
    			t1 = space();
    			create_component(route2.$$.fragment);
    			t2 = space();
    			create_component(route3.$$.fragment);
    			t3 = space();
    			create_component(route4.$$.fragment);
    			t4 = space();
    			create_component(route5.$$.fragment);
    			t5 = space();
    			create_component(route6.$$.fragment);
    			t6 = space();
    			create_component(route7.$$.fragment);
    			t7 = space();
    			create_component(route8.$$.fragment);
    			t8 = space();
    			create_component(route9.$$.fragment);
    			t9 = space();
    			create_component(route10.$$.fragment);
    			t10 = space();
    			create_component(route11.$$.fragment);
    			t11 = space();
    			create_component(route12.$$.fragment);
    			t12 = space();
    			create_component(route13.$$.fragment);
    			t13 = space();
    			create_component(route14.$$.fragment);
    			t14 = space();
    			create_component(route15.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(route1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(route2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(route3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(route4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(route5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(route6, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(route7, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(route8, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(route9, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(route10, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(route11, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(route12, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(route13, target, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(route14, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(route15, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route0_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route0_spread_levels, [
    					route0_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].landing)
    				])
    			: {};

    			route0.$set(route0_changes);

    			const route2_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route2_spread_levels, [
    					route2_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].magazine)
    				])
    			: {};

    			route2.$set(route2_changes);

    			const route3_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route3_spread_levels, [
    					route3_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].bureau)
    				])
    			: {};

    			route3.$set(route3_changes);

    			const route4_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route4_spread_levels, [
    					route4_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].magazineSub)
    				])
    			: {};

    			route4.$set(route4_changes);

    			const route5_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route5_spread_levels, [
    					route5_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].bureauSub)
    				])
    			: {};

    			route5.$set(route5_changes);

    			const route6_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route6_spread_levels, [
    					route6_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].taxonomy)
    				])
    			: {};

    			route6.$set(route6_changes);

    			const route7_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route7_spread_levels, [
    					route7_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].taxonomy)
    				])
    			: {};

    			route7.$set(route7_changes);

    			const route8_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route8_spread_levels, [
    					route8_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].search)
    				])
    			: {};

    			route8.$set(route8_changes);

    			const route9_changes = (dirty & /*Listing, listingRouteParams*/ 128)
    			? get_spread_update(route9_spread_levels, [
    					route9_spread_levels[0],
    					dirty & /*Listing*/ 0 && { component: Listing },
    					dirty & /*listingRouteParams*/ 128 && get_spread_object(/*listingRouteParams*/ ctx[7].search)
    				])
    			: {};

    			route9.$set(route9_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(route6.$$.fragment, local);
    			transition_in(route7.$$.fragment, local);
    			transition_in(route8.$$.fragment, local);
    			transition_in(route9.$$.fragment, local);
    			transition_in(route10.$$.fragment, local);
    			transition_in(route11.$$.fragment, local);
    			transition_in(route12.$$.fragment, local);
    			transition_in(route13.$$.fragment, local);
    			transition_in(route14.$$.fragment, local);
    			transition_in(route15.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(route6.$$.fragment, local);
    			transition_out(route7.$$.fragment, local);
    			transition_out(route8.$$.fragment, local);
    			transition_out(route9.$$.fragment, local);
    			transition_out(route10.$$.fragment, local);
    			transition_out(route11.$$.fragment, local);
    			transition_out(route12.$$.fragment, local);
    			transition_out(route13.$$.fragment, local);
    			transition_out(route14.$$.fragment, local);
    			transition_out(route15.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(route1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(route2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(route3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(route4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(route5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(route6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(route7, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(route8, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(route9, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(route10, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(route11, detaching);
    			if (detaching) detach_dev(t11);
    			destroy_component(route12, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(route13, detaching);
    			if (detaching) detach_dev(t13);
    			destroy_component(route14, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(route15, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(489:0) <Router>",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let t;
    	let router;
    	let current;
    	let if_block = !/*$satelliteSiteActive*/ ctx[2] && create_if_block(ctx);

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*$satelliteSiteActive*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$satelliteSiteActive*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const router_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $satelliteSiteActive;
    	let $pages;
    	let $overlayBanners;
    	let $scrollListActive;
    	let $activeCategory;
    	validate_store(satelliteSiteActive, "satelliteSiteActive");
    	component_subscribe($$self, satelliteSiteActive, $$value => $$invalidate(2, $satelliteSiteActive = $$value));
    	validate_store(pages, "pages");
    	component_subscribe($$self, pages, $$value => $$invalidate(3, $pages = $$value));
    	validate_store(overlayBanners, "overlayBanners");
    	component_subscribe($$self, overlayBanners, $$value => $$invalidate(4, $overlayBanners = $$value));
    	validate_store(scrollListActive, "scrollListActive");
    	component_subscribe($$self, scrollListActive, $$value => $$invalidate(5, $scrollListActive = $$value));
    	validate_store(activeCategory, "activeCategory");
    	component_subscribe($$self, activeCategory, $$value => $$invalidate(6, $activeCategory = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	let overlayActive = false;
    	let mailingListOverlayActive = false;
    	pages.set(loadPages("*[_id == \"global-config\"][0]"));
    	menuBanners.set(loadPages("*[_type == \"banner\" && editorialState == \"live\" && placeInMenu]"));
    	feedBanners.set(loadPages("*[_type == \"banner\" && editorialState == \"live\" && placeInFeed]"));
    	overlayBanners.set(loadPages("*[_type == \"banner\" && editorialState == \"live\" && placeAsOverlay]"));

    	const listingRouteParams = {
    		landing: { title: "Landing" },
    		magazine: { title: "Magazine" },
    		bureau: { title: "Bureau" },
    		magazineSub: { title: "magsub" },
    		bureauSub: { title: "bursub" },
    		taxonomy: { title: "Tag" },
    		search: { title: "Search" }
    	};

    	const magazineTags = [
    		{ title: "Reportage", slug: "reportage" },
    		{ title: "Motion", slug: "motion" },
    		{ title: "Words", slug: "words" },
    		{ title: "Features", slug: "features" },
    		{
    			title: "Guest Features",
    			slug: "guest-features"
    		},
    		{ title: "Sounds", slug: "sounds" }
    	];

    	const bureauTags = [
    		{
    			title: "Creative Direction",
    			slug: "creative-direction"
    		},
    		{ title: "Workshop", slug: "workshop" },
    		{
    			title: "Entertainment",
    			slug: "entertainment"
    		},
    		{
    			title: "Creative Direction",
    			slug: "creative-direction"
    		},
    		{ title: "Workshop", slug: "workshop" },
    		{
    			title: "Entertainment",
    			slug: "entertainment"
    		}
    	];

    	if (!js_cookie.get("nov_seen-banner")) {
    		setTimeout(
    			() => {
    				$$invalidate(0, overlayActive = true);
    			},
    			3000
    		);

    		js_cookie.set("nov_seen-banner", "true", { expires: 1 / 24 });
    	}

    	if (!js_cookie.get("nov_seen-mailing-list")) {
    		setTimeout(
    			() => {
    				$$invalidate(1, mailingListOverlayActive = true);
    			},
    			3000
    		);

    		js_cookie.set("nov_seen-mailing-list", "true", { expires: 1 / 24 });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		$$invalidate(1, mailingListOverlayActive = false);
    	};

    	const click_handler_1 = e => {
    		if (e.target.id === "mailing-list-overlay") $$invalidate(1, mailingListOverlayActive = false);
    	};

    	const click_handler_2 = e => {
    		$$invalidate(0, overlayActive = false);
    	};

    	const click_handler_3 = e => {
    		$$invalidate(0, overlayActive = false);
    	};

    	$$self.$capture_state = () => ({
    		Router,
    		Route,
    		Navigation,
    		isEmpty: isEmpty_1,
    		urlFor,
    		loadPages,
    		Cookies: js_cookie,
    		fade,
    		ScrollList,
    		NewsletterSignUp,
    		pages,
    		menuBanners,
    		feedBanners,
    		overlayBanners,
    		scrollListActive,
    		activeCategory,
    		satelliteSiteActive,
    		Listing,
    		Article,
    		About,
    		Contact,
    		SatelliteSite: Satellite,
    		Error404,
    		overlayActive,
    		mailingListOverlayActive,
    		listingRouteParams,
    		magazineTags,
    		bureauTags,
    		$satelliteSiteActive,
    		$pages,
    		$overlayBanners,
    		$scrollListActive,
    		$activeCategory
    	});

    	$$self.$inject_state = $$props => {
    		if ("overlayActive" in $$props) $$invalidate(0, overlayActive = $$props.overlayActive);
    		if ("mailingListOverlayActive" in $$props) $$invalidate(1, mailingListOverlayActive = $$props.mailingListOverlayActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		overlayActive,
    		mailingListOverlayActive,
    		$satelliteSiteActive,
    		$pages,
    		$overlayBanners,
    		$scrollListActive,
    		$activeCategory,
    		listingRouteParams,
    		magazineTags,
    		bureauTags,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    Sentry.init({ dsn: 'https://3ec1d72489f24257a8450b9fef408507@sentry.io/1757183' });

    const app = new App({
      target: document.body
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
